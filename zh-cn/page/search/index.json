[{"content":"前言 打算从这期记录一些每周的科技相关的随笔，还有一些感悟之类的。大概每两周到一个月更新一期吧。\n个人博客从 Hugo 替换成 Hexo 这周开始，我把博客从 Hexo 迁移到 Hugo，主要是因为：\nHugo 对 i18n 支持更好。因为 Hexo 对 i18n 并不太支持，之前自己魔改了模板，最后实现了中文和英文切换，但是维护成本很高，了解后发现 Hugo 原生支持多语言。\n不过在切换后，发现也有以下一些优点：\n主题配置更简单。我使用的是Stack 主题，基本上没有遇到坑。官方自带的 example 配置就很好，照这配置就好。另外，还带 Google Analysis 分析，还带 RSS 源，源也会自动区分语言，非常舒适。\n在切换的过程中，基本上没有遇到什么障碍，只要有你过去的 Markdown 文件，直接复制到新工程的目录下，再强制推送到原来的 github pages仓库，就可以直接迁移过来。强制推送后，需要在 github重新配置一下自定义域名，就无损升级了，包括评论之类的都是一样的。\n唯一不同的是，Hugo 默认使用小写链接，而 Hexo 默认保留大小写，这可能使得过去的一些链接失效，搜索引擎需要重新建立索引。\n神秘模型Optimus Alpha出现在https://openrouter.ai/ 并霸榜 由于该模型免费，并且性能很强，在上线后，就被选择成为 OpenRouter 的首席流量处理模型。\n随着14 号 OpenAI 官方公布 GPT4.1 后，该模型从 OpenRouter 下架。显然，该模型就是 GPT4.1。\nGPT4.1 是一个编程能力特化的模型，拥有 1M 的上下文窗口。确实，现在编程领域，OpenAI 被 Claude 3.7 还有 Gemini2.5pro 打的鼻青脸肿，无论是 o1 还是 o3 模型，都没能在编程领域取得什么领先地位。希望 OpenAI 再接再厉吧。\nOpenRouter 是一个让用户统一接入多个大语言模型 API 的中间层服务平台。你可以把它理解成一个「代理」或「路由器」，统一管理不同大模型厂商（OpenAI、Anthropic、Mistral、Google Gemini、Cohere 等）的调用方式。\n看起来，这次，OpenAI 选择了 OpenRouter 作为测试发布平台，而不是https://lmarena.ai/\nOpenRouter.ai OpenRouter\n这是一个 LLM平台，包含大量的免费/收费高质量模型。\n选择 Prompt pricing 为 0 元，再选择 Top Weekly，就可以看到目前最好的免费模型。\n不过使用时需要开启 log 和使用数据进行训练。\n目前可以选择 Gemini 2.5 pro。\n其中Ranking功能可以实时查看平台上所有的流量分发情况，哪个模型好用一目了然。\nnanobrowser 一款用于 Chrome 的浏览器插件，可以控制浏览器的自动化操作。\n试验了一下，无法支持 Arc 浏览器。体验下来能力有限，例如，对网页的滚动偶尔失效，无法总结整个页面的内容，只能看到局部的内容，操作偶尔不正确。\n虽然该产品不太推荐，不过这可能是未来一个方向，看起来，以后会出现大量的 AI 代理。\n抢票、刷分之类的灰色产业估计会很开心。\nmarkitdown 一款用于将不同格式的内容转换成 Markdown 格式的工具。\n离线情况下，可以处理不同的文件转换成 Markdown 格式，试用了一下，转换得比较基础。\n也可以支持接入 LLM，提升转换结果和文档中图片的部分。\n在未来可能是一款不错的 MCP 服务。\nPDF search 一款应用，可以快速搜索多个 pdf 中出现的内容。\n使用类似模糊搜索的方式，原理是对 PDF 做了分割并且进行了嵌入向量计算，随后和搜索词进行匹配。\n适合考试期间搜索文档使用。\n缺点是，index 是按照页面划分的，搜索后需要自己在页面中找到对应的 part。\n","date":"2025-04-15T20:45:20+01:00","permalink":"https://nansenli.com/zh-cn/post/2025/04/tech2504/","title":"2025 年 4 月科技随笔"},{"content":"其实这篇算不上攻略吧，只是对晨鹤的一些内容做一些个人的补充分享。\n晨鹤链接：https://chenhe.me/post/ireland\n晨鹤写的内容挺好，很详实，基本上解答了我很多当时来爱尔兰的困惑\n文章未完成，本文不定期更新。\n背景 地点在都柏林，录取的学校是 DCU。\n出发前 直接点名型号吧，苏泊尔小绿锅压力锅。为什么必须要这个而不是其他的呢，因为：1. 压力蒸出来的米饭更好吃。 2. 炖煮类的，例如炖牛腩，卤鸡腿之类的，更方便。 我自己也带了小米的电饭煲，但是来了这边发现电饭煲煮的饭一点也不好吃，只有高压锅煮出来的饭好吃😋。另外，好像只有这款 10 分钟压力就能煮完米饭了，看了下其他款，并没有这么快的速度，我猜想可能和他的小容量有关。 药品：强烈推荐带一盒感康，感冒的时候吃一粒马上就好多了。创可贴可以带一些透明的防水的那种。 水杯：来了之后，发现想买到喜欢的水杯好难。如果人在国内，淘宝上买一个合适的水杯很重要。 小红书：以前以为是个美妆 APP，在国内几乎没有用过。出国才发现这是个出国 APP，以下内容小红书上有大量攻略，可以酌情浏览，当然有的人不太喜并对其嗤之以鼻，萝卜白菜各有所爱吧（晨鹤不要打我）。 驾照：我带了，但是来了就过期了，所以没怎么用到。如果有效期内的话，考驾照会减免考试所需要的时间。 现金：其实不用换太多欧元。在国内办好一张双币信用卡，例如 visa 或者 master card，来了这边是可以直接刷卡的。这边现金消费的场景比较少。 衣服：建议带多层的穿搭。由于这边天气多变，室内外温差大，可能会频繁增减衣物。冬天还是蛮冷的，羽绒服类似的厚度的可以带两件换着穿。 行李箱：海南航空可以申请留学生认证，可以携带最多两个 28 寸的行李箱。不过对我来说太多了，我最后带了一个 20 的一个 28 的。另外 28 寸行李箱其实塞满也很容易超重。想带 26 寸的也可以。 体验，牙科，手术等等：这边费用比较贵，在国内尽量都做了。例如补牙或者激光手术等等。 转换插头：一个高质量的转换插头会很方便。可以考虑准备一些简单的转换插头，再买一个带多口充电口的转换插头。另外可以考虑购买一个特殊排插，头是英标的，插座是国标的。 生活费：租房可能要 600-1200 欧，如果自己做饭，伙食每个月 500 欧，生活费可能是 1000-1800欧一个月，取决于个人消费水平。 机票：海航直飞都柏林的机票不错，特别是，如果你从上海转机而不是在北京飞，机票会更便宜。也就是说多做一段飞机反而更便宜。 临时住宿：可以在Airbnb 或者 Booking 上预定临时住宿。 中餐调料：来了之后，你会发现每天的生活很大一部分就是买菜做饭。不过，基本上所有调料在本地中国超市有售卖，因此不必带太多调料品。具体售卖的清单可以搜索融兴行小程序353购查看。 入境 展示下面的内容即可：\n护照 保险 录取通知书 到达爱尔兰后 抵达住宿地点：在机场拦出租车即可。 买电话卡：这个可以办理学生套餐的，20 欧，无限流量。我办理的是Vodafone 的。记得配置自动 20 天充值，不然每次都要手动充值很麻烦。 办理公交卡：可以先办理一张成人卡，之后，再到市中心换学生卡。学生卡半价。然后可以在官网将成人卡注销，可以退卡退费的。 办理居留卡 IRP：提前预约，若等到 9 月开学再预约，就要排队到 11 月了。有了 IRP，就可以离开爱尔兰了，例如回国，或者去英国或者欧洲玩了。 办理银行卡：可以通过 AIB 办理，无需到现场办理，手机即可办理。办理需要学生证，学生银行卡可以免年费。银行卡尽早办理，同时提供的地址证明也是办理其他手续的重要资料。 办理PPSN：虽然不是一定要用到，但是万一呢。尽量提前办理好。如果找到实习了就可以报税用了。驾照报考也会用到。 支付 平时日常基本上大部分场景都是刷卡支付，使用银行卡靠一下无线的标志就可以支付了。也可以在手机上配置 Apple pay 进行支付。\n租房 DCU学校旁边有两家公寓，非常推荐， 在 shanowen 路上，一家是 Shanowen Square，另外一家是 Shanowen Hall，最好提前几个月来预约，不然到时候没有空房。市区的话 Beckett House 也不错，适合 TCD 的学生。当然如果摇号摇到学校的公寓是最好的。总之，优先学校宿舍，学生公寓，其次可以找房东租房。寄宿家庭的话，和房东一起住的话，可能因人而异，对我来说，我已经体验过了，不算噩梦，也不算美梦，但有个经历之后就好，让我再来一次我打死不要。也有同学说，寄宿家庭环境不错的。\n居家和床上用品 可以在IKEA 上下单，到时候会送到房间。但是注意时效不一定准，可能会第二天才送。学生优惠记得使用，我记得当时我结完账才发现有优惠，联系工作人员，可以帮你取消再重新结算。Homebase 的东西也不错，里面的电暖气很赞，几十欧很大只又很轻，冬天太冷晚上停暖气的话，可以使用这个。\n药店 在国内很少逛药店，但这里的药店除了药以外，还卖很多其他东西，例如化妆品保健品护肤品洗浴用品。基本上 Boots 就可以搞定。市区的 Boots 有家比较大，二楼还可以拍证件照，非常万能。\n餐饮 基本上都是自己做饭。可以去市区融兴行中超购买。融兴行小程序可以全城配送，配送费满 30 欧备注“融逸生活”免配送费，当天早上订单下午即可送达，非常方便！！！\n其他超市说实话本人用的不太多。DCU 附近有 LIDL 还有 Tesco，里面也有一些生鲜，我主要用来补充一些肉类。\n肉类的话，这边的猪肉实在是味道太大了。基本没吃过。只吃牛肉。\nlidl 的Rib eye steak 味道还不错，肥瘦相间，8 欧多 400g，可以吃两顿。另外就是 lidl 的鸡腿肉了，带皮带骨的价格很划算。\n融兴行有卖牛腩，炖牛肉很好吃。\n这边炉灶不太好用，用的电陶炉居多。可能需要习惯一段时间火力。\n公交 爱尔兰公交系统发达，基本上不需要打车。TFI Live 可以实时查看任意站点的下一辆车的到达时间，比 Google 准，在没有电子指示的站点很有用，推荐下载使用。出行主要是公交车，偶尔会有Luas、Dart 等等。\n网购 推荐使用 Shein，满足一定金额即可包邮。一般快递需要 10 天左右送达。可以购买生活用品等。无食品。\n另外学生可以免费开亚马逊的学生会员半年。极大的减少快递费用。\n不走 Shein如果想要像淘宝一样，买东西，然后 走国际货运公司空运 10 天收到的话，运费极高，2kg 的话运费在 200-300 人民币。走海运，运费便宜一点，2kg 的话，在 60-80 人民币。所以如果买一些日用品的话，Shein 上能买到的话，尽量在 Shein 上买，还包邮费。\nOchama 商品会更全，并且包含各种中国食品，以及部分京造产品（京东旗下在欧洲的公司），结账使用邀请码（7WYM5K）可以获得 10 欧优惠卷。但是运费有点贵，如果没有优惠的情况下，基本上很少用到。\n服饰 南边有一个 Dundrum Town Centre，里面服装比较多。市区 Henry St 的服装也挺多的。\n国内游玩 如果是报了语言班的话（我报了 DCU 的 5 周语言班，还蛮不错的，不然开学冲击太大，相当于提前了解了一下学校），7 月-8 月都比较适合出行游玩。可以去高威科克转一转。但如果没有报语言班，只是 9 月之后的话，来了天气就不太好了，会冷，日照时间也减少了很多，所以 9 月开学的时候可以去玩玩，10 月之后就不太适合玩了。之后适合游玩的话，可能要到第二年 4 月之后了，到那个时候，日照恢复，温度也上升了。\n签证 英国签证尽量在国内就申请好，在爱尔兰申请的话，只给半年，在国内申请，会给 2 年。这样无论是去北爱尔兰，还是去英国，都会很方便。 这边课程很短。寒假和第二学期结束后，有大量时间。这些时间如果没有计划的话，会非常无聊。特别是冬天，日照很短。由于这边签证基本上需要找黄牛排队，所以，推荐来了就开始申请签证。稳一点的话，就抓一家大使馆开始刷签证。在签证期间内，往返一次目的地国家。当前在这个过程中也会花费大量的时间和金钱，但是没有办法，想要获得一张长期的申根签，就需要积累出入境记录。我申请的是法签。通常每次会按照以下时间发放：1 个月、3 个月、半年、一年、多年。单次多次出入境无所谓了，反正超过 3 个月的基本上不可能给单次。 求职 这个也很关键。来之前懵懵懂懂，直到来了之后才有一个清晰的认识。这个部分由于我还在求职，也没有完全走完流程，会在走完流程之后再更新。\nNG 岗位：也就是校招岗位，申请时间在来了之后的 9 月到 11 月份。11 月份之后，大部分校招岗位就关闭了。所以需要尽早申请。无论水平如何，都推荐申请一下 NG 岗位。不过，对于超过 2 年工作经验的人来说，大厂基本上 NG 岗位很难获得。但是相当于走了一下流程，若能够接收到面试，也算是丰富经验了。 社招岗位：申请时间在次年 4 月底开始。由于我刚开始申请，所以也不太能说个所以然。另外，找工作也随缘吧。因为很多公司要求是有 1G 的签证才会有面试机会。申请太早的话，公司是不会处理的。 实习岗位：这个就可遇不可求了，由于硕士只有一年，很多实习岗位并不是面相我们的，而是面相本科生的。只能说，尝试投递吧。 交流 如果有疑问，也可以通过以下渠道联系我。\n小红书：\nWhatsapp：\n","date":"2025-04-10T18:12:47Z","permalink":"https://nansenli.com/zh-cn/post/2025/04/ireland-study-guide/","title":"爱尔兰留学不完全攻略"},{"content":"ChatGPT GPT-4o：全能。满足日常交流学习，上下文足够大，轻松处理代码、文档检索等任务。支持多种附件格式和在线执行代码。缺点是生成的上下文长度过小，不适合生成太长内容。对过长的对话，上下文压缩严重，可能会忘记早前的内容。\nProjects：略鸡肋。适合用于多个文件频繁搜索和检索文本的场景。\nGPT-4o mini：弱于 GPT-4o，优点是上下文窗口巨大，推荐用于翻译超长文本的场合。\no1：还不错的思维链模型，用于解决复杂的代码、数学题。不擅长处理感情及需要使用直觉的问题。但思维链过短，且质量不高。建议在输出结果后，将结果作为Gemini-2.5pro 或者DeepSeek-R1 的输入，优化质量。\no3-mini：幻觉严重，不如 o1，但推理速度极快。\nSearch：略微鸡肋。新版本搜索结果被严重阉割，甚至不如模型不搜索时的输出质量。适合替代轻度搜索。\nDeep Research：神器。同类功能中质量最好，输出结果最完善。\nGPT-4.5-preview：优秀。上下文窗口巨大，对长文本理解能力强。拥有海量记忆和最强直觉。其实不擅长推理，但是由于幻觉低，反而表现最好。\nCanvas：整体不如 Cursor。上下文输出太小，文本长度受限。适合边写边编辑的短文本场景。\nWork with Apps on macOS：功能体验被 Cursor 碾压，相当于 Cursor 的精简版。\nClaude Claude 3.7 Sonnet：优秀，适合生成各类代码。网页版支持超大上下文，几乎与 API 提供一致的上下文历史消息保留。模型非常适合撰写沟通类文本，如邮件，用词准确、简洁、不浮夸。缺点是免费版使用次数有限。 DeepSeek R1：幻觉严重，发挥不稳定，偶尔影响使用，对提示词质量要求极高。提示词正确或上下文完整时超越 o1。可以作为 o1 输出结果的输入，优化质量。\nV3：非常优秀，GPT-4o 平替。\nGrok Grok-3：生成文本流畅自然，AI 感较弱，适合自然写作和小说创作。整体中规中矩，生产力方面不如 GPT-4o 提供的工具多。\nGrok-3 + search：优秀。坐拥英文社交数据，快速分析新闻实事。输出内容长，几乎不过滤索搜源内容，比 GPT-4o 搜索能力强。\nGrok-Deep Search：略鸡肋，反而不如 Grok-3 + search。生成内容模板化严重，影响质量。\nGemini 2.5 Pro：非常优秀的模型，GPT-4o 平替，幻觉少，搜索结果质量高，思维链完整清晰，逻辑性强。支持与 Google 工具联动，特殊场景下非常有用，例如上传截图或文本并自动在 Google Calendar 中创建日程。\nDeep Research：一般，略优于旧版 GPT Search。偶尔存在理解偏差，搜索和文档生成是分阶段执行，过程割裂，模板化严重。目前唯一能替代 GPT Deep Research 的产品。\nv0.dev 适合编写并在线预览前端组件。 chat.qwen.ai Qwen2.5-Max：非常优秀的模型，GPT-4o 平替，生成速度快，支持思考模式。 知乎直答 支持搜索知乎全网内容。可能的竞品是小红书直答。 Perplexity 支持基础搜索，质量平庸，略鸡肋。 Mistral.ai 速度快，上下文窗口大，GPT4o-mini 平替。 Cursor 神器。可对整个代码仓库建立索引，适合开发大型项目。支持多模型切换，支持本地命令行执行与终端接管，适合以下任务： 撰写 Latex 文档，替代 Overleaf 辅助完成各类作业 代码仓库搜索与特定功能定位 创建单元测试 执行 git 操作 执行部署任务 几乎可以执行一切涉及文档和命令行的功能，在开发、调试、Debug、文档撰写方面均有帮助 真正的现阶段最接近 Agent 的产品 例子：Leetcode 跟踪器 在淘宝上存在大量的 Leetcode 会员共享账号，但是我们有的时候还是需要将做题记录追加到自己的账号中。购买共享会员账号后，我们可以将某个公司的题目导出为 csv 文件，然后，将自己的做题记录也导出为 csv 文件，之后，对比这两个文件，我们可以轻松的去追踪当前的做题进度。Cursor 非常擅长撰写类似的小工具：\n我们只需要复制网页中的元素，Cursor 就可以为我们撰写完整的 csv 文件，并且自动生成完美的前端界面，极大的提高做题的效率。\n","date":"2025-04-08T19:47:56Z","permalink":"https://nansenli.com/zh-cn/post/2025/04/aitest/","title":"LLM 工具使用体验总结"},{"content":"在 macOS 上安装 Rodin 的步骤（M1 ARM 架构）： 安装 x86 JDK\n从 Oracle 下载 Intel x86 JDK 18（macOS .dmg）：\njdk-18.0.2.1_macos-x64_bin.dmg\n运行安装程序，它会自动配置 Java 环境。\n下载并安装 Rodin\n从 SourceForge 获取 Rodin 3.8/3.9（x86_64 版本）：\nrodin-3.8.0.202304051545-macosx.cocoa.x86_64.tar.gz\n解压 .tar.gz 文件，并将 Rodin.app 移动到 /Applications 文件夹。\n修复 macOS 安全权限\n运行以下命令以绕过\u0026quot;应用程序已损坏\u0026quot;的错误： sudo xattr -cr /Applications/Rodin.app Rodin 应该可以正常运行，无需其他步骤（例如配置 Java VM 路径）。\n","date":"2025-02-01T13:02:01Z","permalink":"https://nansenli.com/zh-cn/post/2025/02/rodin/","title":"如何在搭载 Apple 芯片的 MacBook 上安装 Rodin 软件"},{"content":"这篇文章主要介绍了如何对传统分组密码算法 FEAL-4 进行差分分析（Differential Cryptanalysis），并展示了攻击进程和关键实现细节。文中还包含了部分实验数据和攻击结果，可供有兴趣的读者参考或复现。\n两张重要图片 在正式展开分析之前，先给出两张与 FEAL-4 密切相关的图片，方便对差分传播和整体加密流程有一个直观认识。\n差分传播示意图\n下图展示了在 FEAL-4 中，明文差分（XOR 形式）如何在加密轮次中传播并最终反映到密文上。\nFEAL-4 工作流示意图\n下图是 FEAL-4 的整体加密框架示意，包括明文的左右分块、各轮子密钥注入以及 F 函数的运用流程。\nF 函数的特性 FEAL-4 的轮函数（即 F 函数）可以视作对 32 位输入进行某种随机化排列（Permutation）。在差分分析中，我们并不需要 F 的具体实现，而更关注它的两个关键差分属性：\n若 $X \\oplus Y = 0$，则 $F(X) = F(Y)$。 若 $X \\oplus Y = 0x80800000$，则 $F(X) \\oplus F(Y) = 0x02000000$。 有了这两个结论，在后续分析时就能推断特定差分输入下的输出表现，从而帮助定位子密钥。\n差分路径的详细分析 假设我们选择一对特殊的明文 $P_0$ 和 $P_1$，满足： $$ P_0 \\oplus P_1 = 0x8080000080800000 = P^{\\prime}. $$ 这个特定差分向量有助于简化 FEAL-4 若干轮次输出中的差分计算。\n1. 初始轮次差分推导 令 $(L0_0, R0_0)$ 表示 $P_0$ 的左右分块（同理 $(L0_1, R0_1)$ 表示 $P_1$ 的左右分块）。\n经过第一轮的异或操作后： $$ L1_0 \\oplus L1_1 = (L0_0 \\oplus K4) \\oplus (L0_1 \\oplus K4) = L0_0 \\oplus L1_0 = 0x80800000. $$ 同理可推出右半部分的差分。\n进一步由于加密时存在 “额外一轮 XOR”，可得到： $$ R2_0 \\oplus R2_1 = (R1_0 \\oplus L1_0) \\oplus (R1_1 \\oplus L1_1) = 0x80800000 \\oplus 0x80800000 = 0. $$ 这意味着在后续计算中，差分会以更简单的形式得以归并。\n2. 后向差分计算（Backward Calculation） 当我们获得明文对 $(P_0, P_1)$ 与对应的密文对 $(C_0, C_1)$ 后，可以进一步进行后向推导。令密文记作 $(L, R)$，则：\n计算出 $C^{\\prime} = C_0 \\oplus C_1$，得到 $(L^{\\prime}, R^{\\prime})$。 根据已知差分性质，可在末轮逐步还原 $X^{\\prime}$、$Y^{\\prime}$、$Z^{\\prime}$ 等中间变量。 利用这些结果便可对各子密钥展开攻击或验证。 攻击 K3 在差分分析中，往往先从某个中间轮次子密钥开始，例如 $K_3$。具体步骤如下：\n选取明文对： 我生成了 12 对满足\n$$ P_0 \\oplus P_1 = 0x8080000080800000 $$\n的随机明文。 加密并提取差分： 将上述明文对加密后，得到相应的密文对；结合差分路径推导出 $Y_0$、$Y_1$、$Z^{\\prime}$ 等中间值。 遍历 $K_3$：\n$$ Z^{\\prime} = Z_0 \\oplus Z_1 = F(Y_0 \\oplus K_3) \\oplus F(Y_1 \\oplus K_3). $$\n只要找到满足差分方程 $= 0x02000000$ 的候选即保留。 通过这种方法，我成功得到四个候选子密钥：\ncfa38976, cfa309f6, 4f238976, 4f2309f6 执行以上过程的命令示例为：\n./main -mode=attackk3 -file=K3.txt 该实现与我在 www.theamazingking.com 上介绍的方法一致。\n攻击 K2 在拿到 $K_3$ 的若干候选后，可以继续推算 $K_2$。其核心方程： $$ X\u0026rsquo; = X_0 \\oplus X_1 = F(U_0 \\oplus K_2) \\oplus F(U_1 \\oplus K_2), $$ 其中 $U$ 来自于上一轮运算（包括对 $Y$、$Z$ 等的进一步计算）。同样地：\n生成明文对，满足差分条件 $$ P_0 \\oplus P_1 = 0x0000000080800000. $$ 抓取加密后密文差分，通过遍历所有可能 $K_2$ 值，检查是否能满足差分约束 $=0x02000000$。 命令示例： ./main -mode=attackk2 -file=K2.txt -k3=cfa38976,cfa309f6,4f238976,4f2309f6 最终输出示例如下所示： Candidate K2: 8b722e41 (K3: cfa38976) Candidate K2: 8b72aec1 (K3: cfa38976) ... Candidate K2: 89722e43 (K3: 4f2309f6) Candidate K2: 8972aec3 (K3: 4f2309f6) 攻击 K1 类似地，攻击 $K_1$ 也可以按前面流程来做。\n为了让差分路径能稳定呈现预期结果，我生成了 12 对满足\n$$ P_0 \\oplus P_1 = 0x0000000002000000 $$\n的明文，并验证其加密输出。\n命令示例：\n./main -mode=attackk1 -file=K1.txt -k3k2=\u0026#34;cfa38976,8b722e41; cfa38976,8b72aec1; ...\u0026#34; 可一次性将前面得到的所有 $K_3, K_2$ 候选组合带入，最终找到对应的 $K_1$ 候选。\n攻击 K0, K4, K5 当 $K_3, K_2, K_1$ 全部到手后，就可以反推最后一轮所需的 $K_0, K_4, K_5$。\n设最终加密得到的左、右部分为 $L_0, R_0$。对应的明文分块为 $PL, PR$。则有：\n$PL \\oplus K_4 = LR_0$ $PR \\oplus K_5 = RR_0$ $RR_0 \\oplus LR_0 = R_0$ $f(R_0 \\oplus K_0) \\oplus L_0 = LR_0$ 只要枚举所有可能的 $K_0$，即可通过上述方程解出相应的 $K_4$ 与 $K_5$。然后用其他明文-密文对交叉验证正确性。若都满足，则得到正确的最终密钥集。\n命令示例：\n./main -mode=attackk0k4k5 -k3k2k1=\u0026#34;...\u0026#34; -file=K1.txt -file2=K1_p.txt 实现、优化与验证 1. 自动化生成与并行计算 自动生成随机明文对：在代码中事先控制 XOR 差分，即可批量输出满足需求的明文文件（如 K3_p.txt, K2_p.txt, K1_p.txt）。 并行化搜索：使用 Go 语言的 Goroutines，开启 10 个并行任务，在带有 10 核的 Mac 上最大化利用 CPU 资源。 进度条与可视化：通过 progressbar 库实时显示搜索进度，让实验过程更直观。 2. 验证方法 本地自定义密钥测试\n先选定一套已知的 $K_0$–$K_5$（如 0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 0x00000020），对前面生成的明文对进行加密，并重复差分分析过程，看是否能在结果中匹配这套密钥。\n实验证明能够正确还原这组测试密钥，从而确认代码逻辑的准确性。\n特定明文-密文对测试\n选定一个明文 1234567890abcdef 和在 Einstein Zone 生成的密文 f43ae3eeb56e2bbf，验证最终得到的 256 组候选 $K_0$–$K_5$ 中，每一组都可重现这条加密映射，进一步确认攻击流程无误。\n最终结果 所有解出的 $K_0$–$K_5$ 存放于 final_result.txt。去重后包括以下范围：\nPossible Values for K0 890c2148 890ca1c8 098c2148 098ca1c8 ... 0b8c214a 0b8ca1ca 8b0c214a 8b0ca1ca Possible Values for K1 471f077e 471f87fe c79f077e c79f87fc ... 451f077c 451f87fc c59f077c c59f87fc Possible Values for K2 8b722e41 8b72aec1 8b722e43 8b72aec3 ... 89722e43 8972aec3 Possible Values for K3 cfa38976 cfa309f6 4f238976 4f2309f6 Possible Values for K4 89eb0024 89eb0026 8beb0024 8beb0026 Possible Values for K5 b85e6bc0 b85e6bc2 ba5e6bc0 ba5e6bc2 借助差分分析，我们最终能获得一批子密钥候选集。与现代分组密码（AES 等）相比，FEAL-4 的轮数较少、结构也更为简洁，因此在教学和研究中非常适合用于演示差分分析思路。\n总结 本文详细展示了对 FEAL-4 进行差分攻击的完整流程，包括从差分路径设计、生成明文对、中间子密钥 ($K_3, K_2, K_1$) 攻击，再到最后对 $K_0, K_4, K_5$ 的逆向求解。同时也介绍了代码实现过程中的几处优化和验证方法。\nFEAL-4 算法因为较低的轮数和简单的结构为差分分析提供了便利。然而对于现代更安全、更复杂的分组算法，同样的分析思路也至关重要。本案例希望对密码学的学习者和研究者有所启发，如有任何问题或改进方案，欢迎在评论区讨论交流！\n","date":"2025-01-01T13:15:04Z","permalink":"https://nansenli.com/zh-cn/post/2025/01/feal-4/","title":"差分攻击 FEAL-4：从原理到实现"},{"content":"对于 DCU 安全编程这门课的反汇编，由于题目有一定套路，使用固定的解题思路，可以快速解题\n前置技能 熟悉各种汇编命令 汇编指令 熟悉 % 和 $ 表示寄存器和立即数 $ 与 % 寄存器与立即数 熟悉直接寻址和间接寻址 直接寻址与间接寻址 了解一个case C语言代码到汇编的例子 解题思路 找到入参个数 找到局部变量个数 识别循环体 解析剩余代码片段 识别返回数据 找到入参个数 ebp的位置是saved frame ptr，ebp+4的位置是return address。由于题目往往是约定入参全部为int 或者 int * 类型，因此 ebp+8，ebp+c，ebp+10的位置，分别是入参的第一个参数，第二个参数，第三个参数。\n因此，在代码中快速浏览，寻找 0x__(%ebp) 的字样，找到最大的偏移量。(偏移量-4)//4 的值就是入参的个数。\n例如，下面这段代码\npush %ebp \u0026lt;foo+0\u0026gt; mov %esp, %ebp \u0026lt;foo+1\u0026gt; sub $0x4, %esp \u0026lt;foo+3\u0026gt; mov 0x8(%ebp), %eax \u0026lt;foo+6\u0026gt; mov %eax, -0x4(%ebp) \u0026lt;foo+9\u0026gt; mov -0x4(%ebp), %eax \u0026lt;foo+12\u0026gt; cmp 0x10(%ebp), %eax \u0026lt;foo+15\u0026gt; jge \u0026lt;foo+32\u0026gt; \u0026lt;foo+18\u0026gt; mov 0xc(%ebp), %eax \u0026lt;foo+20\u0026gt; incl (%eax) \u0026lt;foo+23\u0026gt; lea -0x4(%ebp), %eax \u0026lt;foo+25\u0026gt; incl (%eax) \u0026lt;foo+28\u0026gt; jmp \u0026lt;foo+12\u0026gt; \u0026lt;foo+30\u0026gt; mov $0x0, %eax \u0026lt;foo+32\u0026gt; leave \u0026lt;foo+37\u0026gt; ret \u0026lt;foo+38\u0026gt; 我们发现存在 0x10(%ebp) 因此，参数个数为（16-4）/4 ，也就是是3个。\n因此我们可以写出代码的框架，如下\nint foo(int a, int b, int c) { } 其中 a, b, c 存在的栈的位置分别是 ebp+8，ebp+c，ebp+10\n注意，参数从后向前入栈，因此越接近ebp，参数在参数列表中越靠前。\n注意，我们这里先假设全部都是int类型，如果后续有遇到不一致的情况，我们再来修改\n找到局部变量个数 局部变量的个数在代码第三行，sub $0x4, %esp 这里减去的数量，就是分配的局部变量的长度。\n在上面的代码中，显然这里分配了4字节，也就是只有一个局部变量。我们假设这个局部变量就是int类型，起名为i。\n我们继续扩展我们的代码\nint foo(int a, int b, int c) { int i; } 识别循环体 循环体通常是while循环或者for循环。\n对于常见的while命令，我们寻找下面相关的指令：\n判断入口： 判断入口是一个连续的比较命令（如cmp）和一个跳转命令（如jge或jle）组成。找到判断入口有助于我们识别代码中是否有判断或者循环。\n循环： 假如没有循环标志，那么就不是循环体，而是简单的if判断。循环是一个无条件的jmp命令。循环所跳转的位置就是判断条件的开始。\n判断条件： 判断条件是判断入口以及判断入口和前面几条命令组合成的完整判断条件。判断条件就是while括号里的内容。\n现在我们查看下面的例子：\npush %ebp \u0026lt;foo+0\u0026gt; mov %esp, %ebp \u0026lt;foo+1\u0026gt; sub $0x4, %esp \u0026lt;foo+3\u0026gt; mov 0x8(%ebp), %eax \u0026lt;foo+6\u0026gt; mov %eax, -0x4(%ebp) \u0026lt;foo+9\u0026gt; mov -0x4(%ebp), %eax \u0026lt;foo+12\u0026gt; cmp 0x10(%ebp), %eax \u0026lt;foo+15\u0026gt; jge \u0026lt;foo+32\u0026gt; \u0026lt;foo+18\u0026gt; mov 0xc(%ebp), %eax \u0026lt;foo+20\u0026gt; imul (%eax) \u0026lt;foo+23\u0026gt; lea -0x4(%ebp), %eax \u0026lt;foo+25\u0026gt; imul (%eax) \u0026lt;foo+28\u0026gt; jmp \u0026lt;foo+12\u0026gt; \u0026lt;foo+30\u0026gt; mov $0x0, %eax \u0026lt;foo+32\u0026gt; leave \u0026lt;foo+37\u0026gt; ret \u0026lt;foo+38\u0026gt; 判断入口：\n我们寻找一个连续的判断指令和一个跳转指令，我们可以找到 cmp 和 jge 这两个连续指令，就说明这里是判断入口。\n循环：\n我们看到，最后存在一个jmp命令，jmp命令指向了第foo+12的位置，因此foo+12就是循环的判断条件。\n判断条件：\n判断条件的第一句是 mov -0x4(%ebp), %eax ，其中 -0x4(%ebp) 是最后一个局部变量，由于我们只有一个局部变量 i ，因此这句话的意思是，将本地变量i的值赋值给 eax。\n我们看到cmp的命令是：cmp 0x10(%ebp), %eax ，其中cmp 0x10(%ebp) 指第三个入参的值。这句话的意思是计算 eax 寄存器中减去第一个入参的数值，也就是c。\n联合起来，我们就知道，这里是计算 i - c的值，并交给 jge 来做跳转。\n由于汇编的条件判断和C语言条件判断是反过来的，汇编是满足判断则跳过循环体，而C语言是满足条件则执行循环体，因此我们的判断条件也是反过来的。\njge表示大于等于0则跳过循环体，因此C语言的循环条件是小于0则执行循环体，也就是判断 i - c 是否小于 0\n因此我们可以继续完善我们的代码:\nint foo(int a, int b, int c) { int i; while (i - c \u0026lt; 0) { } } 解析剩余代码片段 首先标记下已经处理过的代码\npush %ebp \u0026lt;foo+0\u0026gt; 无用 mov %esp, %ebp \u0026lt;foo+1\u0026gt; 无用 sub $0x4, %esp \u0026lt;foo+3\u0026gt; 分配了几个局部变量 mov 0x8(%ebp), %eax \u0026lt;foo+6\u0026gt; mov %eax, -0x4(%ebp) \u0026lt;foo+9\u0026gt; mov -0x4(%ebp), %eax \u0026lt;foo+12\u0026gt; 判断条件开始 cmp 0x10(%ebp), %eax \u0026lt;foo+15\u0026gt; 判断内容 jge \u0026lt;foo+32\u0026gt; \u0026lt;foo+18\u0026gt; 判断条件结束 mov 0xc(%ebp), %eax \u0026lt;foo+20\u0026gt; incl (%eax) \u0026lt;foo+23\u0026gt; lea -0x4(%ebp), %eax \u0026lt;foo+25\u0026gt; incl (%eax) \u0026lt;foo+28\u0026gt; jmp \u0026lt;foo+12\u0026gt; \u0026lt;foo+30\u0026gt; 循环结束 mov $0x0, %eax \u0026lt;foo+32\u0026gt; leave \u0026lt;foo+37\u0026gt; ret \u0026lt;foo+38\u0026gt; 循环体之前的代码 我们看一下循环开始之前的部分：\nmov 0x8(%ebp), %eax \u0026lt;foo+6\u0026gt; mov %eax, -0x4(%ebp) \u0026lt;foo+9\u0026gt; 我们发现这两句都涉及到了 eax 寄存器\n对于多条涉及eax 寄存器的操作，我们尽量当作一个整体来看\n我们发现，其实这里就是将 0x8(%ebp) 的数值 赋值给了 -0x4(%ebp) ，这两个值分别是 a 和 i\n因此这个部分的代码是\ni = a 循环体中间的代码 mov 0xc(%ebp), %eax \u0026lt;foo+20\u0026gt; incl (%eax) \u0026lt;foo+23\u0026gt; lea -0x4(%ebp), %eax \u0026lt;foo+25\u0026gt; incl (%eax) \u0026lt;foo+28\u0026gt; 对于涉及eax的多条指令，我们不要一条一条看，而是看作一个整体。\n其中，mov 0xc(%ebp), %eax 和 incl (%eax) 可以看作 incl (%b) 注意，由于这里是间接寻址，因此，这意味着，b中存的是地址。因此我们需要修改我们的入参，b这里不是数值，而是地址。这句代码意味着\n(*b)++ 注意\n*b++ 会先对 *b 解引用，再对 b 自增\n因此这里括号不能省略，否则会有问题\n而对于 lea -0x4(%ebp), %eax 和 incl (%eax) ，可以看作 incl (\u0026amp;i) ，这里继续是间接寻址，也就是对后者地址上的数值自增。这句代码意味着 *(\u0026amp;i)++ ，可以简化为\ni++ 之所以这么复杂，是因为汇编指令不能直接对地址进行自增操作，但是可以对一个包含地址的寄存器做自增操作。\n因此，补充了剩余的代码片段，代码应该为\nint foo(int a, int *b, int c) { int i; i = a; while (i - c \u0026lt; 0) { (*b)++; i++; } } 识别返回数据 按照C语言的x86的调用约定，返回数据放在eax中。\nmov $0x0, %eax 很显然，这里直接返回了0\n最终代码 int foo(int a, int *b, int c) { int i; i = a; while (i - c \u0026lt; 0) { (*b)++; i++; } return 0; } ","date":"2024-11-03T14:21:43Z","permalink":"https://nansenli.com/zh-cn/post/2024/11/disassembly/","title":"如何快速解决反汇编问题"},{"content":"在之前的文章中，我使用了 Obsidian 的 QuickAdd 来创建一个脚本，自动转换从 ChatGPT 中复制的文本，修复其中的 LaTeX 格式。然而，对于 Craft 这款应用，并没有合适的插件可以使用。\n我们可以通过 Raycast 来实现这个功能的统一操作。\n创建 Raycast 脚本 首先，我们需要创建一个脚本。\n接着选择 Bash 模板。\n然后，我们编辑这个 Bash 脚本，输入如下代码：\n#!/bin/bash # Required parameters: # @raycast.schemaVersion 1 # @raycast.title Copy From ChatGPT # @raycast.mode silent # Optional parameters: # @raycast.icon 🤖 # @raycast.packageName ChatGPT Utils # Documentation: # @raycast.description Copy From ChatGPT # @raycast.author Nansen Li # @raycast.authorURL nansenli.com # 获取剪贴板内容 clipboard_content=$(pbpaste) # 检查是否成功获取内容 if [ -z \u0026#34;$clipboard_content\u0026#34; ]; then echo \u0026#34;剪贴板为空或无法访问。\u0026#34; exit 1 fi # 处理剪贴板内容 modified_content=$(echo \u0026#34;$clipboard_content\u0026#34; | \\ sed \u0026#39;s/\\\\\\[/$$/g; s/\\\\\\]/$$/g; s/\\\\( /$/g; s/ \\\\\\)/$/g\u0026#39;) # 将修改后的内容写回剪贴板 echo \u0026#34;$modified_content\u0026#34; | pbcopy 创建完脚本后，我们还需要将脚本所在的目录添加到 Raycast 中。\n在这一步中，选择刚刚创建的脚本目录。此时，我们可以在 Script Commands 中看到刚刚创建的脚本。\n如何使用 在复制完 ChatGPT 的公式后，打开 Raycast 的面板，找到刚刚的脚本并运行，此时剪贴板中的内容就会被自动修复。接下来，只需将其粘贴到 Obsidian 或 Craft 中即可。\n","date":"2024-10-26T12:59:17Z","permalink":"https://nansenli.com/zh-cn/post/2024/10/raycast-craft/","title":"如何处理ChatGPT的Latex格式和Obsidian与Craft不一致的问题"},{"content":"背景介绍 我是Nansen，参与了2024年华为爱尔兰研究中心的服务器集群管理优化比赛。在此，我想分享一下这次比赛的经历，并对其中的关键点进行总结。\n我们的算法代码部分可以参考这里: huawei2024\n比赛结果 我们在算法部分获得了第一名，分数比第二至第四名高出约4%-5%，取得了巨大的优势。然而，在演讲环节我们遇到了很大的挑战。首先，我们意识到英语表达方面有提升空间；其次，我们发现演示PPT还可以更精美突出；最后，在时间安排上也存在一些挑战。不过，尽管如此，我们还是在总分上取得了第三名的成绩。\n比赛过程 比赛分为两个阶段。第一阶段有较长的准备时间。当我们确定使用模拟退火算法后，就开始了算法的开发。第一阶段的难点主要在于优化和理解题目需求。在开发过程中，我们遇到了许多bug，但在修复后，分数有了明显提升。\n第二阶段，由于题目在比赛当天才发布，我继续优化第一阶段的算法，成功将评估算法的运行速度提升了1000倍。这显著提高了我们在第二阶段的表现，让我们有足够的实力争夺第一名。\n在决赛阶段，我们的算法表现非常稳定，并在调整后大幅领先对手。然而，由于我们没有足够重视PPT的制作，我们以为只要算法表现好，排名靠前，就能获得高分，但事实证明我们错了。\n经验和教训 算法选择 很幸运，在最初的阶段我就选对了最终的算法，并且在题目发布后不久就构思出了适用于整个比赛的算法框架。然而，我也走了一些弯路，比如尝试了一些不可行的算法（如PPO算法）。在初步尝试无果后，我应该及时停止，而不是继续浪费精力。由于时间有限，我们应追求最短时间内的最优效果，而不是追求一个不切实际、理想中的方案。同时，也要认清自己的能力边界，专注于在短时间内能够实现的目标。\n团队分工 很幸运，这次团队的分工是合理的，我尽力确保每个成员都能发挥自己的价值。改进之处在于，应该更多地与队员沟通，了解他们的意愿和想法。由于我主要负责算法部分，与队友的沟通相对较少，下一次我会在这方面做得更好。\nPPT的制作 我们没有预料到，其他参赛队伍的PPT水平如此之高。我的队友猜测，他们可能有商科背景，这使得他们在制作PPT时具有优势。此外，他们的团队有五名成员，而我们只有三名，这也让我们在人员配备上处于劣势。这些都是客观上的挑战，但如果我们更加重视PPT的制作，或许第一名就是我们的。\n过分投入导致失衡 在决赛阶段，其实我们的算法已经非常出色，分数也超过了此前排名第一的队伍。然而，我仍然花了大量时间继续优化算法，尽管我们的算法分数领先对手很多，但却因此忽略了PPT的准备。事实上，我应该适可而止，并充分理解评分标准的重要性。\n结论 通过参加华为Tech Arena 2024竞赛，我获得了宝贵的经验。这次比赛不仅展示了我们的优势，也暴露了我们在展示技能和团队协作方面需要改进的地方。展望未来，我会牢记这些经验教训，并在今后的比赛中不断改进自己。如果您有问题，可以在留言区反馈给我。\n","date":"2024-10-24T09:58:53Z","permalink":"https://nansenli.com/zh-cn/post/2024/10/huawei2024/","title":"华为爱尔兰研究中心Tech Arena 2024竞赛总结"},{"content":"今天开始了漫长的刷题流程。之前只是简单做了一些题目，保持手感，但今天开始，就要为面试正式准备了。\n之前一直在思考一个问题：如何高效地刷 Leetcode。我认为，要高效地刷题，首先就得背题。书读百遍，其义自见，大语言模型经过大量训练，也锻炼出了写代码的能力。同样地，我相信 Leetcode 也一样，通过多次练习，答案自然会浮现，量变产生质变。\n53. Maximum Subarray 解题思路可以使用 Kadane\u0026rsquo;s Algorithm，代码如下：\ndef maxSubArray(nums): max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) max_global = max(max_global, max_current) return max_global 这是一个典型的动态规划题目，上面的算法其实隐藏了动态规划的本质。\nclass Solution { public: int maxSubArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; dp(nums.size()); dp[0] = nums[0]; for (int i = 1; i \u0026lt; nums.size(); i++) { dp[i] = max(dp[i - 1] + nums[i], nums[i]); } return *max_element(dp.begin(), dp.end()); } }; 这段代码更好地体现了动态规划的思想。\n理解 dp[i] = max(nums[i] + dp[i-1], nums[i]) 的公式可以从动态规划的角度来解析。这个公式的核心在于“在每一个位置上，我们要做出一个最优选择”。以下是详细解释：\n1. dp[i] 的含义是什么？ dp[i] 表示以位置 i 结尾的 最大子数组和。 2. 为什么比较 nums[i] + dp[i-1] 和 nums[i]？ 核心问题是：当前的最大子数组和是否应该包括之前的部分（dp[i-1]）？ nums[i] + dp[i-1]：如果 dp[i-1] 是正数，加上当前的 nums[i] 会让子数组和变大，那么我们选择累加。 nums[i]：如果 dp[i-1] 是负数，我们选择从当前位置重新开始一个新的子数组，因为负数只会拖累当前和。 3. 为什么不用比较后续的数？ 我们在比较时，是假设数组在位置 i 停止。也就是说，我们考虑 [0:i] 这个范围内的最大值，对于位置 i 来说，要么加上之前的子数组，要么放弃之前的子数组，只采用当前的数。 然后，我们遍历整个数组，找出在每个位置停下来的最大值，最终返回最大的那个值。 57. Insert Interval 这是一个经典的区间合并问题，需要将新插入的区间合并到已有的区间中。\n可以使用分解法来解决：\n第一步，将不重叠且在 newInterval 之前的区间添加到结果中。 第二步，合并所有可能重叠的区间到 newInterval 中，注意这里的判断条件。 第三步，将剩余的区间添加到结果中。 注意，合并区间的判断条件是前一个区间的开始小于等于后一个区间的结束，即 intervals[i][0] \u0026lt;= newInterval[1]。\nclass Solution: def insert(self, intervals: List[List[int]], newInterval: List[int]) -\u0026gt; List[List[int]]: ret_list = [] i = 0 while i \u0026lt; len(intervals) and intervals[i][1] \u0026lt; newInterval[0]: ret_list.append(intervals[i]) i += 1 while i \u0026lt; len(intervals) and intervals[i][0] \u0026lt;= newInterval[1]: newInterval[0] = min(intervals[i][0], newInterval[0]) newInterval[1] = max(intervals[i][1], newInterval[1]) i += 1 ret_list.append(newInterval) while i \u0026lt; len(intervals): ret_list.append(intervals[i]) i += 1 return ret_list 只要注意细节，这个题目其实并不难。\n300. Longest Increasing Subsequence 显然是一个动态规划问题。\ndp[i] 表示以某个数字结尾的最长递增子序列的长度。\n每次加入一个元素，我们更新当前的 dp 数组，如果当前数字比之前的小，它们的结果就加 1。\n注意，第一个 dp[i] 是从下标 1 开始的。\nclass Solution: def lengthOfLIS(self, nums: List[int]) -\u0026gt; int: dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[j] \u0026lt; nums[i]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) 复杂度分析：\n时间复杂度：$O(n^2)$，因为有两个嵌套的循环。 空间复杂度：$O(n)$，因为需要一个长度为 n 的 dp 数组。 674. Longest Continuous Increasing Subsequence 这是一个简单题目，但仍然值得理解。\nclass Solution: def findLengthOfLCIS(self, nums: List[int]) -\u0026gt; int: dp = [1] * len(nums) for i in range(1, len(nums)): if nums[i] \u0026gt; nums[i-1]: dp[i] = max(dp[i], dp[i-1] + 1) return max(dp) 392. Is Subsequence class Solution: def isSubsequence(self, s: str, t: str) -\u0026gt; bool: i = 0 j = 0 while i \u0026lt; len(s) and j \u0026lt; len(t): if s[i] == t[j]: i += 1 j += 1 return i == len(s) 这个题目可以用双指针法，以 t 为基准，如果 s 中有相同字符就向前推进，如果 s 到结尾了，说明匹配完成。\n115. Distinct Subsequences 这个问题要求我们找到字符串 s 中有多少不同的子序列等于字符串 t。\n首先，我们需要定义 dp，其中 dp[i][j] 表示从 s 的前 i 个字符中形成 t 的前 j 个字符的不同子序列数。\ndp[i][0] 表示当 t 为空串时，结果为 1。 dp[0][j] 表示从空串中形成 t，结果为 0。 对于 dp[i][j]，其结果取决于位置 i 和 j 的字符：\n如果两者相等，结果等于不匹配 s[i-1] 的情况（dp[i-1][j]）加上匹配的情况（dp[i-1][j-1]）。 如果不相等，则结果等于 dp[i-1][j]。 注意，这里 i, j 指的是前 i 个和前 j 个字符。\n此外，dp[0][0] 初始化为 1，因为空字符串是任何字符串的子序列。\nclass Solution: def numDistinct(self, s: str, t: str) -\u0026gt; int: dp = [[0 for _ in range(len(t) + 1)] for _ in range(len(s) + 1)] for i in range(len(s) + 1): dp[i][0] = 1 for j in range(1, len(t) + 1): for i in range(1, len(s) + 1): if s[i-1] == t[j-1]: dp[i][j] = dp[i-1][j] + dp[i-1][j-1] else: dp[i][j] = dp[i-1][j] return dp[-1][-1] ","date":"2024-10-21T19:39:36Z","permalink":"https://nansenli.com/zh-cn/post/2024/10/leetcode241020/","title":"Leetcode 背题"},{"content":"Off-by-One 溢出攻击分析 背景 上周，我参加了一门安全课程，其中包含了一个 off-by-one 溢出漏洞的示例。以下是原始代码：\n/* 简单的 off-by-one 溢出示例 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; void foo(char *input) { char buf[1024]; strncpy(buf, input, sizeof(buf)); buf[sizeof(buf)] = \u0026#39;\\0\u0026#39;; } void bar(void) { printf(\u0026#34;I\u0026#39;ve been hacked\\n\u0026#34;); } int main(int argc, char **argv) { if (argc != 2) { printf(\u0026#34;Usage: %s input_string\\n\u0026#34;, argv[0]); exit(EXIT_FAILURE); } foo(argv[1]); return 0; } 利用此漏洞的攻击命令是：\nperl -e \u0026#39;system \u0026#34;./obo\u0026#34;, \u0026#34;\\x38\\x84\\x04\\x08\u0026#34;x256\u0026#39; 运行此命令的结果是屏幕上打印出多行 I've been hacked。\n分析 当程序进入 foo 函数时，内存布局如下（使用 GDB 观察到）：\n从上到下，布局包含返回地址、保存的帧指针（saved frame pointer）和缓冲区 (buf)。\n当执行 buf[sizeof(buf)] = '\\0'; 时，保存的帧指针 (ebp) 的最低有效字节被设置为 0。为了确保 ebp 在被部分覆盖后仍然指向 buf 区域内，需要至少 1024 字节的缓冲区。具体来说，需要覆盖 ebp，使其保持在合理范围内（最高到 0xff），这就是为什么缓冲区设置为 0xff * 4 字节的原因。\n理解 foo 返回时的汇编命令 当 foo 函数返回时，通常会执行以下关键的汇编指令：\n1. leave 指令 leave 指令等价于：\nmov esp, ebp pop ebp mov esp, ebp：将栈指针 (esp) 设置为帧指针 (ebp) 的值，恢复栈指针到当前栈帧的顶部，从而释放当前函数占用的空间。 pop ebp：将栈顶的值弹出并赋给帧指针 (ebp)，从而恢复调用者的帧指针。实际上，相当于将返回地址写入 ebp，这意味着将栈中的值（通常是调用者的帧地址）赋给 ebp，从而恢复调用者的栈帧。 leave 的作用是将 esp 恢复到函数调用前的位置，并弹出保存的 ebp。如果 ebp 被覆盖为指向某个特殊地址（例如缓冲区内的地址），在函数返回时可能导致错误的栈指针位置。\n2. ret 指令 ret 指令从栈顶弹出一个地址并跳转到该地址：\npop eip 如果返回地址被覆盖为 bar 函数的地址，执行流将跳转到 bar，允许攻击者执行任意代码。本质上，ret 会将一个地址弹出到指令指针 (eip) 并跳转到该地址继续执行。\n攻击步骤 当执行命令 perl -e 'system \u0026quot;./obo\u0026quot;, \u0026quot;\\x38\\x84\\x04\\x08\u0026quot;x256' 时，程序会将这些重复的字节作为输入传递给 ./obo。 在 foo 函数返回时，执行了 leave 和 ret 指令，由于返回地址被覆盖，程序跳转到 bar 函数，打印出成功的消息多次。 进一步分析：确定有效的覆盖位置 为了成功执行攻击，关键在于精确确定需要覆盖哪些字节，以有效地操控控制流。在这个例子中，溢出发生在执行 buf[sizeof(buf)] = '\\0' 时，导致保存的帧指针 (ebp) 的最低有效字节被设置为 0。因此，需要调整 ebp 的值，确保其指向缓冲区区域，从而使执行流程按预期进行，最终跳转到 bar 函数。\n基于进一步的分析和测试，得出以下见解：\n要准确确定覆盖位置，ebp 的值至关重要。然而，获得这个值是有挑战的，因为：\nGDB 调试会影响地址布局。 输入参数的长度会影响地址布局。 在 GDB 调试下，foo 函数内的布局如下：\n执行 buf[sizeof(buf)] = '\\0'; 后，ebp 被修改，使得返回地址实际上取的是 ebp + 1 处的值，即地址 0xbfffed00 + 1，也就是 0xbfffed04。\n对应的偏移位置在 buf 的第 255 个位置，这意味着可以通过只在该特定位置填入返回地址来构造攻击。在 GDB 中使用以下命令进行验证：\nr $(perl -e \u0026#39;print \u0026#34;\\x01\\x01\\x01\\x01\u0026#34;x254 . \u0026#34;\\x38\\x84\\x04\\x08\u0026#34;x1 . \u0026#34;\\x01\\x01\\x01\\x01\u0026#34;x1\u0026#39;) 经过验证，这在 GDB 调试下是有效的，但需要注意以下细节：\n输入参数的长度必须始终为 256 字节，否则 ebp 的值会发生变化，因为输入参数会占用栈空间，从而影响帧的起始位置，进而影响 ebp 的值。 填充必须使用非零值，如 0x01，因为如果遇到 0 值，strncpy 会提前终止。 直接执行程序时（即不使用 GDB），内存布局不同，导致偏移位置也不同。通过实验，发现偏移位置在第 235 个位置。对应的攻击命令是：\n./obo $(perl -e \u0026#39;print \u0026#34;\\x01\\x01\\x01\\x01\u0026#34;x234 . \u0026#34;\\x38\\x84\\x04\\x08\u0026#34;x1 . \u0026#34;\\x01\\x01\\x01\\x01\u0026#34;x21\u0026#39;) 这样就实现了找到准确覆盖位置并成功执行攻击的效果。\n","date":"2024-10-15T14:18:44Z","permalink":"https://nansenli.com/zh-cn/post/2024/10/oboattact-md/","title":"Off-by-One 溢出攻击分析"},{"content":"ChatGPT生成的公式使用了以下格式：\n\\[ 公式内容 \\] 而Obsidian中的公式渲染使用的是以下格式：\n$$ 公式内容 $$ 当我们将ChatGPT的公式复制到Obsidian中时，这种差异会导致无法正确渲染。\n解决方案 我们可以创建一个Obsidian脚本，在粘贴操作时自动替换公式的格式。\n1. 创建脚本 可以使用Obsidian中的插件来解决这个问题。\n在你的库中，在template目录下创建一个文件fixlatex.js，并输入以下内容：\nmodule.exports = async (params) =\u0026gt; { const { quickAddApi } = params; // 获取剪贴板内容 const clipboardContent = await quickAddApi.utility.getClipboard(); // 检查是否成功获取内容 if (!clipboardContent) { new Notice(\u0026#34;剪贴板为空或无法访问。\u0026#34;); return; } const modifiedContent = clipboardContent .replace(/\\\\\\[|\\\\\\]/g, \u0026#39;$$$$\u0026#39;) // 转换 \\[ \\] 为 $$ $$ .replace(/\\\\\\(\\s*|\\s*\\\\\\)/g, \u0026#39;$$\u0026#39;); // 转换 \\( \\) 为 $ // 将修改后的内容写回剪贴板 await navigator.clipboard.writeText(modifiedContent); new Notice(\u0026#34;剪贴板内容已处理并修改！\u0026#34;); }; 2. 在QuickAdd中设置脚本 安装QuickAdd插件，并创建一个Macro，按如下图中的配置进行设置并保存。Macro的第一步是执行我们刚刚创建的用户脚本fixlatex.js，第二步是等待100毫秒，第三步是执行粘贴操作。\n3. 在Commander中设置侧边快捷键 安装Commander插件，并将刚刚创建的QuickAdd操作设置为侧边栏的快捷键。你也可以跳过这一步，直接使用Obsidian命令执行这个操作。\n4. 验证效果 现在，在ChatGPT的网页中（目前在APP中点击复制按钮似乎有点问题），点击复制按钮后，在Obsidian中点击侧边栏快捷键，或者手动执行QuickAdd命令，就可以将ChatGPT中的内容复制到Obsidian中，并自动转换Latex格式。\n","date":"2024-10-14T15:24:27Z","permalink":"https://nansenli.com/zh-cn/post/2024/10/obsidian-latex-fix/","title":"将ChatGPT公式格式转换为Obsidian兼容格式"},{"content":"关于我 本文书写于 2024年10月11日，都柏林，爱尔兰。\n自我介绍 大家好，我叫李楠森，曾用名李楠。我来自中国，是一名热爱科技的工程师。我拥有机械电子的本科学位和两个计算机科学的硕士学位。我曾在中国一家大型互联网公司担任过 Go 语言工程师，目前正在都柏林一所大学攻读硕士学位。之后计划在爱尔兰发展。\n我对前端和后端开发、系统架构、算法、游戏开发，以及生成式 AI 有着浓厚的兴趣。我一直致力于提高自己的编程能力，也喜欢尝试新技术，保持对行业发展的敏感度。\n如果你对技术或者生活方式有相同的兴趣，欢迎联系我，我们可以一起讨论和交流。\n","date":"2024-10-11T20:55:02Z","permalink":"https://nansenli.com/zh-cn/post/2024/10/aboutme/","title":"关于我"},{"content":"我是李楠森，这里是我的第一篇笔记，我不知道我能记录多少内容，也不知道能记录多久，但是我会尽力坚持去记录。\n于 2024年10月11日凌晨 1点20分 爱尔兰 都柏林\n","date":"2024-10-10T21:06:26Z","permalink":"https://nansenli.com/zh-cn/post/2024/10/myblog/","title":"我的博客"}]