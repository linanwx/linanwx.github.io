[{"content":"这里总结一下过去一年来的所有面试经历。\n总体来说结果还算满意。从NG（应届生）到社招岗位都有在持续投递简历，最终拿到了一个满意的Offer，也算顺利上岸。希望这份经历对未来来爱尔兰读书、找工作的同学有所帮助。\n在进入具体内容前，先介绍一下我的背景：我之前在国内大厂工作了几年，后来来DCU读硕士，在爱尔兰找的是Software Engineer相关岗位。\n从去年10月（入学后不久）开始，我就陆续投递简历，主要是NG岗位和实习岗位。一直投到次年2月，其间只收到了一个Google实习的面试。后来因为实习比较忙，暂停了投递。等到考试结束（5月）后，我集中投了一批岗位，并陆续收到了多个面试机会。经过面试流程，最终拿到一个正式Offer。从这次集中投递到收到Offer，大约花了一个半月时间。\n我每次投简历都有做记录，总共至少投了81个岗位。\n下面是部分收到面试邀请的岗位记录：\nGoogle 实习岗位 视频面试两轮：\n第一轮是一道 LeetCode 中等难度的算法题； 第二轮是一道简单题，但表现很差，猜测因此未通过。 Apple 测试岗位 第一轮视频面试：考察SQL和一些基础算法；\n第二轮考察内容较杂，从简历展开到测试理论、再到Python的 requests 包；\n整体感觉发挥一般，猜测未通过原因可能是略有不足，以及岗位与开发背景匹配度不高。\nApple Full Stack 岗位 虽然收到了面试邀请，但因为岗位在科克，而我已经决定在都柏林发展并租好了房子，所以直接婉拒了这次机会，略感遗憾。\nMeta SSE 岗位 当时正值考试周，与Recruiter协商推迟了一个月，结果之后对方就再也没联系，应该算是被ghost了。不过我并不觉得是自身问题，因为有朋友面试表现非常好，最后也没通过，可能与Meta今年的HC（headcount）缩减有关。\nAmazon SWE 岗位 第一轮面试内容包括：\nBQ（行为问题）部分：回答还算可以；\n技术部分问的是OOP设计而非算法题，但我准备不足，对OOP不熟；\n再加上Amazon大多是Java岗位，我个人对Java兴趣一般，没通过也算顺其自然。\nPTC SWE 岗位 一开始电话中就明确表示不提供工签。我提到可以先以1G身份入职，场面略显尴尬。虽然后续还是走完了流程，但最终没有推进。\neBay SWE Recruiter进行了初步沟通，问了一些基本问题，之后未进入下一轮。推测是已有更合适人选。\nWorkday Recruiter初步交流很顺利，进入等待流程阶段。原定面试时间临时被取消，之后又重新预约。因为那时我已经在等待Arista的正式Offer，所以主动停止了推进。\nArista Recruiter首次联系是在我在健身房时，声音太嘈杂，约定稍后再联系。之后HR发送了第一次面试的时间。\n第一次面试：由于技术故障未能顺利开始，重新约时间后进行了两道算法题，通过；\n第二轮：现场面试，继续两道算法题，第二题难度较高，花了一个小时完成，通过；\n第三轮：同样是现场面试，问题更深入；\n面试通过后，等待总部审批正式Offer，整个流程大概等了一个月。\n经验总结 NG和社招岗位都可以投递，不要因为“overqualified”而自我限制，实际并没有那么大的影响； 视频面试的压力比预期大：平时能做出的题，面试时可能连简单题都发挥不好； 刷题要系统：建议至少刷100道LeetCode，200道是一个比较稳妥的水平，再往上看时间精力，追求性价比； 别怕被拒：每次拒绝都是一次筛选，帮助你找到更适合自己的岗位；要及时总结经验，继续下一家； 心态要稳：投递简历本质就是概率问题，关键是持续输出+良好积累。 祝大家也都能顺利上岸！\n","date":"2025-07-29T23:52:58+01:00","permalink":"https://nansenli.com/zh-cn/post/2025/07/interview2025/","title":"面试经验总结"},{"content":"最近在看MCP相关的内容，其中很多都提到了使用uv来管理Python的包依赖。通过了解，uv看起来是一个很有用的工具，这里总结一下功能。\nuv到底是什么呢？ uv首先是一个包，是使用rust语言写的一个Python包，安装后，可以使用uv命令。\npip install uv uv能做什么？ 能代替pip 在平时使用的pip命令前，加上uv就好了。既然如此，为什么一定要用uv，而不是pip？答案是因为非常块，据统计，是pip的77倍。\n能代替venv或virtualenv 少装一个包，命令更整洁。uv 在创建虚拟环境和安装包方面比 venv 和 virtualenv 快很多。\n能代替poetry 问题来了，poetry是什么？poetry是用来更方便的管理Python的依赖问题。那为什么不用pip + requirements 呢？答案是麻烦。另外，requirements文件，不能锁住依赖的依赖，比如，我锁住了A这个包的版本，但是A又依赖B、C、D，而这使得“在我电脑上能运行但在别人的电脑上无法运行”问题很常见。现在，有了uv，poetry也被代替了。\n能用来代替pipx 问题又来了，pipx是啥？pipx是一个安装Python工具但是不污染环境的工具。\n举个例子，假如我需要安装一个命令行工具，我会运行\npip install httpie 但是它可能会污染我的环境，卸载还会有副作用。而现在，我可以运行\npipx install httpie 不会污染环境。\n不过呢，现在这条命令也被代替了，现在可以运行\nuv tool install 一句话总结uv：Python 依赖管理的“下一代事实标准”。\n","date":"2025-05-11T21:02:54+01:00","permalink":"https://nansenli.com/zh-cn/post/2025/05/pythonuv/","title":"Python uv 包学习"},{"content":"我于这学期完成了DCU 的 Secure Software Engineering的所有考试，我在这里分享一下相关经验。\n更新：我的成绩已经出来了，平均分是75分，达到了一等一的学位水平。祝大家都能取得满意的成绩。\n该项目总共包含8门课程，其中包含上半学期4门课程，下半学期4门课程，所有课程均需要考试通过，难度不小。\n要想通过考试，其中最重要的有以下几点：\n参与课堂。尽量参与每一堂课，课堂可以加深学习的印象，而且有时会明确说明考试考察的内容方向。例如，今年考察的某个题的题型是某一个特定方向的题型。这对通过考试帮助很大。 仔细做近年的题目。前往dcu.guruarchive.com下载历年的题目。仔细研究题型，若课程变动不大，则过去两年的题型可能不会考察。若课程变动，则过去两年的题型作为主要考察内容。建议至少做2年，最多做5年的题目。 仔细完成作业内容。每次提交的作业内容都将直接评分，并决定最终的成绩。通常来说，作业内容占据考试成绩的25%。由于作业是离线的，并不要求背诵和记忆任何内容，因此，只要肯付出努力，就可以取得较高的平时成绩，极大缓解考试通过的压力。 考试概述 上半学期课程 Cryptography and Number Theory System Software/BlockChain Secure Programming Professional \u0026amp; Research Practice 下半学期课程 Formal Programming Concurrent Programming Software Process Quality Network Security 上学期，课程压力不算大。其中重点的课程是Secure Programming以及Cryptography and Number Theory。另外还有一门课程，是System Software/BlockChain，具体是哪门课程，要看学校的安排。如果是BlockChain，则相对轻松，如果是System Software，则有一定压力。Professional \u0026amp; Research Practice这门课程相对轻松。总体而言，上半学期的课程相对轻松，有两门课是考试重点。\n下学期课程，课程压力较大。几乎所有课程都有一定的难度。稍微容易一点的Software Process Quality 也不太容易取得高分。因此学业压力会有一点大。\n下面是关于每一门考试的细节。\nCryptography and Number Theory 课程难度：⭐️⭐️⭐️⭐️⭐️ 考试难度：⭐️⭐️⭐️⭐️⭐️ 这门课程的前面几节课难度尚可，在哈希函数之后的内容，难度飙升。特别是关于Cryptanalysis和Number Theory的部分。不幸的是，难的内容反而是考试的重点。\n想要通过这门课程，并且取得高分，并且花费最少的时间，建议操作方式如下：\n认真听课，不缺席课堂。 在上课前，花费1小时时间，简单预习。对于Cryptanalysis和Number Theory的部分，花费2个小时预习。 如果课堂内容没有听懂，特别是密码分析和数论的部分，不需要太担心，只需要跟上课堂的节奏即可。 认真完成大作业，一般是线性攻击或者差分攻击分析，由于大作业必然出现在考试题目中，如果大作业不是自己认真完成的，则在考试中会带来挑战。作业难度相当高，并且高达25分。想要拿到满分，需要花费至少4天的时间，来完成程序的编写和验证。我的题目是Feistel 4 的差分密码分析。 在考试前，仔细做过去四年的卷子。并把课堂上没有听懂的密码学内容弄明白。 System Software/BlockChain 这门课程需要根据学校的设置。我参与的课程最终上的是BlockChain\n课程难度：⭐️⭐️ 考试难度：⭐️⭐️⭐️ BlockChain的内容主要是视频课程，并不需要参与线下的课程。这使得上学期的安排更加轻松。\n作业内容是一份报告，以及2到3人的关于密码学的PPT演讲。\n总体来说，这门课程理解上不需要花费太多的时间，考试也不算太难。尽管如此，这门课程通过难度不高，但是想要取得高分却很困难。若想要取得高分，需要深入理解考试卷子的内容，认真准备课程作业，并且背诵大量内容，同时在考试分配好时间，尽可能书写多的内容。\n如何通过：\n熟练背诵过去4年卷子中出现的题目即可。考试题目多为区块链的问答题，可以背诵模板回答。 认真准备PPT演讲的assignment以及对应的论文。论文需要有一定深度。 Secure Programming 课程难度：⭐️⭐️⭐️⭐️⭐️ 考试难度：⭐️⭐️⭐️⭐️⭐️ 我个人认为这是最有含金量的课程了。\n这门课程的内容相当丰富，包含了计算机从顶层到底层的所有内容，例如Linux，操作系统，C语言编程，逆向工程，数据结构，GDB调试等等。\n这门课程不包含作业，取而代之的是两场小的随堂考试。因此，这门考试加上期末考试，总共会有3场考试。\n其中第一场考试是期末考试的预演，题型类似。第二场考试则是一个独立的，安全攻击的考试，需要自己研究并编写代码，进行攻击。\n如何通过这门课程\n尽可能的参与课堂，并且尽最大努力去记忆课堂出现的所有信息。要想通过这门课程，需要有非常扎实的计算机技术特别是计算机底层原理的相关知识储备。 取得平时考试的高分。这门课的老师非常的好，他总是会尽可能的将考点内容提前演练，所有的题目都是来自曾经考察过的内容的变体，因此，好好准备教授提供的复习材料是取得平时考试成绩的关键。 熟练做往年的卷子，保证彻底理解往年题目，特别是Linux Permissions 的部分。 考试时，6道题目可以选择5道题目回答，可以选择其中一题放弃，可以选择放弃关于安全攻击的那一题，因为安全攻击的已经随堂考察过了，本身内容也较多不好复习。你也可以根据自己水平放弃一题。 Professional \u0026amp; Research Practice 课程难度：⭐️⭐️⭐️ 考试难度：⭐️⭐️⭐️ 这门课程的平时成绩占比在50%。其中包含一个文献综述，一个视频演讲，一个论文。\n考试成绩占比也是50%。\n对于课堂的部分，可以参加也可以不参加。课堂主要以答疑为主。\n如何通过这门课程：\n作业内容尽量认真对待，取得一个很好的平时成绩的分数。想要获得高分，其中对于论文的部分，格式非常的关键。视频演讲的部分，需要足够的吸引人。 熟练背诵过去3年的考试题目。尽管考试可以二选一回答，仍旧需要准备所有的考察内容。 需要自己准备一份历年的标准答案。需要对整个课程的所有大纲有一个大致的了解。接下来，检查考试卷子的每一道题，使用对应的部分的材料，生成该题目的答案，然后背诵。 平时课堂可参与也可以不参与。因为主要是答疑为主。偶尔穿插一些关于practicum以及找工作的相关信息。 Formal Programming 课程难度：⭐️⭐️⭐️⭐️⭐️ 考试难度：⭐️⭐️⭐️⭐️ 这门课程的难度非常的高，其中涉及到复杂的逻辑推理过程。好在考察的难度还属于可接受的范围。\n如何通过这门课程：\n尽量参与每堂课，对课堂的内容进行听讲，尝试跟上并理解课堂内容，例如一些公式、原理或者推导过程。 认真完成课堂第三节课的作业题目，也就是Event-B建模题目。 对于课堂内容，如果没有听懂，不用太担心，考前复习时弄明白即可，特别是各种Law，大致有印象即可。 在考试前，认真完成过去3年的卷子，将课堂上没有听懂的内容完全搞明白。 Concurrent Programming 课程难度：⭐️⭐️⭐️ 考试难度：⭐️⭐️⭐️⭐️⭐️ 这门课程的难度并不算高，但是需要考察的内容非常多。\n考试需要背诵大量的内容，需要会书写大量的程序片段，API接口，实现大量的方案、原型设计等等。\n如何通过这门课：\n平时作业需要认真完成。 对于考试，需要大量的做练习题，需要至少做5年以上的卷子才会比较保险。尽管题目6选5，但是由于题目考察不固定，难度波动大，建议所有题型全部复习，而不是针对性的放弃某个题型的题目。 参与每一堂课，尽可能对课堂中出现过的所有内容有一个大致的了解和记忆。因为考试涉及面广泛，所有出现过的内容都可能会是考点。 由于考试内容大量涉及到背诵和记忆类的内容，建议在上课时，提前确认当前所讲的内容是否是考试的内容，若是，则需要在课堂上尽可能的记住。 可是将历年试卷整理成资料库，在课堂上询问AI该部分的内容是否是考卷的内容。若是，则认真听讲。 这门课非常建议先浏览试卷，弄明白考察的内容。建议和AI沟通，确认过去3年的题型规律。由于这门课主要考背诵和记忆，因此课堂吸收很关键。 Software Process Quality 课程难度：⭐️⭐️ 考试难度：⭐️⭐️⭐️ 这门课程难度并不高，但考察的内容则比较杂。\n考试复习时，优先复习重复往年卷子中考察的内容，例如Karnaugh和 Clause Coverage的题目。由于题目题型波动较大，尽管是6选5考察，仍旧建议复习所有出现过的题目类型。 课堂可以参与也可以自学。 作业内容并不难，认真对待，恰当的选择合适的题目可以取得高分。 ","date":"2025-05-04T12:00:00Z","permalink":"https://nansenli.com/zh-cn/post/2025/04/dcu-secure-software-exam-cookbook/","title":"Dublin City University MSc in Computing: Secure Software Engineering 考试经验"},{"content":"Github copoilt 面对陌生的Github项目，再也不用害怕看不懂了。点击项目主页的Copolit图标，即可对话，还可使用GPT4.1交流，高达1M窗口上下文，从“这个项目能用来做什么”到“如何部署和处理bug”之类的问题，都能很好回答。\nDia 浏览器 https://www.diabrowser.com/\n目前还未公测，可以通过上面的链接提交邮箱进入等待名单。\nArc浏览器确实很好用，它拥有稳定、成熟且一致的体验，不单纯的只是侧边栏标签创新那么简单。\nDia是Arc浏览器的下一代产品，其实不太理解为什么要重新发布一个新的产品，直接在Arc浏览器上做整合应该是最好的。现在创始人的想法反而是搁置Arc浏览器了。\n从产品体验上来看，Dia浏览器似乎分为下面几个部分：\n一个内置的AI助手，可以进行日常对话 一个类似nanobrowser或browser-use的浏览器操作助手，帮助规划和操作浏览器 一个AI写作助手，可以在光标处生成文本 很有潜力的产品\nGPT o3 / o4-mini / o4-mini-high/ 4.1 / 4.1 mini / 4.1 nano 发布 模型 上下文窗口 输入定价 输出定价 图片定价 主要特性 o4‑mini‑high 200K 令牌 $1.10/M $4.40/M $0.842/K 图像输入 o4‑mini 的高推理努力版本；高吞吐、低延迟；支持链式调用与结构化输出 o4‑mini 200K 令牌 $1.10/M $4.40/M $0.842/K 图像输入 紧凑型推理；AIME 99.5%、SWE‑bench 高分；优秀 STEM、视觉与代码编辑能力 o3 200K 令牌 $10/M $40/M $7.65/K 图像输入 通用型强模型；顶级数学、科学、编码与视觉推理；需 BYOK GPT‑4.1 1.05M 令牌 $2/M $8/M N/A 旗舰大模型；百万令牌上下文；卓越指令跟随、企业级检索与多模态理解 GPT‑4.1 Mini 1.05M 令牌 $0.40/M $1.60/M N/A 中型版本；接近 GPT‑4o 性能；低延迟、低成本；强编码与视觉理解 GPT‑4.1 Nano 1.05M 令牌 $0.10/M $0.40/M N/A 系列中最快最廉价；百万令牌上下文；适合分类与自动补全任务 GPT-4.1 Nano 天生适合翻译，成本非常低，例如配置在沉浸式翻译，开启中英双语字幕，平均每一集黑镜，仅需要0.5美分，翻译完7季只需要0.25美元，成本非常低。\nGPT-4.1 的上下文窗口终于来到1M了，之前GPT写代码简直被吊打，现在只能说追平了。\no3、o4-mini、o4-mini-high表现非常惊喜，有一种小的deep research感觉。\n目前，我的日常基本上变成了：\no4-mini： 简单搜索和总结，可容忍失误 o4-mini-high: 复杂搜索、总结、多步推理 o3: 对准确率要求较高的复杂搜索、总结、多步推理 4o: 直觉类和记忆知识类的回答 而且我统计了每个模型的使用次数，差不多几乎都在使用，没有说哪个模型派不上用场的，不像是o3-mini幻觉太高基本就用不了。\n元宝接入微信联系人 元宝微信，可以直接添加联系人发送信息。支持语音消息和图片消息。是豆包的竞品。优点是无需安装额外的应用。之前给父母推荐了豆包，他们都很喜欢使用。如果元宝也能支持语言通话，甚至视频聊天的话，可能会更有价值。\nOpenAI免费令牌 OpenAI 现在推出免费领牌活动，可以在Data controls中的sharing开启分享日志，即可领取。可惜就是时间太短了，只有一两周的时间，基本上用不完这么多额度。\nGithub 其他日榜周榜相关 https://github.com/kestra-io/kestra\n自动化运行平台，竞品包括：Airflow（数据管道）、Zapier（低代码营销自动化）、Rundeck（运维自动化）、Camunda （电商业务自动化）\nhttps://github.com/Zackriya-Solutions/meeting-minutes\n一款语音转文本的软件，苹果 voice memos 的竞品。\nhttps://github.com/maybe-finance/maybe\n个人财报管理，类似有知有行\nhttps://github.com/supabase-community/supabase-mcp\n在本地使用 AI 开发软件的时候，用于连接数据库的软件，基于 MCP 协议实现。若 MCP 真实未来标准协议之一，那数据库本身可能就会支持 MCP，可能会形成竞品。\nhttps://github.com/langgenius/dify\n低代码 LLM 平台，LangChain的竞品，在现阶段的应用领域可部分代替LangChain。\n","date":"2025-04-20T12:58:30+01:00","permalink":"https://nansenli.com/zh-cn/post/2025/04/tech250402/","title":"2025 年 4 月科技随笔2"},{"content":"前言 打算从这期记录一些每周的科技相关的随笔，还有一些感悟之类的。大概每两周到一个月更新一期吧。\n个人博客从 Hugo 替换成 Hexo 这周开始，我把博客从 Hexo 迁移到 Hugo，主要是因为：\nHugo 对 i18n 支持更好。因为 Hexo 对 i18n 并不太支持，之前自己魔改了模板，最后实现了中文和英文切换，但是维护成本很高，了解后发现 Hugo 原生支持多语言。\n不过在切换后，发现也有以下一些优点：\n主题配置更简单。我使用的是Stack 主题，基本上没有遇到坑。官方自带的 example 配置就很好，照这配置就好。另外，还带 Google Analysis 分析，还带 RSS 源，源也会自动区分语言，非常舒适。\n在切换的过程中，基本上没有遇到什么障碍，只要有你过去的 Markdown 文件，直接复制到新工程的目录下，再强制推送到原来的 github pages仓库，就可以直接迁移过来。强制推送后，需要在 github重新配置一下自定义域名，就无损升级了，包括评论之类的都是一样的。\n唯一不同的是，Hugo 默认使用小写链接，而 Hexo 默认保留大小写，这可能使得过去的一些链接失效，搜索引擎需要重新建立索引。\n神秘模型Optimus Alpha出现在https://openrouter.ai/ 并霸榜 由于该模型免费，并且性能很强，在上线后，就被选择成为 OpenRouter 的首席流量处理模型。\n随着14 号 OpenAI 官方公布 GPT4.1 后，该模型从 OpenRouter 下架。显然，该模型就是 GPT4.1。\nGPT4.1 是一个编程能力特化的模型，拥有 1M 的上下文窗口。确实，现在编程领域，OpenAI 被 Claude 3.7 还有 Gemini2.5pro 打的鼻青脸肿，无论是 o1 还是 o3 模型，都没能在编程领域取得什么领先地位。希望 OpenAI 再接再厉吧。\nOpenRouter 是一个让用户统一接入多个大语言模型 API 的中间层服务平台。你可以把它理解成一个「代理」或「路由器」，统一管理不同大模型厂商（OpenAI、Anthropic、Mistral、Google Gemini、Cohere 等）的调用方式。\n看起来，这次，OpenAI 选择了 OpenRouter 作为测试发布平台，而不是https://lmarena.ai/\nOpenRouter.ai OpenRouter\n这是一个 LLM平台，包含大量的免费/收费高质量模型。\n选择 Prompt pricing 为 0 元，再选择 Top Weekly，就可以看到目前最好的免费模型。\n不过使用时需要开启 log 和使用数据进行训练。\n目前可以选择 Gemini 2.5 pro。\n其中Ranking功能可以实时查看平台上所有的流量分发情况，哪个模型好用一目了然。\nnanobrowser 一款用于 Chrome 的浏览器插件，可以控制浏览器的自动化操作。\n试验了一下，无法支持 Arc 浏览器。体验下来能力有限，例如，对网页的滚动偶尔失效，无法总结整个页面的内容，只能看到局部的内容，操作偶尔不正确。\n虽然该产品不太推荐，不过这可能是未来一个方向，看起来，以后会出现大量的 AI 代理。\n抢票、刷分之类的灰色产业估计会很开心。\nmarkitdown 一款用于将不同格式的内容转换成 Markdown 格式的工具。\n离线情况下，可以处理不同的文件转换成 Markdown 格式，试用了一下，转换得比较基础。\n也可以支持接入 LLM，提升转换结果和文档中图片的部分。\n在未来可能是一款不错的 MCP 服务。\nPDF search 一款应用，可以快速搜索多个 pdf 中出现的内容。\n使用类似模糊搜索的方式，原理是对 PDF 做了分割并且进行了嵌入向量计算，随后和搜索词进行匹配。\n适合考试期间搜索文档使用。\n缺点是，index 是按照页面划分的，搜索后需要自己在页面中找到对应的 part。\n","date":"2025-04-15T20:45:20+01:00","permalink":"https://nansenli.com/zh-cn/post/2025/04/tech2504/","title":"2025 年 4 月科技随笔"},{"content":"其实这篇算不上攻略吧，只是对晨鹤的一些内容做一些个人的补充分享。\n晨鹤链接：https://chenhe.me/post/ireland\n晨鹤写的内容挺好，很详实，基本上解答了我很多当时来爱尔兰的困惑\n文章未完成，本文不定期更新。\n背景 地点在都柏林，录取的学校是 DCU。\n出发前 直接点名型号吧，苏泊尔小绿锅压力锅。为什么必须要这个而不是其他的呢，因为：1. 压力蒸出来的米饭更好吃。 2. 炖煮类的，例如炖牛腩，卤鸡腿之类的，更方便。 我自己也带了小米的电饭煲，但是来了这边发现电饭煲煮的饭一点也不好吃，只有高压锅煮出来的饭好吃😋。另外，好像只有这款 10 分钟压力就能煮完米饭了，看了下其他款，并没有这么快的速度，我猜想可能和他的小容量有关。 药品：强烈推荐带一盒感康，感冒的时候吃一粒马上就好多了。创可贴可以带一些透明的防水的那种。 水杯：来了之后，发现想买到喜欢的水杯好难。如果人在国内，淘宝上买一个合适的水杯很重要。 小红书：以前以为是个美妆 APP，在国内几乎没有用过。出国才发现这是个出国 APP，以下内容小红书上有大量攻略，可以酌情浏览，当然有的人不太喜并对其嗤之以鼻，萝卜白菜各有所爱吧（晨鹤不要打我）。 驾照：我带了，但是来了就过期了，所以没怎么用到。如果有效期内的话，考驾照会减免考试所需要的时间。 现金：其实不用换太多欧元。在国内办好一张双币信用卡，例如 visa 或者 master card，来了这边是可以直接刷卡的。这边现金消费的场景比较少。 衣服：建议带多层的穿搭。由于这边天气多变，室内外温差大，可能会频繁增减衣物。冬天还是蛮冷的，羽绒服类似的厚度的可以带两件换着穿。 行李箱：海南航空可以申请留学生认证，可以携带最多两个 28 寸的行李箱。不过对我来说太多了，我最后带了一个 20 的一个 28 的。另外 28 寸行李箱其实塞满也很容易超重。想带 26 寸的也可以。 体验，牙科，手术等等：这边费用比较贵，在国内尽量都做了。例如补牙或者激光手术等等。 转换插头：一个高质量的转换插头会很方便。可以考虑准备一些简单的转换插头，再买一个带多口充电口的转换插头。另外可以考虑购买一个特殊排插，头是英标的，插座是国标的。 生活费：租房可能要 600-1200 欧，如果自己做饭，伙食每个月 500 欧，生活费可能是 1000-1800欧一个月，取决于个人消费水平。 机票：海航直飞都柏林的机票不错，特别是，如果你从上海转机而不是在北京飞，机票会更便宜。也就是说多做一段飞机反而更便宜。 临时住宿：可以在Airbnb 或者 Booking 上预定临时住宿。 中餐调料：来了之后，你会发现每天的生活很大一部分就是买菜做饭。不过，基本上所有调料在本地中国超市有售卖，因此不必带太多调料品。具体售卖的清单可以搜索融兴行小程序353购查看。 入境 展示下面的内容即可：\n护照 保险 录取通知书 到达爱尔兰后 抵达住宿地点：在机场拦出租车即可。 买电话卡：这个可以办理学生套餐的，20 欧，无限流量。我办理的是Vodafone 的。记得配置自动 20 天充值，不然每次都要手动充值很麻烦。 办理公交卡：可以先办理一张成人卡，之后，再到市中心换学生卡。学生卡半价。然后可以在官网将成人卡注销，可以退卡退费的。 办理居留卡 IRP：提前预约，若等到 9 月开学再预约，就要排队到 11 月了。有了 IRP，就可以离开爱尔兰了，例如回国，或者去英国或者欧洲玩了。 办理银行卡：可以通过 AIB 办理，无需到现场办理，手机即可办理。办理需要学生证，学生银行卡可以免年费。银行卡尽早办理，同时提供的地址证明也是办理其他手续的重要资料。 办理PPSN：虽然不是一定要用到，但是万一呢。尽量提前办理好。如果找到实习了就可以报税用了。驾照报考也会用到。 支付 平时日常基本上大部分场景都是刷卡支付，使用银行卡靠一下无线的标志就可以支付了。也可以在手机上配置 Apple pay 进行支付。\n租房 DCU学校旁边有两家公寓，非常推荐， 在 shanowen 路上，一家是 Shanowen Square，另外一家是 Shanowen Hall，最好提前几个月来预约，不然到时候没有空房。市区的话 Beckett House 也不错，适合 TCD 的学生。当然如果摇号摇到学校的公寓是最好的。总之，优先学校宿舍，学生公寓，其次可以找房东租房。寄宿家庭的话，和房东一起住的话，可能因人而异，对我来说，我已经体验过了，不算噩梦，也不算美梦，但有个经历之后就好，让我再来一次我打死不要。也有同学说，寄宿家庭环境不错的。\n居家和床上用品 可以在IKEA 上下单，到时候会送到房间。但是注意时效不一定准，可能会第二天才送。学生优惠记得使用，我记得当时我结完账才发现有优惠，联系工作人员，可以帮你取消再重新结算。Homebase 的东西也不错，里面的电暖气很赞，几十欧很大只又很轻，冬天太冷晚上停暖气的话，可以使用这个。\n药店 在国内很少逛药店，但这里的药店除了药以外，还卖很多其他东西，例如化妆品保健品护肤品洗浴用品。基本上 Boots 就可以搞定。市区的 Boots 有家比较大，二楼还可以拍证件照，非常万能。\n餐饮 基本上都是自己做饭。可以去市区融兴行中超购买。融兴行小程序可以全城配送，配送费满 30 欧备注“融逸生活”免配送费，当天早上订单下午即可送达，非常方便！！！\n其他超市说实话本人用的不太多。DCU 附近有 LIDL 还有 Tesco，里面也有一些生鲜，我主要用来补充一些肉类。\n肉类的话，这边的猪肉实在是味道太大了。基本没吃过。只吃牛肉。\nlidl 的Rib eye steak 味道还不错，肥瘦相间，8 欧多 400g，可以吃两顿。另外就是 lidl 的鸡腿肉了，带皮带骨的价格很划算。\n融兴行有卖牛腩，炖牛肉很好吃。\n这边炉灶不太好用，用的电陶炉居多。可能需要习惯一段时间火力。\n公交 爱尔兰公交系统发达，基本上不需要打车。TFI Live 可以实时查看任意站点的下一辆车的到达时间，比 Google 准，在没有电子指示的站点很有用，推荐下载使用。出行主要是公交车，偶尔会有Luas、Dart 等等。\n网购 推荐使用 Shein，满足一定金额即可包邮。一般快递需要 10 天左右送达。可以购买生活用品等。无食品。\n另外学生可以免费开亚马逊的学生会员半年。极大的减少快递费用。\n不走 Shein如果想要像淘宝一样，买东西，然后 走国际货运公司空运 10 天收到的话，运费极高，2kg 的话运费在 200-300 人民币。走海运，运费便宜一点，2kg 的话，在 60-80 人民币。所以如果买一些日用品的话，Shein 上能买到的话，尽量在 Shein 上买，还包邮费。\nOchama 商品会更全，并且包含各种中国食品，以及部分京造产品（京东旗下在欧洲的公司），结账使用邀请码（7WYM5K）可以获得 10 欧优惠卷。但是运费有点贵，如果没有优惠的情况下，基本上很少用到。\n服饰 南边有一个 Dundrum Town Centre，里面服装比较多。市区 Henry St 的服装也挺多的。\n国内游玩 如果是报了语言班的话（我报了 DCU 的 5 周语言班，还蛮不错的，不然开学冲击太大，相当于提前了解了一下学校），7 月-8 月都比较适合出行游玩。可以去高威科克转一转。但如果没有报语言班，只是 9 月之后的话，来了天气就不太好了，会冷，日照时间也减少了很多，所以 9 月开学的时候可以去玩玩，10 月之后就不太适合玩了。之后适合游玩的话，可能要到第二年 4 月之后了，到那个时候，日照恢复，温度也上升了。\n签证 英国签证尽量在国内就申请好，在爱尔兰申请的话，只给半年，在国内申请，会给 2 年。这样无论是去北爱尔兰，还是去英国，都会很方便。 这边课程很短。寒假和第二学期结束后，有大量时间。这些时间如果没有计划的话，会非常无聊。特别是冬天，日照很短。由于这边签证基本上需要找黄牛排队，所以，推荐来了就开始申请签证。稳一点的话，就抓一家大使馆开始刷签证。在签证期间内，往返一次目的地国家。当前在这个过程中也会花费大量的时间和金钱，但是没有办法，想要获得一张长期的申根签，就需要积累出入境记录。我申请的是法签。通常每次会按照以下时间发放：1 个月、3 个月、半年、一年、多年。单次多次出入境无所谓了，反正超过 3 个月的基本上不可能给单次。 求职 这个也很关键。来之前懵懵懂懂，直到来了之后才有一个清晰的认识。这个部分由于我还在求职，也没有完全走完流程，会在走完流程之后再更新。\nNG 岗位：也就是校招岗位，申请时间在来了之后的 9 月到 11 月份。11 月份之后，大部分校招岗位就关闭了。所以需要尽早申请。无论水平如何，都推荐申请一下 NG 岗位。不过，对于超过 2 年工作经验的人来说，大厂基本上 NG 岗位很难获得。但是相当于走了一下流程，若能够接收到面试，也算是丰富经验了。 社招岗位：申请时间在次年 4 月底开始。由于我刚开始申请，所以也不太能说个所以然。另外，找工作也随缘吧。因为很多公司要求是有 1G 的签证才会有面试机会。申请太早的话，公司是不会处理的。 实习岗位：这个就可遇不可求了，由于硕士只有一年，很多实习岗位并不是面相我们的，而是面相本科生的。只能说，尝试投递吧。 交流 如果有疑问，也可以通过以下渠道联系我。\n小红书：\nWhatsapp：\n","date":"2025-04-10T18:12:47Z","permalink":"https://nansenli.com/zh-cn/post/2025/04/ireland-study-guide/","title":"爱尔兰留学不完全攻略"},{"content":"ChatGPT o4-mini Thu, Apr 17 这两天最新发布的模型，推理能力显著，多步执行能力优秀。看来o4-mini 在实际任务执行表现上全面超越 o3-mini。\n下图展示了我的一个使用的例子，问题是：“黑镜第七季第三集中出现了很多亚裔，这些亚裔是中国人还是韩国人，或者是日本人还是马来西亚人或者新加坡？”，模型成功的多次调用搜索引擎进行搜索，并获取到了正确答案：\n另外，projects也能在该模式下正常被调用和使用了，由于模型可以自主搜索，而不是使用rag的方式，使得搜索文件的效率大幅上升。\nChatGPT （不包含o3、o4-mini） GPT-4o：全能。满足日常交流学习，上下文足够大，轻松处理代码、文档检索等任务。支持多种附件格式和在线执行代码。缺点是生成的上下文长度过小，不适合生成太长内容。对过长的对话，上下文压缩严重，可能会忘记早前的内容。\nProjects：略鸡肋。适合用于多个文件频繁搜索和检索文本的场景。\nGPT-4o mini：弱于 GPT-4o，优点是上下文窗口巨大，推荐用于翻译超长文本的场合。\no1：还不错的思维链模型，用于解决复杂的代码、数学题。不擅长处理感情及需要使用直觉的问题。但思维链过短，且质量不高。建议在输出结果后，将结果作为Gemini-2.5pro 或者DeepSeek-R1 的输入，优化质量。\no3-mini：幻觉严重，不如 o1，但推理速度极快。\nSearch：略微鸡肋。新版本搜索结果被严重阉割，甚至不如模型不搜索时的输出质量。适合替代轻度搜索。\nDeep Research：神器。同类功能中质量最好，输出结果最完善。\nGPT-4.5-preview：优秀。上下文窗口巨大，对长文本理解能力强。拥有海量记忆和最强直觉。其实不擅长推理，但是由于幻觉低，反而表现最好。\nCanvas：整体不如 Cursor。上下文输出太小，文本长度受限。适合边写边编辑的短文本场景。\nWork with Apps on macOS：功能体验被 Cursor 碾压，相当于 Cursor 的精简版。\nClaude Claude 3.7 Sonnet：优秀，适合生成各类代码。网页版支持超大上下文，几乎与 API 提供一致的上下文历史消息保留。模型非常适合撰写沟通类文本，如邮件，用词准确、简洁、不浮夸。缺点是免费版使用次数有限。 DeepSeek R1：幻觉严重，发挥不稳定，偶尔影响使用，对提示词质量要求极高。提示词正确或上下文完整时超越 o1。可以作为 o1 输出结果的输入，优化质量。\nV3：非常优秀，GPT-4o 平替。\nGrok Grok-3：生成文本流畅自然，AI 感较弱，适合自然写作和小说创作。整体中规中矩，生产力方面不如 GPT-4o 提供的工具多。\nGrok-3 + search：优秀。坐拥英文社交数据，快速分析新闻实事。输出内容长，几乎不过滤索搜源内容，比 GPT-4o 搜索能力强。\nGrok-Deep Search：略鸡肋，反而不如 Grok-3 + search。生成内容模板化严重，影响质量。\nGemini 2.5 Pro：非常优秀的模型，GPT-4o 平替，幻觉少，搜索结果质量高，思维链完整清晰，逻辑性强。支持与 Google 工具联动，特殊场景下非常有用，例如上传截图或文本并自动在 Google Calendar 中创建日程。缺点是经常声称自己使用了搜索，但实际上并未执行搜索。\nDeep Research：一般，略优于旧版 GPT Search。偶尔存在理解偏差，搜索和文档生成是分阶段执行，过程割裂，模板化严重。目前唯一能替代 GPT Deep Research 的产品。\nv0.dev 适合编写并在线预览前端组件。 chat.qwen.ai Qwen2.5-Max：非常优秀的模型，GPT-4o 平替，生成速度快，支持思考模式。 知乎直答 支持搜索知乎全网内容。可能的竞品是小红书直答。 Perplexity 支持基础搜索，质量平庸，略鸡肋。 Mistral.ai 速度快，上下文窗口大，GPT4o-mini 平替。 Cursor 神器。可对整个代码仓库建立索引，适合开发大型项目。支持多模型切换，支持本地命令行执行与终端接管，适合以下任务： 撰写 Latex 文档，替代 Overleaf 辅助完成各类作业 代码仓库搜索与特定功能定位 创建单元测试 执行 git 操作 执行部署任务 几乎可以执行一切涉及文档和命令行的功能，在开发、调试、Debug、文档撰写方面均有帮助 真正的现阶段最接近 Agent 的产品（于o3和o4-mini发布后不成立，因为o3和o4-mini也可以多步执行规划并完成任务了。不过o3和o4-mini仍然只能在自己的小环境里完成Agent，而Cursor可以在用户电脑上执行，这是一个优点。） 例子：Leetcode 跟踪器 在淘宝上存在大量的 Leetcode 会员共享账号，但是我们有的时候还是需要将做题记录追加到自己的账号中。购买共享会员账号后，我们可以将某个公司的题目导出为 csv 文件，然后，将自己的做题记录也导出为 csv 文件，之后，对比这两个文件，我们可以轻松的去追踪当前的做题进度。Cursor 非常擅长撰写类似的小工具：\n我们只需要复制网页中的元素，Cursor 就可以为我们撰写完整的 csv 文件，并且自动生成完美的前端界面，极大的提高做题的效率。\n","date":"2025-04-08T19:47:56Z","permalink":"https://nansenli.com/zh-cn/post/2025/04/aitest/","title":"LLM 工具使用体验总结"},{"content":"在 macOS 上安装 Rodin 的步骤（M1 ARM 架构）： 安装 x86 JDK\n从 Oracle 下载 Intel x86 JDK 18（macOS .dmg）：\njdk-18.0.2.1_macos-x64_bin.dmg\n运行安装程序，它会自动配置 Java 环境。\n下载并安装 Rodin\n从 SourceForge 获取 Rodin 3.8/3.9（x86_64 版本）：\nrodin-3.8.0.202304051545-macosx.cocoa.x86_64.tar.gz\n解压 .tar.gz 文件，并将 Rodin.app 移动到 /Applications 文件夹。\n修复 macOS 安全权限\n运行以下命令以绕过\u0026quot;应用程序已损坏\u0026quot;的错误： sudo xattr -cr /Applications/Rodin.app Rodin 应该可以正常运行，无需其他步骤（例如配置 Java VM 路径）。\n","date":"2025-02-01T13:02:01Z","permalink":"https://nansenli.com/zh-cn/post/2025/02/rodin/","title":"如何在搭载 Apple 芯片的 MacBook 上安装 Rodin 软件"},{"content":"这篇文章主要介绍了如何对传统分组密码算法 FEAL-4 进行差分分析（Differential Cryptanalysis），并展示了攻击进程和关键实现细节。文中还包含了部分实验数据和攻击结果，可供有兴趣的读者参考或复现。\n两张重要图片 在正式展开分析之前，先给出两张与 FEAL-4 密切相关的图片，方便对差分传播和整体加密流程有一个直观认识。\n差分传播示意图\n下图展示了在 FEAL-4 中，明文差分（XOR 形式）如何在加密轮次中传播并最终反映到密文上。\nFEAL-4 工作流示意图\n下图是 FEAL-4 的整体加密框架示意，包括明文的左右分块、各轮子密钥注入以及 F 函数的运用流程。\nF 函数的特性 FEAL-4 的轮函数（即 F 函数）可以视作对 32 位输入进行某种随机化排列（Permutation）。在差分分析中，我们并不需要 F 的具体实现，而更关注它的两个关键差分属性：\n若 $X \\oplus Y = 0$，则 $F(X) = F(Y)$。 若 $X \\oplus Y = 0x80800000$，则 $F(X) \\oplus F(Y) = 0x02000000$。 有了这两个结论，在后续分析时就能推断特定差分输入下的输出表现，从而帮助定位子密钥。\n差分路径的详细分析 假设我们选择一对特殊的明文 $P_0$ 和 $P_1$，满足： $$ P_0 \\oplus P_1 = 0x8080000080800000 = P^{\\prime}. $$ 这个特定差分向量有助于简化 FEAL-4 若干轮次输出中的差分计算。\n1. 初始轮次差分推导 令 $(L0_0, R0_0)$ 表示 $P_0$ 的左右分块（同理 $(L0_1, R0_1)$ 表示 $P_1$ 的左右分块）。\n经过第一轮的异或操作后： $$ L1_0 \\oplus L1_1 = (L0_0 \\oplus K4) \\oplus (L0_1 \\oplus K4) = L0_0 \\oplus L1_0 = 0x80800000. $$ 同理可推出右半部分的差分。\n进一步由于加密时存在 “额外一轮 XOR”，可得到： $$ R2_0 \\oplus R2_1 = (R1_0 \\oplus L1_0) \\oplus (R1_1 \\oplus L1_1) = 0x80800000 \\oplus 0x80800000 = 0. $$ 这意味着在后续计算中，差分会以更简单的形式得以归并。\n2. 后向差分计算（Backward Calculation） 当我们获得明文对 $(P_0, P_1)$ 与对应的密文对 $(C_0, C_1)$ 后，可以进一步进行后向推导。令密文记作 $(L, R)$，则：\n计算出 $C^{\\prime} = C_0 \\oplus C_1$，得到 $(L^{\\prime}, R^{\\prime})$。 根据已知差分性质，可在末轮逐步还原 $X^{\\prime}$、$Y^{\\prime}$、$Z^{\\prime}$ 等中间变量。 利用这些结果便可对各子密钥展开攻击或验证。 攻击 K3 在差分分析中，往往先从某个中间轮次子密钥开始，例如 $K_3$。具体步骤如下：\n选取明文对： 我生成了 12 对满足\n$$ P_0 \\oplus P_1 = 0x8080000080800000 $$\n的随机明文。 加密并提取差分： 将上述明文对加密后，得到相应的密文对；结合差分路径推导出 $Y_0$、$Y_1$、$Z^{\\prime}$ 等中间值。 遍历 $K_3$：\n$$ Z^{\\prime} = Z_0 \\oplus Z_1 = F(Y_0 \\oplus K_3) \\oplus F(Y_1 \\oplus K_3). $$\n只要找到满足差分方程 $= 0x02000000$ 的候选即保留。 通过这种方法，我成功得到四个候选子密钥：\ncfa38976, cfa309f6, 4f238976, 4f2309f6 执行以上过程的命令示例为：\n./main -mode=attackk3 -file=K3.txt 该实现与我在 www.theamazingking.com 上介绍的方法一致。\n攻击 K2 在拿到 $K_3$ 的若干候选后，可以继续推算 $K_2$。其核心方程： $$ X\u0026rsquo; = X_0 \\oplus X_1 = F(U_0 \\oplus K_2) \\oplus F(U_1 \\oplus K_2), $$ 其中 $U$ 来自于上一轮运算（包括对 $Y$、$Z$ 等的进一步计算）。同样地：\n生成明文对，满足差分条件 $$ P_0 \\oplus P_1 = 0x0000000080800000. $$ 抓取加密后密文差分，通过遍历所有可能 $K_2$ 值，检查是否能满足差分约束 $=0x02000000$。 命令示例： ./main -mode=attackk2 -file=K2.txt -k3=cfa38976,cfa309f6,4f238976,4f2309f6 最终输出示例如下所示： Candidate K2: 8b722e41 (K3: cfa38976) Candidate K2: 8b72aec1 (K3: cfa38976) ... Candidate K2: 89722e43 (K3: 4f2309f6) Candidate K2: 8972aec3 (K3: 4f2309f6) 攻击 K1 类似地，攻击 $K_1$ 也可以按前面流程来做。\n为了让差分路径能稳定呈现预期结果，我生成了 12 对满足\n$$ P_0 \\oplus P_1 = 0x0000000002000000 $$\n的明文，并验证其加密输出。\n命令示例：\n./main -mode=attackk1 -file=K1.txt -k3k2=\u0026#34;cfa38976,8b722e41; cfa38976,8b72aec1; ...\u0026#34; 可一次性将前面得到的所有 $K_3, K_2$ 候选组合带入，最终找到对应的 $K_1$ 候选。\n攻击 K0, K4, K5 当 $K_3, K_2, K_1$ 全部到手后，就可以反推最后一轮所需的 $K_0, K_4, K_5$。\n设最终加密得到的左、右部分为 $L_0, R_0$。对应的明文分块为 $PL, PR$。则有：\n$PL \\oplus K_4 = LR_0$ $PR \\oplus K_5 = RR_0$ $RR_0 \\oplus LR_0 = R_0$ $f(R_0 \\oplus K_0) \\oplus L_0 = LR_0$ 只要枚举所有可能的 $K_0$，即可通过上述方程解出相应的 $K_4$ 与 $K_5$。然后用其他明文-密文对交叉验证正确性。若都满足，则得到正确的最终密钥集。\n命令示例：\n./main -mode=attackk0k4k5 -k3k2k1=\u0026#34;...\u0026#34; -file=K1.txt -file2=K1_p.txt 实现、优化与验证 1. 自动化生成与并行计算 自动生成随机明文对：在代码中事先控制 XOR 差分，即可批量输出满足需求的明文文件（如 K3_p.txt, K2_p.txt, K1_p.txt）。 并行化搜索：使用 Go 语言的 Goroutines，开启 10 个并行任务，在带有 10 核的 Mac 上最大化利用 CPU 资源。 进度条与可视化：通过 progressbar 库实时显示搜索进度，让实验过程更直观。 2. 验证方法 本地自定义密钥测试\n先选定一套已知的 $K_0$–$K_5$（如 0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 0x00000020），对前面生成的明文对进行加密，并重复差分分析过程，看是否能在结果中匹配这套密钥。\n实验证明能够正确还原这组测试密钥，从而确认代码逻辑的准确性。\n特定明文-密文对测试\n选定一个明文 1234567890abcdef 和在 Einstein Zone 生成的密文 f43ae3eeb56e2bbf，验证最终得到的 256 组候选 $K_0$–$K_5$ 中，每一组都可重现这条加密映射，进一步确认攻击流程无误。\n最终结果 所有解出的 $K_0$–$K_5$ 存放于 final_result.txt。去重后包括以下范围：\nPossible Values for K0 890c2148 890ca1c8 098c2148 098ca1c8 ... 0b8c214a 0b8ca1ca 8b0c214a 8b0ca1ca Possible Values for K1 471f077e 471f87fe c79f077e c79f87fc ... 451f077c 451f87fc c59f077c c59f87fc Possible Values for K2 8b722e41 8b72aec1 8b722e43 8b72aec3 ... 89722e43 8972aec3 Possible Values for K3 cfa38976 cfa309f6 4f238976 4f2309f6 Possible Values for K4 89eb0024 89eb0026 8beb0024 8beb0026 Possible Values for K5 b85e6bc0 b85e6bc2 ba5e6bc0 ba5e6bc2 借助差分分析，我们最终能获得一批子密钥候选集。与现代分组密码（AES 等）相比，FEAL-4 的轮数较少、结构也更为简洁，因此在教学和研究中非常适合用于演示差分分析思路。\n总结 本文详细展示了对 FEAL-4 进行差分攻击的完整流程，包括从差分路径设计、生成明文对、中间子密钥 ($K_3, K_2, K_1$) 攻击，再到最后对 $K_0, K_4, K_5$ 的逆向求解。同时也介绍了代码实现过程中的几处优化和验证方法。\nFEAL-4 算法因为较低的轮数和简单的结构为差分分析提供了便利。然而对于现代更安全、更复杂的分组算法，同样的分析思路也至关重要。本案例希望对密码学的学习者和研究者有所启发，如有任何问题或改进方案，欢迎在评论区讨论交流！\n","date":"2025-01-01T13:15:04Z","permalink":"https://nansenli.com/zh-cn/post/2025/01/feal-4/","title":"差分攻击 FEAL-4：从原理到实现"},{"content":"对于 DCU 安全编程这门课的反汇编，由于题目有一定套路，使用固定的解题思路，可以快速解题\n前置技能 熟悉各种汇编命令 汇编指令 熟悉 % 和 $ 表示寄存器和立即数 $ 与 % 寄存器与立即数 熟悉直接寻址和间接寻址 直接寻址与间接寻址 了解一个case C语言代码到汇编的例子 解题思路 找到入参个数 找到局部变量个数 识别循环体 解析剩余代码片段 识别返回数据 找到入参个数 ebp的位置是saved frame ptr，ebp+4的位置是return address。由于题目往往是约定入参全部为int 或者 int * 类型，因此 ebp+8，ebp+c，ebp+10的位置，分别是入参的第一个参数，第二个参数，第三个参数。\n因此，在代码中快速浏览，寻找 0x__(%ebp) 的字样，找到最大的偏移量。(偏移量-4)//4 的值就是入参的个数。\n例如，下面这段代码\npush %ebp \u0026lt;foo+0\u0026gt; mov %esp, %ebp \u0026lt;foo+1\u0026gt; sub $0x4, %esp \u0026lt;foo+3\u0026gt; mov 0x8(%ebp), %eax \u0026lt;foo+6\u0026gt; mov %eax, -0x4(%ebp) \u0026lt;foo+9\u0026gt; mov -0x4(%ebp), %eax \u0026lt;foo+12\u0026gt; cmp 0x10(%ebp), %eax \u0026lt;foo+15\u0026gt; jge \u0026lt;foo+32\u0026gt; \u0026lt;foo+18\u0026gt; mov 0xc(%ebp), %eax \u0026lt;foo+20\u0026gt; incl (%eax) \u0026lt;foo+23\u0026gt; lea -0x4(%ebp), %eax \u0026lt;foo+25\u0026gt; incl (%eax) \u0026lt;foo+28\u0026gt; jmp \u0026lt;foo+12\u0026gt; \u0026lt;foo+30\u0026gt; mov $0x0, %eax \u0026lt;foo+32\u0026gt; leave \u0026lt;foo+37\u0026gt; ret \u0026lt;foo+38\u0026gt; 我们发现存在 0x10(%ebp) 因此，参数个数为（16-4）/4 ，也就是是3个。\n因此我们可以写出代码的框架，如下\nint foo(int a, int b, int c) { } 其中 a, b, c 存在的栈的位置分别是 ebp+8，ebp+c，ebp+10\n注意，参数从后向前入栈，因此越接近ebp，参数在参数列表中越靠前。\n注意，我们这里先假设全部都是int类型，如果后续有遇到不一致的情况，我们再来修改\n找到局部变量个数 局部变量的个数在代码第三行，sub $0x4, %esp 这里减去的数量，就是分配的局部变量的长度。\n在上面的代码中，显然这里分配了4字节，也就是只有一个局部变量。我们假设这个局部变量就是int类型，起名为i。\n我们继续扩展我们的代码\nint foo(int a, int b, int c) { int i; } 识别循环体 循环体通常是while循环或者for循环。\n对于常见的while命令，我们寻找下面相关的指令：\n判断入口： 判断入口是一个连续的比较命令（如cmp）和一个跳转命令（如jge或jle）组成。找到判断入口有助于我们识别代码中是否有判断或者循环。\n循环： 假如没有循环标志，那么就不是循环体，而是简单的if判断。循环是一个无条件的jmp命令。循环所跳转的位置就是判断条件的开始。\n判断条件： 判断条件是判断入口以及判断入口和前面几条命令组合成的完整判断条件。判断条件就是while括号里的内容。\n现在我们查看下面的例子：\npush %ebp \u0026lt;foo+0\u0026gt; mov %esp, %ebp \u0026lt;foo+1\u0026gt; sub $0x4, %esp \u0026lt;foo+3\u0026gt; mov 0x8(%ebp), %eax \u0026lt;foo+6\u0026gt; mov %eax, -0x4(%ebp) \u0026lt;foo+9\u0026gt; mov -0x4(%ebp), %eax \u0026lt;foo+12\u0026gt; cmp 0x10(%ebp), %eax \u0026lt;foo+15\u0026gt; jge \u0026lt;foo+32\u0026gt; \u0026lt;foo+18\u0026gt; mov 0xc(%ebp), %eax \u0026lt;foo+20\u0026gt; imul (%eax) \u0026lt;foo+23\u0026gt; lea -0x4(%ebp), %eax \u0026lt;foo+25\u0026gt; imul (%eax) \u0026lt;foo+28\u0026gt; jmp \u0026lt;foo+12\u0026gt; \u0026lt;foo+30\u0026gt; mov $0x0, %eax \u0026lt;foo+32\u0026gt; leave \u0026lt;foo+37\u0026gt; ret \u0026lt;foo+38\u0026gt; 判断入口：\n我们寻找一个连续的判断指令和一个跳转指令，我们可以找到 cmp 和 jge 这两个连续指令，就说明这里是判断入口。\n循环：\n我们看到，最后存在一个jmp命令，jmp命令指向了第foo+12的位置，因此foo+12就是循环的判断条件。\n判断条件：\n判断条件的第一句是 mov -0x4(%ebp), %eax ，其中 -0x4(%ebp) 是最后一个局部变量，由于我们只有一个局部变量 i ，因此这句话的意思是，将本地变量i的值赋值给 eax。\n我们看到cmp的命令是：cmp 0x10(%ebp), %eax ，其中cmp 0x10(%ebp) 指第三个入参的值。这句话的意思是计算 eax 寄存器中减去第一个入参的数值，也就是c。\n联合起来，我们就知道，这里是计算 i - c的值，并交给 jge 来做跳转。\n由于汇编的条件判断和C语言条件判断是反过来的，汇编是满足判断则跳过循环体，而C语言是满足条件则执行循环体，因此我们的判断条件也是反过来的。\njge表示大于等于0则跳过循环体，因此C语言的循环条件是小于0则执行循环体，也就是判断 i - c 是否小于 0\n因此我们可以继续完善我们的代码:\nint foo(int a, int b, int c) { int i; while (i - c \u0026lt; 0) { } } 解析剩余代码片段 首先标记下已经处理过的代码\npush %ebp \u0026lt;foo+0\u0026gt; 无用 mov %esp, %ebp \u0026lt;foo+1\u0026gt; 无用 sub $0x4, %esp \u0026lt;foo+3\u0026gt; 分配了几个局部变量 mov 0x8(%ebp), %eax \u0026lt;foo+6\u0026gt; mov %eax, -0x4(%ebp) \u0026lt;foo+9\u0026gt; mov -0x4(%ebp), %eax \u0026lt;foo+12\u0026gt; 判断条件开始 cmp 0x10(%ebp), %eax \u0026lt;foo+15\u0026gt; 判断内容 jge \u0026lt;foo+32\u0026gt; \u0026lt;foo+18\u0026gt; 判断条件结束 mov 0xc(%ebp), %eax \u0026lt;foo+20\u0026gt; incl (%eax) \u0026lt;foo+23\u0026gt; lea -0x4(%ebp), %eax \u0026lt;foo+25\u0026gt; incl (%eax) \u0026lt;foo+28\u0026gt; jmp \u0026lt;foo+12\u0026gt; \u0026lt;foo+30\u0026gt; 循环结束 mov $0x0, %eax \u0026lt;foo+32\u0026gt; leave \u0026lt;foo+37\u0026gt; ret \u0026lt;foo+38\u0026gt; 循环体之前的代码 我们看一下循环开始之前的部分：\nmov 0x8(%ebp), %eax \u0026lt;foo+6\u0026gt; mov %eax, -0x4(%ebp) \u0026lt;foo+9\u0026gt; 我们发现这两句都涉及到了 eax 寄存器\n对于多条涉及eax 寄存器的操作，我们尽量当作一个整体来看\n我们发现，其实这里就是将 0x8(%ebp) 的数值 赋值给了 -0x4(%ebp) ，这两个值分别是 a 和 i\n因此这个部分的代码是\ni = a 循环体中间的代码 mov 0xc(%ebp), %eax \u0026lt;foo+20\u0026gt; incl (%eax) \u0026lt;foo+23\u0026gt; lea -0x4(%ebp), %eax \u0026lt;foo+25\u0026gt; incl (%eax) \u0026lt;foo+28\u0026gt; 对于涉及eax的多条指令，我们不要一条一条看，而是看作一个整体。\n其中，mov 0xc(%ebp), %eax 和 incl (%eax) 可以看作 incl (%b) 注意，由于这里是间接寻址，因此，这意味着，b中存的是地址。因此我们需要修改我们的入参，b这里不是数值，而是地址。这句代码意味着\n(*b)++ 注意\n*b++ 会先对 *b 解引用，再对 b 自增\n因此这里括号不能省略，否则会有问题\n而对于 lea -0x4(%ebp), %eax 和 incl (%eax) ，可以看作 incl (\u0026amp;i) ，这里继续是间接寻址，也就是对后者地址上的数值自增。这句代码意味着 *(\u0026amp;i)++ ，可以简化为\ni++ 之所以这么复杂，是因为汇编指令不能直接对地址进行自增操作，但是可以对一个包含地址的寄存器做自增操作。\n因此，补充了剩余的代码片段，代码应该为\nint foo(int a, int *b, int c) { int i; i = a; while (i - c \u0026lt; 0) { (*b)++; i++; } } 识别返回数据 按照C语言的x86的调用约定，返回数据放在eax中。\nmov $0x0, %eax 很显然，这里直接返回了0\n最终代码 int foo(int a, int *b, int c) { int i; i = a; while (i - c \u0026lt; 0) { (*b)++; i++; } return 0; } ","date":"2024-11-03T14:21:43Z","permalink":"https://nansenli.com/zh-cn/post/2024/11/disassembly/","title":"如何快速解决反汇编问题"},{"content":"在之前的文章中，我使用了 Obsidian 的 QuickAdd 来创建一个脚本，自动转换从 ChatGPT 中复制的文本，修复其中的 LaTeX 格式。然而，对于 Craft 这款应用，并没有合适的插件可以使用。\n我们可以通过 Raycast 来实现这个功能的统一操作。\n创建 Raycast 脚本 首先，我们需要创建一个脚本。\n接着选择 Bash 模板。\n然后，我们编辑这个 Bash 脚本，输入如下代码：\n#!/bin/bash # Required parameters: # @raycast.schemaVersion 1 # @raycast.title Copy From ChatGPT # @raycast.mode silent # Optional parameters: # @raycast.icon 🤖 # @raycast.packageName ChatGPT Utils # Documentation: # @raycast.description Copy From ChatGPT # @raycast.author Nansen Li # @raycast.authorURL nansenli.com # 获取剪贴板内容 clipboard_content=$(pbpaste) # 检查是否成功获取内容 if [ -z \u0026#34;$clipboard_content\u0026#34; ]; then echo \u0026#34;剪贴板为空或无法访问。\u0026#34; exit 1 fi # 处理剪贴板内容 modified_content=$(echo \u0026#34;$clipboard_content\u0026#34; | \\ sed \u0026#39;s/\\\\\\[/$$/g; s/\\\\\\]/$$/g; s/\\\\( /$/g; s/ \\\\\\)/$/g\u0026#39;) # 将修改后的内容写回剪贴板 echo \u0026#34;$modified_content\u0026#34; | pbcopy 创建完脚本后，我们还需要将脚本所在的目录添加到 Raycast 中。\n在这一步中，选择刚刚创建的脚本目录。此时，我们可以在 Script Commands 中看到刚刚创建的脚本。\n如何使用 在复制完 ChatGPT 的公式后，打开 Raycast 的面板，找到刚刚的脚本并运行，此时剪贴板中的内容就会被自动修复。接下来，只需将其粘贴到 Obsidian 或 Craft 中即可。\n","date":"2024-10-26T12:59:17Z","permalink":"https://nansenli.com/zh-cn/post/2024/10/raycast-craft/","title":"如何处理ChatGPT的Latex格式和Obsidian与Craft不一致的问题"},{"content":"背景介绍 我是Nansen，参与了2024年华为爱尔兰研究中心的服务器集群管理优化比赛。在此，我想分享一下这次比赛的经历，并对其中的关键点进行总结。\n我们的算法代码部分可以参考这里: huawei2024\n比赛结果 我们在算法部分获得了第一名，分数比第二至第四名高出约4%-5%，取得了巨大的优势。然而，在演讲环节我们遇到了很大的挑战。首先，我们意识到英语表达方面有提升空间；其次，我们发现演示PPT还可以更精美突出；最后，在时间安排上也存在一些挑战。不过，尽管如此，我们还是在总分上取得了第三名的成绩。\n比赛过程 比赛分为两个阶段。第一阶段有较长的准备时间。当我们确定使用模拟退火算法后，就开始了算法的开发。第一阶段的难点主要在于优化和理解题目需求。在开发过程中，我们遇到了许多bug，但在修复后，分数有了明显提升。\n第二阶段，由于题目在比赛当天才发布，我继续优化第一阶段的算法，成功将评估算法的运行速度提升了1000倍。这显著提高了我们在第二阶段的表现，让我们有足够的实力争夺第一名。\n在决赛阶段，我们的算法表现非常稳定，并在调整后大幅领先对手。然而，由于我们没有足够重视PPT的制作，我们以为只要算法表现好，排名靠前，就能获得高分，但事实证明我们错了。\n经验和教训 算法选择 很幸运，在最初的阶段我就选对了最终的算法，并且在题目发布后不久就构思出了适用于整个比赛的算法框架。然而，我也走了一些弯路，比如尝试了一些不可行的算法（如PPO算法）。在初步尝试无果后，我应该及时停止，而不是继续浪费精力。由于时间有限，我们应追求最短时间内的最优效果，而不是追求一个不切实际、理想中的方案。同时，也要认清自己的能力边界，专注于在短时间内能够实现的目标。\n团队分工 很幸运，这次团队的分工是合理的，我尽力确保每个成员都能发挥自己的价值。改进之处在于，应该更多地与队员沟通，了解他们的意愿和想法。由于我主要负责算法部分，与队友的沟通相对较少，下一次我会在这方面做得更好。\nPPT的制作 我们没有预料到，其他参赛队伍的PPT水平如此之高。我的队友猜测，他们可能有商科背景，这使得他们在制作PPT时具有优势。此外，他们的团队有五名成员，而我们只有三名，这也让我们在人员配备上处于劣势。这些都是客观上的挑战，但如果我们更加重视PPT的制作，或许第一名就是我们的。\n过分投入导致失衡 在决赛阶段，其实我们的算法已经非常出色，分数也超过了此前排名第一的队伍。然而，我仍然花了大量时间继续优化算法，尽管我们的算法分数领先对手很多，但却因此忽略了PPT的准备。事实上，我应该适可而止，并充分理解评分标准的重要性。\n结论 通过参加华为Tech Arena 2024竞赛，我获得了宝贵的经验。这次比赛不仅展示了我们的优势，也暴露了我们在展示技能和团队协作方面需要改进的地方。展望未来，我会牢记这些经验教训，并在今后的比赛中不断改进自己。如果您有问题，可以在留言区反馈给我。\n","date":"2024-10-24T09:58:53Z","permalink":"https://nansenli.com/zh-cn/post/2024/10/huawei2024/","title":"华为爱尔兰研究中心Tech Arena 2024竞赛总结"},{"content":"今天开始了漫长的刷题流程。之前只是简单做了一些题目，保持手感，但今天开始，就要为面试正式准备了。\n之前一直在思考一个问题：如何高效地刷 Leetcode。我认为，要高效地刷题，首先就得背题。书读百遍，其义自见，大语言模型经过大量训练，也锻炼出了写代码的能力。同样地，我相信 Leetcode 也一样，通过多次练习，答案自然会浮现，量变产生质变。\n53. Maximum Subarray 解题思路可以使用 Kadane\u0026rsquo;s Algorithm，代码如下：\ndef maxSubArray(nums): max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) max_global = max(max_global, max_current) return max_global 这是一个典型的动态规划题目，上面的算法其实隐藏了动态规划的本质。\nclass Solution { public: int maxSubArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; dp(nums.size()); dp[0] = nums[0]; for (int i = 1; i \u0026lt; nums.size(); i++) { dp[i] = max(dp[i - 1] + nums[i], nums[i]); } return *max_element(dp.begin(), dp.end()); } }; 这段代码更好地体现了动态规划的思想。\n理解 dp[i] = max(nums[i] + dp[i-1], nums[i]) 的公式可以从动态规划的角度来解析。这个公式的核心在于“在每一个位置上，我们要做出一个最优选择”。以下是详细解释：\n1. dp[i] 的含义是什么？ dp[i] 表示以位置 i 结尾的 最大子数组和。 2. 为什么比较 nums[i] + dp[i-1] 和 nums[i]？ 核心问题是：当前的最大子数组和是否应该包括之前的部分（dp[i-1]）？ nums[i] + dp[i-1]：如果 dp[i-1] 是正数，加上当前的 nums[i] 会让子数组和变大，那么我们选择累加。 nums[i]：如果 dp[i-1] 是负数，我们选择从当前位置重新开始一个新的子数组，因为负数只会拖累当前和。 3. 为什么不用比较后续的数？ 我们在比较时，是假设数组在位置 i 停止。也就是说，我们考虑 [0:i] 这个范围内的最大值，对于位置 i 来说，要么加上之前的子数组，要么放弃之前的子数组，只采用当前的数。 然后，我们遍历整个数组，找出在每个位置停下来的最大值，最终返回最大的那个值。 57. Insert Interval 这是一个经典的区间合并问题，需要将新插入的区间合并到已有的区间中。\n可以使用分解法来解决：\n第一步，将不重叠且在 newInterval 之前的区间添加到结果中。 第二步，合并所有可能重叠的区间到 newInterval 中，注意这里的判断条件。 第三步，将剩余的区间添加到结果中。 注意，合并区间的判断条件是前一个区间的开始小于等于后一个区间的结束，即 intervals[i][0] \u0026lt;= newInterval[1]。\nclass Solution: def insert(self, intervals: List[List[int]], newInterval: List[int]) -\u0026gt; List[List[int]]: ret_list = [] i = 0 while i \u0026lt; len(intervals) and intervals[i][1] \u0026lt; newInterval[0]: ret_list.append(intervals[i]) i += 1 while i \u0026lt; len(intervals) and intervals[i][0] \u0026lt;= newInterval[1]: newInterval[0] = min(intervals[i][0], newInterval[0]) newInterval[1] = max(intervals[i][1], newInterval[1]) i += 1 ret_list.append(newInterval) while i \u0026lt; len(intervals): ret_list.append(intervals[i]) i += 1 return ret_list 只要注意细节，这个题目其实并不难。\n300. Longest Increasing Subsequence 显然是一个动态规划问题。\ndp[i] 表示以某个数字结尾的最长递增子序列的长度。\n每次加入一个元素，我们更新当前的 dp 数组，如果当前数字比之前的小，它们的结果就加 1。\n注意，第一个 dp[i] 是从下标 1 开始的。\nclass Solution: def lengthOfLIS(self, nums: List[int]) -\u0026gt; int: dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[j] \u0026lt; nums[i]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) 复杂度分析：\n时间复杂度：$O(n^2)$，因为有两个嵌套的循环。 空间复杂度：$O(n)$，因为需要一个长度为 n 的 dp 数组。 674. Longest Continuous Increasing Subsequence 这是一个简单题目，但仍然值得理解。\nclass Solution: def findLengthOfLCIS(self, nums: List[int]) -\u0026gt; int: dp = [1] * len(nums) for i in range(1, len(nums)): if nums[i] \u0026gt; nums[i-1]: dp[i] = max(dp[i], dp[i-1] + 1) return max(dp) 392. Is Subsequence class Solution: def isSubsequence(self, s: str, t: str) -\u0026gt; bool: i = 0 j = 0 while i \u0026lt; len(s) and j \u0026lt; len(t): if s[i] == t[j]: i += 1 j += 1 return i == len(s) 这个题目可以用双指针法，以 t 为基准，如果 s 中有相同字符就向前推进，如果 s 到结尾了，说明匹配完成。\n115. Distinct Subsequences 这个问题要求我们找到字符串 s 中有多少不同的子序列等于字符串 t。\n首先，我们需要定义 dp，其中 dp[i][j] 表示从 s 的前 i 个字符中形成 t 的前 j 个字符的不同子序列数。\ndp[i][0] 表示当 t 为空串时，结果为 1。 dp[0][j] 表示从空串中形成 t，结果为 0。 对于 dp[i][j]，其结果取决于位置 i 和 j 的字符：\n如果两者相等，结果等于不匹配 s[i-1] 的情况（dp[i-1][j]）加上匹配的情况（dp[i-1][j-1]）。 如果不相等，则结果等于 dp[i-1][j]。 注意，这里 i, j 指的是前 i 个和前 j 个字符。\n此外，dp[0][0] 初始化为 1，因为空字符串是任何字符串的子序列。\nclass Solution: def numDistinct(self, s: str, t: str) -\u0026gt; int: dp = [[0 for _ in range(len(t) + 1)] for _ in range(len(s) + 1)] for i in range(len(s) + 1): dp[i][0] = 1 for j in range(1, len(t) + 1): for i in range(1, len(s) + 1): if s[i-1] == t[j-1]: dp[i][j] = dp[i-1][j] + dp[i-1][j-1] else: dp[i][j] = dp[i-1][j] return dp[-1][-1] ","date":"2024-10-21T19:39:36Z","permalink":"https://nansenli.com/zh-cn/post/2024/10/leetcode241020/","title":"Leetcode 背题"},{"content":"Off-by-One 溢出攻击分析 背景 上周，我参加了一门安全课程，其中包含了一个 off-by-one 溢出漏洞的示例。以下是原始代码：\n/* 简单的 off-by-one 溢出示例 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; void foo(char *input) { char buf[1024]; strncpy(buf, input, sizeof(buf)); buf[sizeof(buf)] = \u0026#39;\\0\u0026#39;; } void bar(void) { printf(\u0026#34;I\u0026#39;ve been hacked\\n\u0026#34;); } int main(int argc, char **argv) { if (argc != 2) { printf(\u0026#34;Usage: %s input_string\\n\u0026#34;, argv[0]); exit(EXIT_FAILURE); } foo(argv[1]); return 0; } 利用此漏洞的攻击命令是：\nperl -e \u0026#39;system \u0026#34;./obo\u0026#34;, \u0026#34;\\x38\\x84\\x04\\x08\u0026#34;x256\u0026#39; 运行此命令的结果是屏幕上打印出多行 I've been hacked。\n分析 当程序进入 foo 函数时，内存布局如下（使用 GDB 观察到）：\n从上到下，布局包含返回地址、保存的帧指针（saved frame pointer）和缓冲区 (buf)。\n当执行 buf[sizeof(buf)] = '\\0'; 时，保存的帧指针 (ebp) 的最低有效字节被设置为 0。为了确保 ebp 在被部分覆盖后仍然指向 buf 区域内，需要至少 1024 字节的缓冲区。具体来说，需要覆盖 ebp，使其保持在合理范围内（最高到 0xff），这就是为什么缓冲区设置为 0xff * 4 字节的原因。\n理解 foo 返回时的汇编命令 当 foo 函数返回时，通常会执行以下关键的汇编指令：\n1. leave 指令 leave 指令等价于：\nmov esp, ebp pop ebp mov esp, ebp：将栈指针 (esp) 设置为帧指针 (ebp) 的值，恢复栈指针到当前栈帧的顶部，从而释放当前函数占用的空间。 pop ebp：将栈顶的值弹出并赋给帧指针 (ebp)，从而恢复调用者的帧指针。实际上，相当于将返回地址写入 ebp，这意味着将栈中的值（通常是调用者的帧地址）赋给 ebp，从而恢复调用者的栈帧。 leave 的作用是将 esp 恢复到函数调用前的位置，并弹出保存的 ebp。如果 ebp 被覆盖为指向某个特殊地址（例如缓冲区内的地址），在函数返回时可能导致错误的栈指针位置。\n2. ret 指令 ret 指令从栈顶弹出一个地址并跳转到该地址：\npop eip 如果返回地址被覆盖为 bar 函数的地址，执行流将跳转到 bar，允许攻击者执行任意代码。本质上，ret 会将一个地址弹出到指令指针 (eip) 并跳转到该地址继续执行。\n攻击步骤 当执行命令 perl -e 'system \u0026quot;./obo\u0026quot;, \u0026quot;\\x38\\x84\\x04\\x08\u0026quot;x256' 时，程序会将这些重复的字节作为输入传递给 ./obo。 在 foo 函数返回时，执行了 leave 和 ret 指令，由于返回地址被覆盖，程序跳转到 bar 函数，打印出成功的消息多次。 进一步分析：确定有效的覆盖位置 为了成功执行攻击，关键在于精确确定需要覆盖哪些字节，以有效地操控控制流。在这个例子中，溢出发生在执行 buf[sizeof(buf)] = '\\0' 时，导致保存的帧指针 (ebp) 的最低有效字节被设置为 0。因此，需要调整 ebp 的值，确保其指向缓冲区区域，从而使执行流程按预期进行，最终跳转到 bar 函数。\n基于进一步的分析和测试，得出以下见解：\n要准确确定覆盖位置，ebp 的值至关重要。然而，获得这个值是有挑战的，因为：\nGDB 调试会影响地址布局。 输入参数的长度会影响地址布局。 在 GDB 调试下，foo 函数内的布局如下：\n执行 buf[sizeof(buf)] = '\\0'; 后，ebp 被修改，使得返回地址实际上取的是 ebp + 1 处的值，即地址 0xbfffed00 + 1，也就是 0xbfffed04。\n对应的偏移位置在 buf 的第 255 个位置，这意味着可以通过只在该特定位置填入返回地址来构造攻击。在 GDB 中使用以下命令进行验证：\nr $(perl -e \u0026#39;print \u0026#34;\\x01\\x01\\x01\\x01\u0026#34;x254 . \u0026#34;\\x38\\x84\\x04\\x08\u0026#34;x1 . \u0026#34;\\x01\\x01\\x01\\x01\u0026#34;x1\u0026#39;) 经过验证，这在 GDB 调试下是有效的，但需要注意以下细节：\n输入参数的长度必须始终为 256 字节，否则 ebp 的值会发生变化，因为输入参数会占用栈空间，从而影响帧的起始位置，进而影响 ebp 的值。 填充必须使用非零值，如 0x01，因为如果遇到 0 值，strncpy 会提前终止。 直接执行程序时（即不使用 GDB），内存布局不同，导致偏移位置也不同。通过实验，发现偏移位置在第 235 个位置。对应的攻击命令是：\n./obo $(perl -e \u0026#39;print \u0026#34;\\x01\\x01\\x01\\x01\u0026#34;x234 . \u0026#34;\\x38\\x84\\x04\\x08\u0026#34;x1 . \u0026#34;\\x01\\x01\\x01\\x01\u0026#34;x21\u0026#39;) 这样就实现了找到准确覆盖位置并成功执行攻击的效果。\n","date":"2024-10-15T14:18:44Z","permalink":"https://nansenli.com/zh-cn/post/2024/10/oboattact-md/","title":"Off-by-One 溢出攻击分析"},{"content":"ChatGPT生成的公式使用了以下格式：\n\\[ 公式内容 \\] 而Obsidian中的公式渲染使用的是以下格式：\n$$ 公式内容 $$ 当我们将ChatGPT的公式复制到Obsidian中时，这种差异会导致无法正确渲染。\n解决方案 我们可以创建一个Obsidian脚本，在粘贴操作时自动替换公式的格式。\n1. 创建脚本 可以使用Obsidian中的插件来解决这个问题。\n在你的库中，在template目录下创建一个文件fixlatex.js，并输入以下内容：\nmodule.exports = async (params) =\u0026gt; { const { quickAddApi } = params; // 获取剪贴板内容 const clipboardContent = await quickAddApi.utility.getClipboard(); // 检查是否成功获取内容 if (!clipboardContent) { new Notice(\u0026#34;剪贴板为空或无法访问。\u0026#34;); return; } const modifiedContent = clipboardContent .replace(/\\\\\\[|\\\\\\]/g, \u0026#39;$$$$\u0026#39;) // 转换 \\[ \\] 为 $$ $$ .replace(/\\\\\\(\\s*|\\s*\\\\\\)/g, \u0026#39;$$\u0026#39;); // 转换 \\( \\) 为 $ // 将修改后的内容写回剪贴板 await navigator.clipboard.writeText(modifiedContent); new Notice(\u0026#34;剪贴板内容已处理并修改！\u0026#34;); }; 2. 在QuickAdd中设置脚本 安装QuickAdd插件，并创建一个Macro，按如下图中的配置进行设置并保存。Macro的第一步是执行我们刚刚创建的用户脚本fixlatex.js，第二步是等待100毫秒，第三步是执行粘贴操作。\n3. 在Commander中设置侧边快捷键 安装Commander插件，并将刚刚创建的QuickAdd操作设置为侧边栏的快捷键。你也可以跳过这一步，直接使用Obsidian命令执行这个操作。\n4. 验证效果 现在，在ChatGPT的网页中（目前在APP中点击复制按钮似乎有点问题），点击复制按钮后，在Obsidian中点击侧边栏快捷键，或者手动执行QuickAdd命令，就可以将ChatGPT中的内容复制到Obsidian中，并自动转换Latex格式。\n","date":"2024-10-14T15:24:27Z","permalink":"https://nansenli.com/zh-cn/post/2024/10/obsidian-latex-fix/","title":"将ChatGPT公式格式转换为Obsidian兼容格式"},{"content":"关于我 本文书写于 2024年10月11日，都柏林，爱尔兰。\n自我介绍 大家好，我叫李楠森，曾用名李楠。我来自中国，是一名热爱科技的工程师。我拥有机械电子的本科学位和两个计算机科学的硕士学位。我曾在中国一家大型互联网公司担任过 Go 语言工程师，目前正在都柏林一所大学攻读硕士学位。之后计划在爱尔兰发展。\n我对前端和后端开发、系统架构、算法、游戏开发，以及生成式 AI 有着浓厚的兴趣。我一直致力于提高自己的编程能力，也喜欢尝试新技术，保持对行业发展的敏感度。\n除了软件开发设计外，我也有其他各种各样的背景。我曾经参加过嵌入式系统设计、机械软件设计，曾经焊接过电路板，设计过电子元器件，包括放大器等检测电路和模拟摄像头或数字摄像头等功能元件，了解控制系统和控制过程，例如PID。绘制工程图，例如汽车汽缸等模型，使用AutoCAD建模等。参与嵌入式防火墙设计。我还拥有带领不同队伍参加编程或者电子设计的竞赛经历。\n如果你对技术或者生活方式有相同的兴趣，欢迎联系我，我们可以一起讨论和交流。\n","date":"2024-10-11T20:55:02Z","permalink":"https://nansenli.com/zh-cn/post/2024/10/aboutme/","title":"关于我"},{"content":"在所有机器上运行 机器均为debian 首先安装docker\nsudo apt-get update sudo apt-get install -y \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg \\ lsb-release curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg echo \\ \u0026#34;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian \\ $(lsb_release -cs) stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null sudo apt-get update sudo apt-get install -y docker-ce docker-ce-cli containerd.io sudo mkdir /etc/docker cat \u0026lt;\u0026lt;EOF | sudo tee /etc/docker/daemon.json { \u0026#34;exec-opts\u0026#34;: [\u0026#34;native.cgroupdriver=systemd\u0026#34;], \u0026#34;log-driver\u0026#34;: \u0026#34;json-file\u0026#34;, \u0026#34;log-opts\u0026#34;: { \u0026#34;max-size\u0026#34;: \u0026#34;100m\u0026#34; }, \u0026#34;storage-driver\u0026#34;: \u0026#34;overlay2\u0026#34; } EOF sudo usermod -aG docker ${USER} sudo systemctl restart docker sudo su ${USER} 此时运行 docker ps -a 无异常，docker安装成功\n接下来安装k8s组件\ncat \u0026lt;\u0026lt;EOF | sudo tee /etc/modules-load.d/k8s.conf br_netfilter EOF cat \u0026lt;\u0026lt;EOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sudo sysctl --system sudo apt-get update sudo apt-get install -y apt-transport-https ca-certificates curl sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg echo \u0026#34;deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main\u0026#34; | sudo tee /etc/apt/sources.list.d/kubernetes.list sudo apt-get update sudo apt-get install -y kubelet kubeadm kubectl sudo apt-mark hold kubelet kubeadm kubectl 在主节点上运行 接下来初始化控制平面\nsudo kubeadm init --apiserver-advertise-address masterip --control-plane-endpoint masterdns --pod-network-cidr 10.244.0.0/16 将输出内容的最后部分保存备用，包括如何配置.kube以及节点的加入命令，并按照提示配置.kube文件\n然后初始化网络插件\nwget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml kubectl apply -f kube-flannel.yml 检查pods运行状况是否正常\nkubectl get pods -A 在另外一个节点安装k8s组件，然后运行加入节点join命令，该命令在kubeadm init结束时会打印出来\n之后检查pods运行状态是否正常\n下载dashboad\nwget https://raw.githubusercontent.com/kubernetes/dashboard/v2.2.0/aio/deploy/recommended.yaml -o dashboard.yaml 编辑dashboard.yaml 在第一处8843下面添加nodePort: 31001，并在上方修改type:NodePort，找到namespace=处在下面添加一行 - \u0026ndash;token-ttl=43200 具体可以参见 https://www.huaweicloud.com/articles/dc1dcb0c48cc785a9193c9ce709c8b35.html\n创建管理员角色\nkubectl create -f https://raw.githubusercontent.com/rootsongjc/kubernetes-handbook/master/manifests/dashboard-1.7.1/admin-role.yaml 应用pod\nkubectl apply -f dashboard.yaml 检查端口\nsudo lsof -i:31001 获得token\nkubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-token | awk \u0026#39;{print $1}\u0026#39;) 访问 https://masterip:31001 并在chrome输入 thisisunsafe，然后输入token\n","date":"2021-06-20T12:21:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/k8s/k8s%E7%BB%8F%E5%85%B8%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/","title":"K8S经典安装流程"},{"content":"亲测可用\n新建文件docker-compose.yml\nversion: \u0026#39;2\u0026#39; services: zoo: image: wurstmeister/zookeeper restart: unless-stopped hostname: zoo ports: - \u0026#34;2181:2181\u0026#34; container_name: zookeeper kafka: image: wurstmeister/kafka ports: - \u0026#34;9092:9092\u0026#34; environment: KAFKA_ADVERTISED_HOST_NAME: 9.134.5.240 ## 修改:宿主机IP KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://9.134.5.240:19092 ## 修改:宿主机IP KAFKA_ZOOKEEPER_CONNECT: \u0026#34;zoo:2181\u0026#34; KAFKA_ADVERTISED_PORT: 9092 KAFKA_BROKER_ID: 1 KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1 depends_on: - zoo container_name: kafka kafka-manager: image: sheepkiller/kafka-manager ## 镜像：开源的web管理kafka集群的界面 environment: ZK_HOSTS: zoo:2181 ## 修改:宿主机IP ports: - \u0026#34;9000:9000\u0026#34; ## 暴露端口 运行docker-compose up -d即可\n","date":"2020-06-23T07:31:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/docker/docker%E6%90%AD%E5%BB%BAkafka%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83/","title":"Docker搭建kafka测试环境"},{"content":"前言 很急，暂时不写了\n核心点 不管是服务器还是客户端都有 emit 和 on 这两个函数，可以说 socket.io 的核心就是这两个函数了，通过 emit 和 on 可以轻松地实现服务器与客户端之间的双向通信。\nemit ：用来发射一个事件或者说触发一个事件，第一个参数为事件名，第二个参数为要发送的数据，第三个参数为回调函数（一般省略，如需对方接受到信息后立即得到确认时，则需要用到回调函数）。 on ：用来监听一个 emit 发射的事件，第一个参数为要监听的事件名，第二个参数为一个匿名函数用来接收对方发来的数据，该匿名函数的第一个参数为接收的数据，若有第二个参数，则为要返回的函数。 socket.io 提供了三种默认的事件（客户端和服务器都有）：connect 、message 、disconnect 。当与对方建立连接后自动触发 connect 事件，当收到对方发来的数据后触发 message 事件（通常为 socket.send() 触发），当对方关闭连接后触发 disconnect 事件。\n在服务器端区分以下三种情况：\nsocket.emit() ：向建立该连接的客户端广播 socket.broadcast.emit() ：向除去建立该连接的客户端的所有客户端广播 io.sockets.emit() ：向所有客户端广播，等同于上面两个的和\n","date":"2018-12-11T10:50:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E7%BD%91%E7%BB%9C/socket-io%E5%AD%A6%E4%B9%A0/","title":"socketio学习"},{"content":"官方参考 https://golang.org/ref/spec#Types\n其中类型有：\nMethod sets 方法集合 Boolean types 布尔类型 Numeric types 数字类型 String types 字符串类型 Array types 数组类型 Slice types 切片类型 Struct types 结构体类型 Pointer types 指针类型 Function types 函数类型 Interface types 接口类型 Map types 字典类型 Channel types 通道类型\nMethod sets 方法集合 A type may have a method set associated with it. The method set of an interface type is its interface. The method set of any other type T consists of all methods declared with receiver type T. The method set of the corresponding pointer type *T is the set of all methods declared with receiver *T or T (that is, it also contains the method set of T). Further rules apply to structs containing embedded fields, as described in the section on struct types. Any other type has an empty method set. In a method set, each method must have a unique non-blankmethod name.\nThe method set of a type determines the interfaces that the type implements and the methods that can be calledusing a receiver of that type.\n接口类型Interface types的接口就是方法集合。若一组方法的接受参数都为参数T，把这组方法叫T类型的方法集合。T指针的对应方法集合，其接受参数为T或者*T。这意味着T指针的方法集合包含T类型的方法集合。对结构体来说，该规则同样适用。任何类型都有一个空的方法集合。在方法集合中，每个方法都有一个非空的方法名称。\n类型的方法集合确定了该类型实现的接口，以及可以可以被该类型的接收器调用的方法。\nBoolean types 布尔类型 A boolean type represents the set of Boolean truth values denoted by the predeclared constants true and false. The predeclared boolean type is bool; it is a defined type.\n布尔类型定义了布尔变量，可被赋值为常量true和false。该类型是已定义类型。例如可以使用char类型来定义。\nNumeric types 数字类型 A numeric type represents sets of integer or floating-point values. The predeclared architecture-independent numeric types are:\nuint8 the set of all unsigned 8-bit integers (0 to 255) uint16 the set of all unsigned 16-bit integers (0 to 65535) uint32 the set of all unsigned 32-bit integers (0 to 4294967295) uint64 the set of all unsigned 64-bit integers (0 to 18446744073709551615) int8 the set of all signed 8-bit integers (-128 to 127) int16 the set of all signed 16-bit integers (-32768 to 32767) int32 the set of all signed 32-bit integers (-2147483648 to 2147483647) int64 the set of all signed 64-bit integers (-9223372036854775808 to 9223372036854775807) float32 the set of all IEEE-754 32-bit floating-point numbers float64 the set of all IEEE-754 64-bit floating-point numbers complex64 the set of all complex numbers with float32 real and imaginary parts complex128 the set of all complex numbers with float64 real and imaginary parts byte alias for uint8 rune alias for int32 The value of an n-bit integer is n bits wide and represented using two\u0026rsquo;s complement arithmetic.\nuint either 32 or 64 bits int same size as uint uintptr an unsigned integer large enough to store the uninterpreted bits of a pointer value There is also a set of predeclared numeric types with implementation-specific sizes:\nTo avoid portability issues all numeric types are defined types and thus distinct except byte, which is an alias for uint8, and rune, which is an alias for int32. Conversions are required when different numeric types are mixed in an expression or assignment. For instance, int32 and int are not the same type even though they may have the same size on a particular architecture.\n数字类型包括整型和浮点。内置声明包括uint8 uint16 uint32 uint64以及int8 int16 int32 int64 float32 float64 complex64 complex128 byte rune。\nN位整数是N位宽度，使用二进制补码计算。\n与平台无关的声明包块uint int uintptr。\n除了byte和rune外，其他数字类型为已定义类型，而byte是uint8的别名，rune是int32的别名。在数字类型之间的转换需要进行显示转换。\nString types 字符串类型 A string type represents the set of string values. A string value is a (possibly empty) sequence of bytes. Strings are immutable: once created, it is impossible to change the contents of a string. The predeclared string type is string; it is a defined type.\nThe length of a string s (its size in bytes) can be discovered using the built-in function len. The length is a compile-time constant if the string is a constant. A string\u0026rsquo;s bytes can be accessed by integer indices 0 through len(s)-1. It is illegal to take the address of such an element; if s[i] is the i\u0026lsquo;th byte of a string, \u0026amp;s[i] is invalid.\n字符串类型可以表示所有字符串的值。一个字符串的值是一系列空或不空的字节序列。他的值不能被修改。字符串被创建后就不能修改内容。我们使用string来声明一个string类型。string类型是已定义类型。\n一个字符串的长度（其包含多少个字节）可以使用内建函数len来计算。在编译器可以计算一个常量string的长度。string类型的变量可以访问其位置0到位置len-1的值。对这些位置的元素，获取其地址是非法的。使用s[i]表示s字符串第i个位置的元素，而\u0026amp;s[i]是非法的。\nArray types 数组类型 An array is a numbered sequence of elements of a single type, called the element type. The number of elements is called the length and is never negative.\nArrayType = \u0026#34;[\u0026#34; ArrayLength \u0026#34;]\u0026#34; ElementType . ArrayLength = Expression . ElementType = Type . The length is part of the array\u0026rsquo;s type; it must evaluate to a non-negative constant representable by a value of type int. The length of array a can be discovered using the built-in function len. The elements can be addressed by integer indices 0 through len(a)-1. Array types are always one-dimensional but may be composed to form multi-dimensional types.\n[32]byte [2*N] struct { x, y int32 } [1000]*float64 [3][5]int [2][2][2]float64 // same as [2]([2]([2]float64)) 数组类型是多个同类型的元素构成的可数序列。元素的数量是数组的长度。长度不能为负数。\n数组的长度也是数组的一部分。他的值非负，可以用int表示。数组的长度使用len求出。数组的所有元素可以从位置0到len-1进行访问。数组类型永远是一维的，进行组合可以表示多位类型。\nSlice types 切片 A slice is a descriptor for a contiguous segment of an underlying array and provides access to a numbered sequence of elements from that array. A slice type denotes the set of all slices of arrays of its element type. The value of an uninitialized slice is nil.\nSliceType = \u0026#34;[\u0026#34; \u0026#34;]\u0026#34; ElementType . Like arrays, slices are indexable and have a length. The length of a slice s can be discovered by the built-in function len; unlike with arrays it may change during execution. The elements can be addressed by integer indices 0 through len(s)-1. The slice index of a given element may be less than the index of the same element in the underlying array.\nA slice, once initialized, is always associated with an underlying array that holds its elements. A slice therefore shares storage with its array and with other slices of the same array; by contrast, distinct arrays always represent distinct storage.\nThe array underlying a slice may extend past the end of the slice. The capacity is a measure of that extent: it is the sum of the length of the slice and the length of the array beyond the slice; a slice of length up to that capacity can be created by slicing a new one from the original slice. The capacity of a slice a can be discovered using the built-in function cap(a).\nA new, initialized slice value for a given element type T is made using the built-in function make, which takes a slice type and parameters specifying the length and optionally the capacity. A slice created with make always allocates a new, hidden array to which the returned slice value refers. That is, executing\nmake([]T, length, capacity) produces the same slice as allocating an array and slicing it, so these two expressions are equivalent:\nmake([]int, 50, 100) new([100]int)[0:50] Like arrays, slices are always one-dimensional but may be composed to construct higher-dimensional objects. With arrays of arrays, the inner arrays are, by construction, always the same length; however with slices of slices (or arrays of slices), the inner lengths may vary dynamically. Moreover, the inner slices must be initialized individually.\n切片表示底层数组的连续段，提供对该段位置的元素访问。切片的类型表示其元素的类型。未初始化的切片的值为nil。\n与数组相同，切片的长度可以使用len来求出。长度通常小于原来的数组。\n切片自初始化之后与低层数组共享存储空间，多个切片可以共享同一个存储空间。数组通常代表了不同的存储空间。\n切片的低层数组长度可以超过切片的末端，使用cap可以计算切片的容量，容量是数组超出切片的值加上切片本身的值。可以通过对切片重新切分得到新的超过原长度的切片。\n使用内建函数make创建指定类型的切片。make接受切片类型和切片的长度，容量作为可选参数。使用make创建出来的切片总是被分配一个切片所引用的隐藏数组，这意味着通过make创建长度50容量100的切片make([]int, 50, 100)与通过new创建一个长度100的数组并对其切片50的长度new([100]int)[0:50]两者的结果相同。\n与数组相同，切片的长度是一维的，但是可以表示更高的维度。对于数组来说，内部的数组由于构造的长度相同，是不能改变的。复合切片的内部长度会变成动态的，复合切片的内部也需要单独初始化。\nStruct types 结构体 A struct is a sequence of named elements, called fields, each of which has a name and a type. Field names may be specified explicitly (IdentifierList) or implicitly (EmbeddedField). Within a struct, non-blank field names must be unique.\nStructType = \u0026#34;struct\u0026#34; \u0026#34;{\u0026#34; { FieldDecl \u0026#34;;\u0026#34; } \u0026#34;}\u0026#34; . FieldDecl = (IdentifierList Type | EmbeddedField) [ Tag ] . EmbeddedField = [ \u0026#34;*\u0026#34; ] TypeName . Tag = string_lit . // An empty struct. struct {} // A struct with 6 fields. struct { x, y int u float32 _ float32 // padding A *[]int F func() } A field declared with a type but no explicit field name is called an embedded field. An embedded field must be specified as a type name T or as a pointer to a non-interface type name *T, and T itself may not be a pointer type. The unqualified type name acts as the field name.\n// A struct with four embedded fields of types T1, *T2, P.T3 and *P.T4 struct { T1 // field name is T1 *T2 // field name is T2 P.T3 // field name is T3 *P.T4 // field name is T4 x, y int // field names are x and y } The following declaration is illegal because field names must be unique in a struct type:\nstruct { T // conflicts with embedded field *T and *P.T *T // conflicts with embedded field T and *P.T *P.T // conflicts with embedded field T and *T } A field or method f of an embedded field in a struct x is called promoted if x.f is a legal selector that denotes that field or method f.\nPromoted fields act like ordinary fields of a struct except that they cannot be used as field names in composite literals of the struct.\nGiven a struct type S and a defined type T, promoted methods are included in the method set of the struct as follows:\nIf S contains an embedded field T, the method sets of S and *S both include promoted methods with receiver T. The method set of *S also includes promoted methods with receiver *T. If S contains an embedded field *T, the method sets of S and *S both include promoted methods with receiver T or*T. A field declaration may be followed by an optional string literal tag, which becomes an attribute for all the fields in the corresponding field declaration. An empty tag string is equivalent to an absent tag. The tags are made visible through a reflection interface and take part in type identity for structs but are otherwise ignored.\nstruct { x, y float64 \u0026#34;\u0026#34; // an empty tag string is like an absent tag name string \u0026#34;any string is permitted as a tag\u0026#34; _ [4]byte \u0026#34;ceci n\u0026#39;est pas un champ de structure\u0026#34; } // A struct corresponding to a TimeStamp protocol buffer. // The tag strings define the protocol buffer field numbers; // they follow the convention outlined by the reflect package. struct { microsec uint64 `protobuf:\u0026#34;1\u0026#34;` serverIP6 uint64 `protobuf:\u0026#34;2\u0026#34;` } 结构体是一系列字段的集合，每个字段有自己的名称和类型。类型可以隐式指定。在结构中非空字段名称必须是唯一的。\n结构体可以为空。也可以包含int float等类型。如果使用_表示padding占位。\n如果结构体的字段只有类型而没有名字，我们表示这个字段是嵌入字段。嵌入字段的类型必须是类型T，或者是一个非接口类型的指针。\n结构体x中的嵌入字段的字段或方法叫做结构体x的提升。对结构体x，调用其不存在的成员或者方法，会使用嵌入字段的字段或方法来代替。\n被提升的字段表现的就像原始字段，除了他们不能用在特殊场合。\n给定结构体类型和定义的类型T，提升方法包含在结构体的方法集中。\n如果S包含嵌入字段T，使用T为接受着的话，提升方法被包含在S和S的方法集合。使用T为接受者的话，提升方法被包含在*S的方法集合。\n结构体的字段后面，可以跟上一个字符串。这个字符串可以通过反射的方式获取。可以用于特殊的场合。例如json转换，protobuf转换。\nPointer types 指针类型 A pointer type denotes the set of all pointers to variables of a given type, called the base type of the pointer. The value of an uninitialized pointer is nil.\nPointerType = \u0026#34;*\u0026#34; BaseType . BaseType = Type . *Point *[4]int 一个指针类型表示指向给定类型所有变量的指针的类型，是指针的基础类型。指针在未被初始化的时候使用nil作为初值。\nFunction types 函数类型 A function type denotes the set of all functions with the same parameter and result types. The value of an uninitialized variable of function type is nil.\nFunctionType = \u0026#34;func\u0026#34; Signature . Signature = Parameters [ Result ] . Result = Parameters | Type . Parameters = \u0026#34;(\u0026#34; [ ParameterList [ \u0026#34;,\u0026#34; ] ] \u0026#34;)\u0026#34; . ParameterList = ParameterDecl { \u0026#34;,\u0026#34; ParameterDecl } . ParameterDecl = [ IdentifierList ] [ \u0026#34;...\u0026#34; ] Type . Within a list of parameters or results, the names (IdentifierList) must either all be present or all be absent. If present, each name stands for one item (parameter or result) of the specified type and all non-blank names in the signature must be unique. If absent, each type stands for one item of that type. Parameter and result lists are always parenthesized except that if there is exactly one unnamed result it may be written as an unparenthesized type.\nThe final incoming parameter in a function signature may have a type prefixed with \u0026hellip;. A function with such a parameter is called variadic and may be invoked with zero or more arguments for that parameter.\nfunc() func(x int) int func(a, _ int, z float32) bool func(a, b int, z float32) (bool) func(prefix string, values ...int) func(a, b int, z float64, opt ...interface{}) (success bool) func(int, int, float64) (float64, *[]int) func(n int) func(p *T) 一个函数类型表示所有拥有相同参数和返回值的函数的类型。未被初始化的函数类型变量的值是nil。\n在参数列表或者返回列表中，名称必须都被显示的声明出来，或者都没有声明，只写类型。如果写了名称，每个名称都有类型和非空的名字，而名字必须唯一。如果没有声明名字，那就只写类型。参数和返回列表需要使用括号包裹。返回列表在只有一个类型且没有名字时可以不加括号。\n最后传入的参数的前面可以使用可变参数，前缀可以使用三个点。调用时，需要传入0个或以上的参数。\nInterface types 接口类型 An interface type specifies a method set called its interface. A variable of interface type can store a value of any type with a method set that is any superset of the interface. Such a type is said to implement the interface. The value of an uninitialized variable of interface type is nil.\nInterfaceType = \u0026#34;interface\u0026#34; \u0026#34;{\u0026#34; { MethodSpec \u0026#34;;\u0026#34; } \u0026#34;}\u0026#34; . MethodSpec = MethodName Signature | InterfaceTypeName . MethodName = identifier . InterfaceTypeName = TypeName . As with all method sets, in an interface type, each method must have a unique non-blank name.\n// A simple File interface interface { Read(b Buffer) bool Write(b Buffer) bool Close() } More than one type may implement an interface. For instance, if two types S1 and S2 have the method set\nfunc (p T) Read(b Buffer) bool { return … } func (p T) Write(b Buffer) bool { return … } func (p T) Close() { … } (where T stands for either S1 or S2) then the File interface is implemented by both S1 and S2, regardless of what other methods S1 and S2 may have or share.\nA type implements any interface comprising any subset of its methods and may therefore implement several distinct interfaces. For instance, all types implement the empty interface:\ninterface{} Similarly, consider this interface specification, which appears within a type declaration to define an interface called Locker:\ntype Locker interface { Lock() Unlock() } If S1 and S2 also implement\nfunc (p T) Lock() { … } func (p T) Unlock() { … } they implement the Locker interface as well as the File interface.\nAn interface T may use a (possibly qualified) interface type name E in place of a method specification. This is called embedding interface E in T; it adds all (exported and non-exported) methods of E to the interface T.\ntype ReadWriter interface { Read(b Buffer) bool Write(b Buffer) bool } type File interface { ReadWriter // same as adding the methods of ReadWriter Locker // same as adding the methods of Locker Close() } type LockedFile interface { Locker File // illegal: Lock, Unlock not unique Lock() // illegal: Lock not unique } An interface type T may not embed itself or any interface type that embeds T, recursively.\n// illegal: Bad cannot embed itself type Bad interface { Bad } // illegal: Bad1 cannot embed itself using Bad2 type Bad1 interface { Bad2 } type Bad2 interface { Bad1 } 接口类型表示一个方法集合，该方法集合叫做该类型的接口。接口类型可以存储一个变量，以及该变量的方法集合的任何超集。传入的类型与对应的接口叫做该类型的实现。未被初始化的接口类型变量的值是nil。\n和方法集合一样，接口类型的内部，每个方法必须油唯一非空名字。\n如果S1、S2两种类型的方法集和都包含了同样的接口实现，不管方法集合其他的区别是什么，S1和S2都被认为是接口的实现。\n如果一个类型实现了一个接口，这个接口的子集又是其他接口的实现，那么这个类型也会实现那些接口。举个例子，所有的类型都实现了空接口。\n接口中也可以内嵌其他接口，但是其内嵌的接口的方法的名字不能冲突。\nMap types 字典类型 A map is an unordered group of elements of one type, called the element type, indexed by a set of unique keys of another type, called the key type. The value of an uninitialized map is nil.\nMapType = \u0026ldquo;map\u0026rdquo; \u0026ldquo;[\u0026rdquo; KeyType \u0026ldquo;]\u0026rdquo; ElementType . KeyType = Type . The comparison operators == and != must be fully defined for operands of the key type; thus the key type must not be a function, map, or slice. If the key type is an interface type, these comparison operators must be defined for the dynamic key values; failure will cause a run-time panic.\nmap[string]int map[*T]struct{ x, y float64 } map[string]interface{} The number of map elements is called its length. For a map m, it can be discovered using the built-in function len and may change during execution. Elements may be added during execution using assignments and retrieved with index expressions; they may be removed with the delete built-in function.\nA new, empty map value is made using the built-in function make, which takes the map type and an optional capacity hint as arguments:\nmake(map[string]int) make(map[string]int, 100) The initial capacity does not bound its size: maps grow to accommodate the number of items stored in them, with the exception of nil maps. A nil map is equivalent to an empty map except that no elements may be added.\n字典类型的内部是无序元素排序的类型，内部的类型叫元素的类型，使用唯一键值进行索引，键值也有另外一种类型，叫键类型。未被初始化的字典类型的值是nil。\n键值类型必须完全定义了==运算和！=运算。因此函数、字典、切片都是不允许作为键值的。如果键值是一个接口，比较操作必须被定义为可以接受一个动态的键值。对键值的相关操作失败时会引发程序运行时惊慌。\n字典元素的数量称为字典的长度。可以通过len函数检查，其值在运行期间可能被更改。元素可能通过指派操作添加，可以通过下标取出，可以通过delete函数移除。\n一个空的map的值可以通过内建函数make来创建，make的第一个参数是map的类型，第二个参数是容量。\n字典的容量不限制大小，字典的容量会增长以容纳其中项目的数量。但nil字典不是这样的，nil字典基本上和空字典是一样的，除了不能添加任何元素。\nChannel types 通道类型 A channel provides a mechanism for concurrently executing functions to communicate by sending and receiving values of a specified element type. The value of an uninitialized channel is nil.\nChannelType = ( \u0026ldquo;chan\u0026rdquo; | \u0026ldquo;chan\u0026rdquo; \u0026ldquo;\u0026lt;-\u0026rdquo; | \u0026ldquo;\u0026lt;-\u0026rdquo; \u0026ldquo;chan\u0026rdquo; ) ElementType . The optional \u0026lt;- operator specifies the channel direction, send or receive. If no direction is given, the channel is bidirectional. A channel may be constrained only to send or only to receive by conversion or assignment.\nchan T // can be used to send and receive values of type T chan\u0026lt;- float64 // can only be used to send float64s \u0026lt;-chan int // can only be used to receive ints The \u0026lt;- operator associates with the leftmost chan possible:\nchan\u0026lt;- chan int // same as chan\u0026lt;- (chan int) chan\u0026lt;- \u0026lt;-chan int // same as chan\u0026lt;- (\u0026lt;-chan int) \u0026lt;-chan \u0026lt;-chan int // same as \u0026lt;-chan (\u0026lt;-chan int) chan (\u0026lt;-chan int) A new, initialized channel value can be made using the built-in function make, which takes the channel type and an optional capacity as arguments:\nmake(chan int, 100) The capacity, in number of elements, sets the size of the buffer in the channel. If the capacity is zero or absent, the channel is unbuffered and communication succeeds only when both a sender and receiver are ready. Otherwise, the channel is buffered and communication succeeds without blocking if the buffer is not full (sends) or not empty (receives). A nil channel is never ready for communication.\nA channel may be closed with the built-in function close. The multi-valued assignment form of the receive operator reports whether a received value was sent before the channel was closed.\nA single channel may be used in send statements, receive operations, and calls to the built-in functions cap and len by any number of goroutines without further synchronization. Channels act as first-in-first-out queues. For example, if one goroutine sends values on a channel and a second goroutine receives them, the values are received in the order sent.\n通道提供了并行执行程序之间的通信方式，该方式使用发送和接受特定类型的值来实现。未被初始化的通道的值是nil。\n标记\u0026lt;-用来指示通道的方向，例如是接受还是发送。如果不指定方向，则通道从是双向的。\n通道的\u0026lt;-标记，转换或指派通道的方向，成为发送或接收。\n通道所传递的内容也可以是通道。\n使用make也可以创建初始化的通道，make的第二个参数可以设置通道的容量。\n通道的容量是通道中元素的缓存数量。如果容量是0或者不设置，通道是没有缓存的，只有接收者和发送者都准备好时才进行通信。否则，通道在缓存没有满时，是不阻塞的。如果通道的值是0，则永远无法通信。\n通道使用系统调用close来关闭。使用多值接受的第二个参数来判断通道是否关闭。\n单向通道用于发送表达式，接收操作。cap与len也可以调用，并且无须担心多个同步的协程同时运行。通道是先入先出的，如果第一个协成放入了一个值，第二个协成取出的一定是先放入的值。\n","date":"2018-11-14T08:14:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/go/go%E7%B1%BB%E5%9E%8B%E5%AE%98%E6%96%B9%E5%8F%82%E8%80%83-%E4%B8%AD%E8%8B%B1%E6%96%87%E5%AF%B9%E7%85%A7/","title":"Go类型官方参考 中英文对照"},{"content":"前言 本人寝室有两个移动宽带，使用光纤入户方式，其中一个是20M，另一个是30M，使用pppoe方式拨号上网。希望能够将两个带宽进行合并。\n方案一 在京东上搜索多wan口路由，价格比较贵。pass。\n方案二 将手上的小米路由器mini进行改造。刷入OpenWrt。\n刷入OpenWrt 不是本篇得重点。但是有一点，OpenWrt的固件可以在官方网站查询到并下载，其源也齐全并新潮，不需要刷入旧的Pandorabox等源不可靠得固件。路由需要刷入开发版固件和ssh固件，然后通过命令行刷入OpenWrt固件。不需要刷入breed的u-boot，这种行为太危险了，还会丢失SN。\n第一次拨号，设置国内源 首先开启路由器，插上网线，访问192.168.1.1，在页面中设置root密码。\n在system software页面中，点击configuration，将downloads.openwrt.org进行替换，换成openwrt.proxy.ustclug.org，并提交。在network - interface页面编辑 wan配置，更改协议并配置pppoe上网。\n使用ssh连接路由器，在命令行输入opkg update。注意有没有成功。 然后输入opkg install kmod-macvlan mwan3 luci-app-mwan3。没成功多试几次。\n设置虚拟网卡 在interface中查看wan的interface绑定的vlan，是eth0.2。在终端输入 ip link add link eth0.2 name veth0 type macvlan，并输入ifconfig veth0 up。\n绑定网卡到接口 方便起见，修改WAN6作为我们的第二个接口，设置第二个账号得pppoe的上网账号，然后修改其physical setting为veth0。\n如果此时两个账户无法同时拨号，说明不支持单线双拨。\n设置跃点数 在wan和wan6两个页面中设置use gateway metric，注意要不一样。例如一个10一个11.\n设置负载均衡 在load balance依次设置。\n重启服务 点击重启服务\n测试 参考 https://acris.me/2017/06/25/Load-balancing-multiple-PPPoE-on-LEDE/\n","date":"2018-11-10T18:08:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E7%BD%91%E7%BB%9C/%E5%90%88%E6%B3%95%E5%8D%95%E7%BA%BF%E5%8F%8C%E6%8B%A8%E6%8F%90%E9%AB%98%E5%AF%9D%E5%AE%A4%E8%B7%AF%E7%94%B1%E5%B8%A6%E5%AE%BD%E5%88%A9%E7%94%A8%E7%8E%87/","title":"合法单线双拨——提高寝室路由带宽利用率"},{"content":"Go的指针与值在作为接受者和参数时的表现不同 方法与指针重定向 比较前两个程序，你大概会注意到带指针参数的函数必须接受一个指针：\nvar v Vertex ScaleFunc(v, 5) // 编译错误！ ScaleFunc(\u0026amp;v, 5) // OK 而以指针为接收者的方法被调用时，接收者既能为值又能为指针：\nvar v Vertex v.Scale(5) // OK p := \u0026amp;v p.Scale(10) // OK 对于语句 v.Scale(5)，即便 v 是个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 Scale 方法有一个指针接收者，为方便起见，Go 会将语句 v.Scale(5) 解释为 (\u0026amp;v).Scale(5)。\n另外，Go会将指针的.运算自动解释为(*).\n","date":"2018-11-07T06:54:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/go/2018-09-20-go%E5%AD%A6%E4%B9%A0%E6%8B%BE%E8%B4%9D/","title":"2018-09-20 Go学习拾贝"},{"content":"示例 使用 AES-128-CBC加密算法 使用了pkcs5_encode padding 方式 pkcs7_encode也是兼容的\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;openssl/aes.h\u0026gt; #include \u0026lt;openssl/rand.h\u0026gt; // a simple hex-print routine. could be modified to print 16 bytes-per-line static void hex_print(const void* pv, size_t len) { const unsigned char * p = (const unsigned char*)pv; if (NULL == pv) printf(\u0026#34;NULL\u0026#34;); else { size_t i = 0; for (; i\u0026lt;len;++i) printf(\u0026#34;%02X \u0026#34;, *p++); } printf(\u0026#34;\\n\u0026#34;); } void pkcs7_encode(uint8_t *in, uint8_t *out, int inlen, int *outlen, const int enc) { // uint8_t padchr[16] = {0x10, 0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01}; if(inlen \u0026lt;=0) return; // 添加padding if (enc == AES_ENCRYPT) { *outlen = inlen + 16 - inlen % 16; for (int i = 0; i \u0026lt; *outlen; i++) { if (i \u0026lt; inlen) out[i] = in[i]; else out[i] = 16 - inlen % 16; } } // 删除padding else if (enc == AES_DECRYPT) { *outlen = inlen - (in[inlen-1]); for (int i=0; i\u0026lt; *outlen; i++) { out[i] = in[i]; } } } int main(int argc, char **argv) { int keylength; printf(\u0026#34;Give a key length [only 128 or 192 or 256!]:\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;keylength); /* generate a key with a given length */ unsigned char aes_key[16] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f}; size_t inputslength = 0; printf(\u0026#34;Give an input\u0026#39;s length:\\n\u0026#34;); scanf(\u0026#34;%lu\u0026#34;, \u0026amp;inputslength); /* generate input with a given length */ unsigned char * aes_input = malloc(inputslength); unsigned char * aes_out = malloc(inputslength); memset(aes_input, \u0026#39;X\u0026#39;, inputslength); /* init vector */ unsigned char iv_enc[AES_BLOCK_SIZE] = {0}, iv_dec[AES_BLOCK_SIZE]={0}; const size_t encslength = ((inputslength + AES_BLOCK_SIZE) / AES_BLOCK_SIZE) * AES_BLOCK_SIZE; unsigned char * enc_in = malloc(encslength); pkcs7_encode(aes_input, enc_in, inputslength, \u0026amp;encslength, AES_ENCRYPT); unsigned char * enc_out = malloc(encslength); AES_KEY enc_key; AES_set_encrypt_key(aes_key, keylength, \u0026amp;enc_key); AES_cbc_encrypt(enc_in, enc_out, encslength, \u0026amp;enc_key, iv_enc, AES_ENCRYPT); printf(\u0026#34;original:\\t\u0026#34;); hex_print(aes_input, inputslength); printf(\u0026#34;padding:\\t\u0026#34;); hex_print(enc_in, encslength); printf(\u0026#34;encrypt:\\t\u0026#34;); hex_print(enc_out, encslength); unsigned char * dec_out = malloc(encslength); AES_KEY dec_key; AES_set_decrypt_key(aes_key, keylength, \u0026amp;dec_key); AES_cbc_encrypt(enc_out, dec_out, encslength, \u0026amp;dec_key, iv_dec, AES_DECRYPT); pkcs7_encode(dec_out, aes_out, encslength, \u0026amp;inputslength, AES_DECRYPT); printf(\u0026#34;decrypt:\\t\u0026#34;); hex_print(dec_out, encslength); printf(\u0026#34;depadding:\\t\u0026#34;); hex_print(aes_out, inputslength); int8_t buff[100]; long bufflen; return 0; } ","date":"2018-11-02T06:49:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/c++/openssl-aes-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95-api%E4%BD%BF%E7%94%A8/","title":"openssl aes 加密算法 api使用"},{"content":"前言 本来是使用 Intel 的 i5-6500 CPU，在更换为 AMD 的 Ryzen 2700 后，频繁出现卡机现象。\n现象 在卡机时，观测到任务管理器的硬盘占用率为100%，同时写入与写出量为0。硬盘位光威 悍将 512 GB杂牌。在事件管理器中有大量编号为129的事件。\n怀疑硬件问题 在重复更换了SATA接口，重复拔插了电源，尝试无效，仍然卡机\n网上搜索相关问题 在网上搜索到，大部分都指向了问题的根源，是WIN10的AHCI驱动问题，以及SSD固件的问题。\n解决途径一 更换AHCI驱动 无效 为了更换AHCI驱动，尝试在AMD官网，在华硕官网下载了芯片组驱动，并手动在设备管理器中更换了驱动，使得显示为AMD SATA驱动。后又反复试过各种主板驱动，最终，测试无效，不能解决问题\n解决途径二 更换硬盘为raid格式 无效 为了更换raid格式，重新安装Windows，但是在安装过程中，Windows无法识别ssd。根据amd官方英文手册，以及官方raid驱动，手动载入raid驱动，仍然在Windows安装过程中无法看到ssd。重复多次无法看到。可能是因为只有一块硬盘，使用volume模式的raid不被支持吧。放弃该方式\n解决途径三 更改注册表，关闭MSI 无效 https://www.pconline.com.cn/win10/739/7395324.html\n大意就是在某些AHCI模式下使用StorAHCI.sys驱动时，可能导致个别SSD无法在“信息信号中断”（MSI）模式下完成正确的输入/输出操作，最终表现就是系统停滞，同时任务管理器中磁盘占用率显示为100%。当然解决的方法也简单，直接在regedit里关闭它（MSI Mode）就成。\n4. 点击Contana，输入“regedit”启动注册表编辑器，导航到“HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Enum\\PCI\\xxxxx \\Device Parameters\\Interrupt Management\\MessageSignaledInterruptProperties”（”xxxxx”是你刚刚记录的“设备实例路径”）；\n5. 最后更改右窗格中的“MSISupported”键值，由1改为0；\n经过测试无效\n解决途径四 更改电源设置 无效 PCIE-Express中的设置置为关闭，测试无效\n解决途径五 更改LPM 有用 http://www.sohu.com/a/204645459_493865\nhttps://answers.microsoft.com/en-us/windows/forum/windows_10-hardware-winpc/event-id-129-storahci-resetting-raidport0/7b30c512-6597-438b-80cb-22fb2f85d62e\n其内容如下：\n我们现在用的大多数SSD都支持一些省电的功能，DIPM/HIPM/Device Sleep。\n由主机 （Host）发出改变形态请求的我们叫做HIPM(Host-Initiated LPM, HIPM)，而直接由设备(Device)发出形态请求的叫(Device-Initiated LPM,DIPM)。请求什么，请求变慢，请求节能，请求Device Sleep。\n而HIPM，DIPM都离不开电脑LPM技术的支持。LPM，Link Power Management (LPM)，链接电源管理。LPM是SATA接口物理层上的一个功能，它能够将主机（Host）和存储设备（Device）的链接分成3种形态：Active形态，Partial形态和Slumber形态，目的是降低物理层总线传输速度，这样达到省电效果。\nLPM一般是默认打开的。\n那么打开这个LPM对于SSD好么？\n1. 主机发送HIPM形态改变指令，而SSD设备标准不同，不能很好的支持，出现兼容问题导致卡顿，或者掉盘；\n2. 主机发送HIPM形态改变指令太频繁，导致SSD设备不能及时反应，出现卡顿。\n3. LPM开启后造成SATA总线传输延迟增加，导致高速SSD的传输受到阻塞而卡顿；\n4. SSD内部的DIPM和主机请求的HIPM发生冲突导致卡顿。\n很多时候，SSD导致电脑出现卡顿，突然掉盘，都是LPM引起的。\nLPM是能够让SATA设备到达节能的效果。但是，也同样对SSD性能产生了影响。\n那么为了节能，你愿意付出损失SSD性能的代价吗？\nHDD的功耗大概在10-25W。也许LPM曾经仅仅是为HDD而来的。\nSSD启动功耗：0.1W1W（2W），最高功耗：510W，平均功耗：4~5W左右。\n我们的电源缺SSD这几W么？我们在乎这点电费么？好意思在乎么！\n既然SSD用不着LPM，这样损害SSD性能的节能功能，那么我们可不可以给它关掉呢？\n保存为“.reg”格式。\n点击运行。自动写入注册表，更改LPM电源设置。\n如果你的SSD出现严重卡顿，掉盘等现象，你可以试试这个方法。\nSSD卡顿、掉盘的主要原因还是，SSD太差劲。确实，在SSD价格不断上涨的今天，要想花较少的钱买到好的SSD是非常难的。\n经过测试，有效\n解决途径六 更改BIOS设置，开启sata热拔插功能 推荐 https://www.aiweibk.com/5795.html\n在主板BIOS设置中开启Hot Plug热插拔属性之后还会带来一个副作用，那就是固态硬盘的LPM节能将会随热插拔的开启而关闭，从而避免热插拔时数据丢失或重新连接时失去响应。\n如果你的固态硬盘与主板搭配存在兼容性问题而有间歇性的卡顿现象，不妨在主板BIOS设置当中开启Hot Plug选项来禁用LPM节能，或许就能解决故障。\n经测试，有效\n总结 为什么之前用Intel就没问题用了AMD就有问题，我猜测是因为原来的Intel主板比较差，不支持SATA LPM，然后win10默认是开启了LPM，但是SSD因为杂牌，所以支持不好，虽然固件支持LPM，但是会出现严重问题。由于主板不支持LPM，就算Windows开启了LPM，问题也显现不出来。\n现在换了新的主板，支持LPM，在默认情况下，与SSD出现兼容问题。需要手动关闭LPM功能。\n","date":"2018-10-24T11:47:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/%E5%85%B3%E4%BA%8E-windows-10-%E4%BD%BF%E7%94%A8-ssd-%E6%AF%8F%E9%9A%94%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98%E7%9A%84%E6%8E%A2%E7%A9%B6%E4%B8%8E%E8%A7%A3%E5%86%B3/","title":"关于 Windows 10 使用 SSD 每隔一段时间卡顿问题的探究与解决"},{"content":"于成都一酒店面试 有想到的再更新\n笔试 使用开放地址法实现hashmap，key是int，value是string，时间30分钟\n一面 volatile 作用 原理 dynamic_cast static_cast 区别 dynamic_cast父子类转换合法问题 虚析构函数 虚表 RTTI type_info 结构体 sizeof 红黑树特点；大约12个数字，求该序列一个可能的红黑树结果，画出来 服务器建立listen的api调用过程，非阻塞epoll如何实现 epoll原理，边缘触发水平触发业务代码的逻辑区别在哪 tcp粘包 扔两个鸡蛋，100层楼，求鸡蛋硬度，动态规划求解方法 10亿个玩家，每个人都有个分数，分数范围是0~10w，求一个人的排名是多少 redis跳跃表 内存栅栏在汇编中是如何实现的 void func()函数对应的汇编程序刚开始都要做两件事，是什么 如果程序出现了内存泄漏，如何判断内存是如何泄露 如何在main函数之前打印一些东西。main函数之前还会执行哪些程序。 二面 python is == 区别 id函数 python xrange range 区别 Python iterator redis ziplist redis ttl过期实现 stl deque实现（我回答list，不对。遂问你如果要实现一个deque，你怎么实现） shell中运行一个程序，到程序输出hello world，中间发生了什么，细节 Linux程序典型内存布局画出来 不同线程之间可以访问对方的栈空间吗 一个长为x，宽为y的矩阵，四个角有洞，一个台球从某点出发，不考虑摩擦力无限运动下去，求他会进入到哪个洞里面 lambda表达式[]可以填什么，你觉得编译器是如何实现lambda表达式的 什么是右值（这里我把右值和右值引用搞混了） malloc实现过程，malloc一定会调用brk调整堆边界吗。介绍buddy https 客户端和服务器是如何实现协议选择的，现在常用的协议是什么 https 客户端鉴定服务器的过程 ","date":"2018-09-15T15:59:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/2018-09-15-%E7%BD%91%E6%98%93%E4%BA%92%E5%A8%B1%E9%9D%A2%E8%AF%95/","title":"2018-09-15 网易互娱面试"},{"content":"参考资料 http://python.jobbole.com/81683/\nPython的命名空间 任何一个变量在创建时都会创建在自己的命名空间内，如果自己的命名空间内不含有这个名字，就会创建一个新的，而不是覆盖上层的命名空间，在访问时，如果自己的命名空间内没有，则访问上层的。\nPython的闭包 任何函数都是对象。可以创建一个待调用的对象。如果创建一个待调用的函数，其内部过程使用了一个局部变量，此时设计到了闭包：嵌套定义在非全局作用域里面的函数能够记住它在被定义的时候它所处的封闭命名空间。\n通俗的说：子函数可以使用父函数中的局部变量，这种行为就叫做闭包。\n闭包细节之C++与Python 一般情况下，大部分语言的父函数的局部变量，会随着父函数退出而结束生命周期。此时lambda函数，或者函数对象的调用中，如果引用了父函数的局部变量，就会出现问题。如果定义lambda或函数对象在定义的过程中，能够记住当前的命名空间，就是闭包。可是C++中，局部变量的生命周期规定是和父函数一样，怎么办？使用mutable修饰变量，该变量的生命周期就会变得和函数对象和lambda表达式一样长，否则捕捉这些变量时可能就会有问题。而Python会将闭包中的对象都捕捉到，不让其释放。直到函数对象回收为止。\n装饰器 有的时候我们需要对函数做一些改装，而这些改装的工作几乎类似。例如，我们需要对函数的运行时间进行计算，此时，我们需要在所有函数开始和结尾加上一个时间戳。然后在函数结束时进行打印。或者，我们需要对参数和返回值进行校验。当然我们可以在所有函数开始和结束的时候调用校验函数。\n装饰器可以完成这样的功能。例如我们有一个函数\ndef func(): time.sleep(1) 使用另一个返回带有闭包的函数对象的函数来完成这样的功能\ndef addTimePrint(func): def retFuncObj(*args, **kwargs): starttime = time() func(*args, **kwargs) print(time() - starttime) return retFuncObj 然后我们需要把新的func函数替换掉。\nfunc = addTimePrint(func) Python提供了一个语法糖，在定义了addTimePrint之后，使用@addTimePrint就可以完成函数的定义和装饰\n@addTimePrint def func(): time.sleep(1) ","date":"2018-09-04T08:54:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/python/python-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%BC%AB%E8%B0%88/","title":"Python 装饰器漫谈"},{"content":"前言 回顾一下Redis集群的相关知识点\n配置\n一个Redis数据库系统有一个主数据库，多个从数据库 主数据库不需要做任何配置，从数据库在配置中加入\u0026ndash;slaveof ip port即可 从数据库默认只读，就算改成可写也没有实际用处 除了在配置文件中添加，也可以在运行时使用slaveof命令，来修改主数据库 持久化回顾\nRDB 该方式将Redis进程fork一份，子进程将内存写入文件，然后替换之前的RDB快照 AOF 该方式Redis将每条命令都写入文件中。当AOF文件太大的时候，每追加一定数量的命令时，需要重写一次AOF文件，因为其中有些命令时冗余的。写入文件由于操作系统有缓存，可以进行配置。不配置的情况下30s写入磁盘一次。可以配置为每条命令都同步缓存，也可以配置为每秒同步一次。 原理 初始化复制 当从数据库启动后，向主数据库发送SYNC命令 主数据库进行一次快照保存，同时在保存快照时将命令缓存下来，然后将快照与保存快照期间的命令一起发送给从数据库 如果断线之后，Redis2.6以及以前的版本会重新进行初始化复制。Redis2.8之后的版本可以近传输断线期间的命令。 从数据库将接受到的临时快照替换为配置中设定的RDB快照文件。之后的操作和RDB持久化恢复的过程一致。 复制同步 之后，主数据库会将导致数据库变化的命令发送给从数据库 Redis复制策略使用的是乐观复制，存在不一致时间窗。主数据库可以配置当有多少数据库连接时可写，以及允许数据库最长失去链接时间。可以降低一定程度的数据不一致问题。 读写分离提高性能 一些带有耗时的读操作可以通过复制功能建立多个数据库从节点来加快速度\nslave数据库持久化 使用从数据库时可以关闭主数据库的持久化。但是主数据库崩溃的时候，主从数据库需要进行身份转换才可以恢复主数据库的内容。从数据库使用slaveof no one，主数据库使用slaveof命令设置为从数据库。\n这种情况下，如果主数据库崩溃后，不能立刻重新启动。因为如果此时从新启动，主数据库因为没有持久化，就会将从数据库中的内容清空。\n无硬盘复制 主从复制可以通过RDB持久化方式来实现初始化同步。 当主数据库禁用RDB快照，但是当执行了初始化复制，仍然会生成RDB快照。此时主数据库重启动时将会使用RDB快照进行恢复。因为同步时间点不确定，甚至可能很久都没有进行初始化同步。这可能导致恢复的时间点可能是任意的。\n另外，初始化同步时需要创建RDB快照，如果磁盘速度太慢可能会影响同步的效率。\n从Redis2.8.18开始，Redis引入了无硬盘复制，开启该选项的时候，初始化复制将不再创建RDB快照，而是直接通过网络将RDB快照内容发送走。\n增量复制 主数据库和从数据库如果断开链接后，下一次重新链接如果使用初始化复制，开销会比较高。\n数据库在每次运行时，会生成唯一ID。 复制同步阶段，主数据库会将每一个命令放入回放日志中。并记下当前命令的偏移量。 从数据库接受命令时，也需要记录下命令偏移量。 当主从连接准备就绪之后，从数据库发送psync来告诉主数据库可以使用增量复制。 主数据库判断从数据库发送的id和自己是否相同。不相同的情况下，主数据库可能已经重启过了。 然后判断从数据库的命令偏移量是否和在backlog回放日志中，如果在，将回放日志中的命令发给从数据库。 backlog的大小可以配置，默认时1MB。越大可以使断线重连后的容忍程度越长。 哨兵 哨兵系统的出现，目的是为了解决之前的主从数据库的维护的不方便。以前存在两个问题，主数据库挂了无法感知。主数据库挂了之后，主从转换问题。\n哨兵进程启动时，会读取配置文件。配置文件中有master-name ip port 。当主节点故障时，哨兵将自动转换其中一个从节点，变为主节点。当之前的主节点恢复后，会自动转变为从节点。\n哨兵启动之后，会定时执行下面3个操作：\n10秒向master、slave发送INFO 2秒向master、slave的__sentinel__:hello发送自己的信息 1秒向主数据库、从数据库、和其他哨兵发送PING INFO信息使得哨兵可以获取当前数据库的相关信息。向master发送INFO可以获取其从数据库。 向频道发送自己的信息，所有哨兵可以收到监控同一个数据库的其他哨兵的信息。 哨兵之间建立连接目的是为了发送ping信息。 哨兵发送ping命令时没有进行回复，就会认为其主观下线。如果发现一个主数据库主观下线，就会询问其他哨兵是否认为其主观下线。如果达到一定数量的时候，超过哨兵启动参数中设置的quorum，哨兵认为其客观下线。\nRAFT选举：\n发现主数据库客观下线的哨兵A向其他哨兵发送命令，请求选自己成为领头哨兵。 如果被请求的哨兵还没有选过其他人，则会同意 如果A发现同意的数量超过了哨兵数量的一半和quorum参数，则A成为领头哨兵。 否则，随机等待一个时间重新发起请求，进行下一轮选举 领头哨兵会进行如下操作：\n查看从数据库的优先级，优先级越高的选他 查看从数据库的复制命令偏移量，偏移量越大的选他 选择ID小的从数据库 被选中的数据库会被领头哨兵发送slaveof no one成为主数据库，其他从数据库会收到slaveof命令更改其主数据库。最后，更改内部记录，将已经停止的数据库更新为主数据库的从数据库，使当其恢复服务时以从数据库的身份恢复。\n部署 哨兵一般部署在每个节点上，如果redis集群很大，所有哨兵与一个从数据库之间的连接数量太多会影响redis对所有哨兵的回复。所以部署的数量不能太多。\n集群 水平扩容这块，在腾讯实习期间解除了codis。codis分为redis proxy和从节点。主要原理就是对key进行hash之后，放入到具体的redis slave中。脚本在执行的过程中，被分配到具体的slave中执行，可能会遇到找不到其他key的情况。\n除了codis，还有redis cluster。\n在启动redis实例时，配置中cluster-enables改为yes，即可打开集群配置。\n使用脚本可以方便的创建集群。增加新节点可以使用cluster meet命令添加ip和端口。该节点添加新节点后，会使用gossip协议将该节点的信息广播到所有节点。\n插槽的分配。新的节点加入集群后有两种选择，要么使用cluster replicate命令复制每个主数据库来以从数据库的形式运行，要么向集群申请分配插槽slot来以主数据库的形式运行。\nkey使用crc16做hash运算，如果存在{*}，则使用该部分做hash运算，然后分给16384个槽中的一个。集群在创建的开始时就有一个槽分配的映射表。最终数据会存在对应的redis节点中。\n","date":"2018-09-02T14:25:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E6%95%B0%E6%8D%AE%E5%BA%93/redis-%E9%9B%86%E7%BE%A4%E5%AD%A6%E4%B9%A0/","title":"Redis 集群学习"},{"content":" 在函数中，简洁赋值语句 := 可在类型明确的地方代替 var 声明。但是常量必须使用const来声明 函数外的每个语句都必须以关键字开始（var, func 等等），因此 := 结构不能在函数外使用。 为什么Go使用后置类型生命 https://blog.go-zh.org/gos-declaration-syntax Go的类型有如下： bool string int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr byte // uint8 的别名 rune // int32 的别名 // 表示一个 Unicode 码点 float32 float64 complex64 complex128 当你需要一个整数值时应使用 int 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。 Go不存在隐式转换 ","date":"2018-09-01T13:40:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/go/2018-08-30-go%E5%AD%A6%E4%B9%A0%E6%8B%BE%E8%B4%9D/","title":"2018-08-30 Go学习拾贝"},{"content":" 三次握手四次挥手 nagle算法 tcp断开链接一方会进入到哪几个状态 多进程多线程如何选择，考虑业务 mysql master slave 集群 了解多少 多进程下gdb调试流程 网络框架libevent等介绍 select 和epoll区别。java为什么connect用select不用epoll 进程间通信方式 锁的了解。无锁数据结构实现 共享内存互斥如何设计 ","date":"2018-08-29T04:32:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/2018-08-29-%E8%85%BE%E8%AE%AF%E5%A4%A9%E7%BE%8E%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95/","title":"2018-08-29 腾讯天美电话面试"},{"content":"K8S要求所有节点具有完全互联的网络，因此所有节点应该具有平等的ip，虽然每个节点都有公网ip，但是由于腾讯云的机器在网卡上看不到ip，因此在加入集群时会使用网卡的ip，其他节点无法通过该ip找到这个机器。\n想要在网卡上看到ip，需要开通腾讯云eip直通功能。需要注意的是，官方提供的脚本在debian 10上存在问题，无法正确的自启动，需要做如下更改：\n将/etc/rc.loacl最终行添加 /etc/rc.d/rc.local\n虽然腾讯云的debian 10还是会开机启动/etc/rc.local，但是不会启动/etc/rc.d/rc.local，而提供的脚本是写入到后者的。\n参考文档 https://cloud.tencent.com/document/product/1199/41709\n","date":"2018-07-22T13:40:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/k8s/%E8%A7%A3%E5%86%B3%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B7%A8%E8%BF%90%E8%90%A5%E5%95%86%E6%90%AD%E5%BB%BAk8s%E9%9B%86%E7%BE%A4%E7%BD%91%E5%8D%A1ip%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%97%AE%E9%A2%98/","title":"解决腾讯云服务器跨运营商搭建k8s集群网卡ip不正确的问题"},{"content":"前言 为了工作内容学习SVN。SVN是一个C/S类型的版本管理，对服务器依赖很大，大部分操作是和SVN服务器有关的。\n最常见的操作流程 这里假设服务器项目的地址是svn://192.168.1.1/shop\n通过checkout检出项目 update 更新服务器的项目到本地 commit 提交本地的更改 如何部署一个svn服务器 因为这个svn是一个c/s类型的软件，得部署服务器才能够使用。所以得先弄个服务器出来供我们测试。 为了尽可能简单，这里在Windows下面安装一个visualsvn的软件来当作我们的服务器。注意一般服务器是运行在Linux的，这里只是为了上手方便才使用Windows的服务器软件。在官网很容易就能下载到visualsvn server的软件。我下了个3.9的版本。用就用最新稳定版。中间有一步选标准版，其他的按照默认来就可以了。其中有一个端口号的选择，注意一下不要和本机的端口冲突了。默认端口是443，你可以改成8443。\n在服务器端创建一个测试项目 因为svn项目就是仓库，就是一个文件夹。我们需要建立一个文件夹。打开D:\\Repositories文件夹，在该目录下面运行命令svnadmin create test1，这样就建立了一个项目。为了其他用户能够访问该目录，需要使用svnserve命令启动服务器，这个稍后再说。这里还需要配置权限设置。打开test1目录下面的conf目录svnserve.conf，将其中的anon-access 的注释去掉，将值改为write。此时允许匿名访问，并可写\n然后在D:\\Repositories目录下运行命令： svnserve -d -r ./test1 这一步是打开svn服务器的监听状态。\nsvn客户端常用操作 下载TortoiseSVN进行安装。\ncheckout 检出 然后，在需要同步的目录下面单机右键，选择tortoise中的rebo-bowser，并输入svn://127.0.0.1确认。在文件夹图标上右键选择checkout并确认，此时检出成功。\ncommit 添加一个txt文件，随便写点东西。然后右键commit。即可commit到服务器端。\nupdate A开发者将提交的数据提交后，服务器发生了变化，B开发者需要同步。右键update即可。\nignore 不需要提交文件时，在文件上面右键然后选择add to ignore list中\nSVN版本 svn版本从1开始递增。svn可以会退版本。svn可以进行分支和合并操作，但是和git中的分支操作区别很大。似乎是重新创建了一个项目这样的。最后合并也是只是把冲突合并了。和git基于diff进行分支不同。\n","date":"2018-07-01T15:01:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/svn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"SVN学习笔记"},{"content":"前言 为了加密传输http的数据，我们需要用到https证书。免费的证书有lets‘s encrypt。\n使用nginx配置转发 我们需要在服务器上配置nginx，使得lets\u0026rsquo;s encrypt能够验证我们的域名。 下面是我的服务器nginx的配置文件\nserver { listen 80; server_name www.unrealblue.cc; location / { return 301 https://$host$request_uri; } location ~ /.well-known/acme-challenge { root /var/www/html; allow all; } } 说明：第一个location意思是转发所有的80请求到https连接。第二个请求的意思是，如果访问.well-known，则使用我们提供的/var/www/html目录。\n将文件保存为default.conf。\n这里我使用了nginx docker来部署，所以没有安装nginx。\nFROM nginx LABEL MAINTAINER linanwx@gmail.com RUN apt update RUN apt install -y certbot RUN mkdir -p /var/www/html COPY ./default.conf /etc/nginx/conf.d/ EXPOSE 80:80 EXPOSE 443:443 VOLUME [\u0026#34;/etc/letsencrypt/\u0026#34;] 将第一个代码段存为default.conf，第二个代码段存为dockerfile，然后运行docker build -t nginx-server .\n运行docker run -it --rm -d -p80:80 -p443:443 --net=server-net --name nginx-server -v $PWD/letsencrypt:/etc/letsencrypt nginx-server启动容器并在后台运行。\n生成证书 运行docker exec -it nginx-server /bin/bash进入容器内部。 运行下面的命令生成证书\nopenssl dhparam -out /etc/letsencrypt/live/dhparams.pem 2048 certbot certonly --agree-tos -a webroot --webroot-path=/var/www/html -d www.unrealblue.cc -m linanwx@gmail.com certbot程序会访问你的域名，来确认你的域名所有权是你，这就用到了上一步操作的nginx的配置。其中还有一些参数，查看help可以知道含义。另外，除非你确认要部署到服务器上，否则在测试阶段使用\u0026ndash;test-cert参数来进行测试。因为证书生成是有数量限制的。 另外一点就是生成dhparam。他是迪菲-赫尔曼秘钥交换协议参数，生成时间较长。之后我们会在nginx中使用这个。\n不出意外你会获得证书，他们存在/etc/letsencrypt/目录下。并且，由于在容器启动的时候使用了挂卷，证书会出现在宿主机中。\n配置nginx https 新建一个文件，命名为http.conf\n# https://www.jianshu.com/p/f7f39cb24423 server { listen 443 ssl; server_name www.unrealblue.cc; ssl_certificate /etc/letsencrypt/live/www.unrealblue.cc/fullchain.pem; ssl_trusted_certificate /etc/letsencrypt/live/www.unrealblue.cc/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/www.unrealblue.cc/privkey.pem; ssl_dhparam /etc/letsencrypt/live/dhparams.pem; ssl_ciphers \u0026#39;ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS\u0026#39;; ssl_prefer_server_ciphers on; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_session_cache shared:SSL:50m; ssl_session_timeout 1d; ssl_stapling on; ssl_stapling_verify on; add_header Strict-Transport-Security max-age=60; location / { root /usr/share/nginx/html; index index.html index.htm; } # location = /gfwlist { # proxy_pass http://server-handy:8081; # } error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } } 将其保存。然后修改dockerfile如下：\nFROM nginx LABEL MAINTAINER linanwx@gmail.com RUN apt update RUN apt install -y certbot RUN mkdir -p /var/www/html COPY ./default.conf /etc/nginx/conf.d/ COPY ./https.conf /etc/nginx/conf.d/ EXPOSE 80:80 EXPOSE 443:443 VOLUME [\u0026#34;/etc/letsencrypt/\u0026#34;] 这里将这个http.conf也一同复制进去了。\n重新启动容器，访问https://127.0.0.1，可以看到访问成功了。\n在本地环境测试的时候会提示证书不正确。 点继续。\n","date":"2018-06-04T09:12:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E7%BD%91%E7%BB%9C/%E4%BD%BF%E7%94%A8lets-encrypt%E5%92%8Cnginx%E9%85%8D%E7%BD%AEhttps%E8%AE%BF%E9%97%AE/","title":"使用Let's encrypt和nginx配置https访问"},{"content":"前言 socat是强大易用的工具，可以实现任意socket的转换。\n使用 socat [options] \u0026lt;address\u0026gt; \u0026lt;address\u0026gt;\noptions可以查看help。\naddress有一下几种形式：\n- STDIN STDOUT ：表示标准输入输出，可以就用一个横杠代替 /var/log/syslog : 也可以是任意路径，如果是相对路径要使用./，打开一个文件作为数据流。 TCP:127.0.0.1:1080 : 建立一个TCP连接作为数据流，TCP也可以替换为UDP TCP-LISTEN:12345 : 建立TCP监听端口，TCP也可以替换为UDP EXEC:/bin/bash : 执行一个程序作为数据流。 场景一 本地有个文件，我想显示在终端中\nsocat - /etc/sysctl.conf\n场景二 有个TCP连接会连上来，我想看看会获得什么数据。 socat TCP-LISTEN:12345 -\n场景三 我是黑客，我想在目标机上弄一个shell代理 socat TCP-LISTEN:12345 EXEC:/bin/bash\n场景四 本地有一个UNIX DOMAIN域套接字，我想把他转成TCP SOCKET供局域网内的机器使用，怎么办？\nsocat TCP-LISTEN:12345,reuseaddr,fork UNIX-CONNECT:/data/deCOREIDPS/unix.domain\n当有多个tcp连上来那就fork一个去连域套接字\n场景五 将本地的80端口转到远程去\nsocat TCP-LISTEN:80,fork TCP:www.baidu.com:80\n参考 http://brieflyx.me/2015/linux-tools/socat-introduction/\n","date":"2018-05-23T09:04:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E7%BD%91%E7%BB%9C/socat%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/","title":"socat命令学习"},{"content":"前言 睡前学习一下Google protocol buffer\n安装protobuf编译器 启动最新版的ubuntu docker镜像，运行apt install protobuf-compiler\n书写 .proto 文件 nano lm.helloworld.proto\n然后输入\npackage lm; message helloworld { required int32 id = 1; // ID required string str = 2; // str optional int32 opt = 3; //optional field } 在上例中，package 名字叫做 lm，定义了一个消息 helloworld，该消息有三个成员，类型为 int32 的 id，另一个为类型为 string 的成员 str。opt 是一个可选的成员，即消息中可以不包含该成员。\n编译proto文件 ","date":"2018-05-18T11:10:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/google-protocol-buffer-%E4%BA%86%E8%A7%A3/","title":"GoogleProtocolBuffer了解"},{"content":"前言 C++网络库有很多。handy是一个C++11风格的网络库，对深入学习C++有很大帮助。\n代码分析 下面是来自handy/raw_examples下的epoll.cc文件。是水平触发的一个示例。该http服务器无论接收到什么样的请求，都返回一个静态资源123456。编译：c++ -o epoll epoll.cc，运行： sudo ./epoll。源代码中sendRes的if (con.writeEnabled)这句似乎有些问题，导致发送超大资源时出现问题。我已经做了修改，使之能够正确发送超大文件。\n/* * 编译：c++ -o epoll epoll.cc * 运行： ./epoll * 测试：curl -v localhost */ /* 运行效果 使用sudo 运行epoll程序。该程序在本机0.0.0.0的80端口监听，作为一个http服务器运行 每当有连接访问时，返回静态资源httpRes LT是默认模式 */ #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;sys/epoll.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; bool output_log = true; // 一个宏，用来打印错误并退出 #define exit_if(r, ...) if(r) {printf(__VA_ARGS__); printf(\u0026#34;%s:%d error no: %d error msg %s\\n\u0026#34;, __FILE__, __LINE__, errno, strerror(errno)); exit(1);} // 这个函数用于将指定的fd设置为非阻塞状态 void setNonBlock(int fd) { // 首先我们取出原来文件描述符的flags int flags = fcntl(fd, F_GETFL, 0); exit_if(flags\u0026lt;0, \u0026#34;fcntl failed\u0026#34;); // 然后加上O_NONBLOCK，再设置回去 int r = fcntl(fd, F_SETFL, flags | O_NONBLOCK); exit_if(r\u0026lt;0, \u0026#34;fcntl failed\u0026#34;); } // 对epoll_ctl二次包装，将events 和 fd放入ev中。 // 并且设置events 设置为可读可写时触发 void updateEvents(int efd, int fd, int events, int op) { struct epoll_event ev = {0}; ev.events = events; ev.data.fd = fd; printf(\u0026#34;%s fd %d events read %d write %d\\n\u0026#34;, op==EPOLL_CTL_MOD?\u0026#34;mod\u0026#34;:\u0026#34;add\u0026#34;, fd, ev.events \u0026amp; EPOLLIN, ev.events \u0026amp; EPOLLOUT); int r = epoll_ctl(efd, op, fd, \u0026amp;ev); exit_if(r, \u0026#34;epoll_ctl failed\u0026#34;); } // 尝试在fd上做accept操作。如果成功，将其加入到epoll fd的监听列表中。epoll的events设置为当数据有写入的时候触发。 void handleAccept(int efd, int fd) { struct sockaddr_in raddr; socklen_t rsz = sizeof(raddr); int cfd = accept(fd,(struct sockaddr *)\u0026amp;raddr,\u0026amp;rsz); exit_if(cfd\u0026lt;0, \u0026#34;accept failed\u0026#34;); sockaddr_in peer, local; socklen_t alen = sizeof(peer); int r = getpeername(cfd, (sockaddr*)\u0026amp;peer, \u0026amp;alen); exit_if(r\u0026lt;0, \u0026#34;getpeername failed\u0026#34;); printf(\u0026#34;accept a connection from %s\\n\u0026#34;, inet_ntoa(raddr.sin_addr)); setNonBlock(cfd); updateEvents(efd, cfd, EPOLLIN, EPOLL_CTL_ADD); } // 表示一个连接。成员有连接已读取的数据、已写入的数据 // string用来保存二进制内容没有问题吗，如果遇到\\0会如何？ // 没有问题https://www.zhihu.com/question/33104941 struct Con { string readed; size_t written; bool writeEnabled; Con(): written(0), writeEnabled(false) {} }; // 用来映射fd与con的数据结构 map\u0026lt;int, Con\u0026gt; cons; string httpRes; // 发送资源 void sendRes(int efd, int fd) { // 首先取得连接信息 Con\u0026amp; con = cons[fd]; // 没有接受到数据就要求写入 // 说明其可能上一次继续发送的数据发送完了 // 其对应的文件描述符在cons中已经删除 // 然后触发了epoll信号 // 此时关闭其上一次发送的标志 // 然后关闭其缓冲区发送触发epoll的标志 // 只保留其有数据可读时触发 // 为什么不在写入完数据时就将这步做了呢？ // if (!con.readed.length()) { // if (con.writeEnabled) { // updateEvents(efd, fd, EPOLLIN, EPOLL_CTL_MOD); // con.writeEnabled = false; // } // return; // } // 计算还需要写入的数据长度 size_t left = httpRes.length() - con.written; int wd = 0; // 连续写入数据，直到内核缓冲区无法写入数据为止 while((wd=::write(fd, httpRes.data()+con.written, left))\u0026gt;0) { con.written += wd; left -= wd; if(output_log) printf(\u0026#34;write %d bytes left: %lu\\n\u0026#34;, wd, left); }; // 如果没有数据可以写入，则删除这个连接。但是不断开连接，即将连接信息置空 if (left == 0) { // close(fd); // 测试中使用了keepalive，因此不关闭连接。连接会在read事件中关闭 if (con.writeEnabled) { updateEvents(efd, fd, EPOLLIN, EPOLL_CTL_MOD); con.writeEnabled = false; } cons.erase(fd); return; } // 如果内核缓冲区满了，没办法写入了 if (wd \u0026lt; 0 \u0026amp;\u0026amp; (errno == EAGAIN || errno == EWOULDBLOCK)) { // 将其标记上可继续写 if (!con.writeEnabled) { // 等待其可继续写，或可读 // 避免重复进行系统调用，使用con.writeEnabled标记位 printf(\u0026#34;update it to EPOLLIN|EPOLLOUT\\n\u0026#34;); updateEvents(efd, fd, EPOLLIN|EPOLLOUT, EPOLL_CTL_MOD); con.writeEnabled = true; } return; } // 如果是其他情况，比如在没有写完数据时直接返回0，或者是返回了其他错误 // 则说明出错了 if (wd\u0026lt;=0) { printf(\u0026#34;write error for %d: %d %s\\n\u0026#34;, fd, errno, strerror(errno)); close(fd); cons.erase(fd); } } // 当loop once处理读取数据时，调用该函数 void handleRead(int efd, int fd) { char buf[4096]; int n = 0; // 每次读取4k字节，循环读出当前内核中已存在的数据（有可能分包导致信息不完整） while ((n=::read(fd, buf, sizeof buf)) \u0026gt; 0) { if(output_log) printf(\u0026#34;read %d bytes\\n\u0026#34;, n); // 这里通过一个map来获取之前fd对应的连接信息。 // 当fd对应的下标不存在的时候，则会调用con的默认构造函数Con(): written(0), writeEnabled(false) {} string\u0026amp; readed = cons[fd].readed; // 调用string类的append方法将数据加入到连接信息中 // 注意为了保证二进制安全需要传入参数n readed.append(buf, n); std::cout \u0026lt;\u0026lt; \u0026#34;now info is\u0026#34; \u0026lt;\u0026lt; std::endl \u0026lt;\u0026lt; \u0026#34;---\u0026#34; \u0026lt;\u0026lt; readed \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;---\u0026#34; \u0026lt;\u0026lt; std::endl; // 判断一个http请求发送完毕。 // 不判断http请求的内容，一律发送静态资源 if (readed.length()\u0026gt;4) { if (readed.substr(readed.length()-2, 2) == \u0026#34;\\n\\n\u0026#34; || readed.substr(readed.length()-4, 4) == \u0026#34;\\r\\n\\r\\n\u0026#34;) { //当读取到一个完整的http请求，测试发送响应 // TCP连接建立起来之后，客户端就开始传输首部，然后以\\r\\n\\r\\n来标志首部的结束和实体的开始（当然是请求里包含实体才会有实体的开始）， // 接下来就是实体的传输，当实体传输完之后，客户端就开始接收数据，服务器就知道，这次请求就已经结束了， // 那么实体就是\\r\\n\\r\\n到停止接收的那么一段数据。对应的，客户端接收响应的时候也是这样。 // 没有实体，则\\r\\n\\r\\n就是http的结束 // 开始写入数据。注意有可能使缓冲区写满，若写满了则在之后继续写入 sendRes(efd, fd); } } } // read无法读取的话，就会返回-1。此时errno（errno是属于线程的，是线程安全的）是EAGAIN代表没读完。EWOULDBLOCK和EAGAIN是一样的。 // 那就返回，然后等待下次再读取 if (n\u0026lt;0 \u0026amp;\u0026amp; (errno == EAGAIN || errno == EWOULDBLOCK)){ printf(\u0026#34;nothing to read from %d, return. \\n\u0026#34;, fd); return; } //实际应用中，n\u0026lt;0应当检查各类错误，如EINTR if (n \u0026lt; 0) { printf(\u0026#34;read %d error: %d %s\\n\u0026#34;, fd, errno, strerror(errno)); } // 执行到这里，n是0，表示对端关闭连接。这时我们也关闭连接 printf(\u0026#34;%d close the connection\\n\u0026#34;, fd); close(fd); cons.erase(fd); } // 当loop once缓冲区可写的时候，简单的写入我们准备好的静态资源 void handleWrite(int efd, int fd) { sendRes(efd, fd); } // 对一个epoll句柄进行循环中的一次操作 // 其中l是LISTEN的fd void loop_once(int efd, int lfd, int waitms) { // 最多让内核拷贝20个事件出来 const int kMaxEvents = 20; struct epoll_event activeEvs[100]; int n = epoll_wait(efd, activeEvs, kMaxEvents, waitms); // n是返回了多少个事件 if(output_log) printf(\u0026#34;epoll_wait return %d\\n\u0026#34;, n); for (int i = 0; i \u0026lt; n; i ++) { int fd = activeEvs[i].data.fd; int events = activeEvs[i].events; // EPOLLIN 事件或者是 EPOLLERR事件。EPOLLERR也代表管道写入结束。 // 参见： http://man7.org/linux/man-pages/man2/epoll_ctl.2.html if (events \u0026amp; (EPOLLIN | EPOLLERR)) { // EPOLLIN事件则只有当对端有数据写入时才会触发，所以触发一次后需要不断读取所有数据直到读完EAGAIN为止。否则剩下的数据只有在下次对端有写入时才能一起取出来了。 // 当对方关闭连接，则是EPOLLERR事件 if (fd == lfd) { printf(\u0026#34;this is accept\\n\u0026#34;); handleAccept(efd, fd); } else { printf(\u0026#34;this can read\\n\u0026#34;); handleRead(efd, fd); } } else if (events \u0026amp; EPOLLOUT) { // 这里处理文件描述符如果可以写入的事件 // EPOLLOUT事件只有在连接时触发一次，表示可写 // 之后表示缓冲区的数据已经送出，可以继续写入 // 详见https://www.zhihu.com/question/22840801 if(output_log) printf(\u0026#34;handling epollout\\n\u0026#34;); handleWrite(efd, fd); } else { exit_if(1, \u0026#34;unknown event\u0026#34;); } } } int main(int argc, const char* argv[]) { if (argc \u0026gt; 1) { output_log = false; } /* 小知识 signal（参数1，参数2）； 参数1：我们要进行处理的信号。系统的信号我们可以再终端键入 kill -l查看(共64个)。其实这些信号时系统定义的宏。 参数2：我们处理的方式（是系统默认还是忽略还是捕获）。SIG_IGN: 如果func参数被设置为SIG_IGN，该信号将被忽略。 */ ::signal(SIGPIPE, SIG_IGN); // 设置http返回的内容 httpRes = \u0026#34;HTTP/1.1 200 OK\\r\\nConnection: Keep-Alive\\r\\nContent-Type: text/html; charset=UTF-8\\r\\nContent-Length: 19048576\\r\\n\\r\\n123456\u0026#34;; // 将剩下的内容填充成0。最后content的长度是大约1024*1024 for(int i=0;i\u0026lt;19048570;i++) { httpRes+=\u0026#39;\\0\u0026#39;; } // 设置端口为80端口 short port = 80; // 创建一个epoll句柄 int epollfd = epoll_create(1); exit_if(epollfd \u0026lt; 0, \u0026#34;epoll_create failed\u0026#34;); // 创建一个socket套接字 int listenfd = socket(AF_INET, SOCK_STREAM, 0); exit_if(listenfd \u0026lt; 0, \u0026#34;socket failed\u0026#34;); struct sockaddr_in addr; memset(\u0026amp;addr, 0, sizeof addr); addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = INADDR_ANY; // 先绑定socket到端口上 int r = ::bind(listenfd,(struct sockaddr *)\u0026amp;addr, sizeof(struct sockaddr)); // 这一步如果没有超级用户的权限，就会报错。linux对于非root权限用户不能使用1024以下的端口 exit_if(r, \u0026#34;bind to 0.0.0.0:%d failed %d %s\u0026#34;, port, errno, strerror(errno)); /* #include\u0026lt;sys/socket.h\u0026gt; int listen(int sockfd, int backlog) 返回：0──成功， -1──失败 参数sockfd 被listen函数作用的套接字，sockfd之前由socket函数返回。在被socket函数返回的套接字fd之时，它是一个主动连接的套接字， 也就是此时系统假设用户会对这个套接字调用connect函数，期待它主动与其它进程连接，然后在服务器编程中，用户希望这个套接字可以接受外来的连接请求， 也就是被动等待用户来连接。由于系统默认时认为一个套接字是主动连接的，所以需要通过某种方式来告诉系统，用户进程通过系统调用listen来完成这件事。 参数backlog 这个参数涉及到一些网络的细节。在进程正理一个一个连接请求的时候，可能还存在其它的连接请求。 因为TCP连接是一个过程，所以可能存在一种半连接的状态，有时由于同时尝试连接的用户过多，使得服务器进程无法快速地完成连接请求。 如果这个情况出现了，服务器进程希望内核如何处理呢？ 内核会在自己的进程空间里维护一个队列以跟踪这些完成的连接但服务器进程还没有接手处理或正在进行的连接，这样的一个队列内核不可能让其任意大， 所以必须有一个大小的上限。这个backlog告诉内核使用这个数值作为上限。 毫无疑问，服务器进程不能随便指定一个数值，内核有一个许可的范围。这个范围是实现相关的。很难有某种统一，一般这个值会小30以内。 内核用于跟踪这些完成连接但是用户代码还没有通过accept调用的队列长度这里设置为了20。在队列长度小于20时，内核会立即完成连接的建立。 但是如果队列长度大于20，在用户代码调用accept之前该连接都不会建立，对方则处于阻塞状态。 */ r = listen(listenfd, 20); exit_if(r, \u0026#34;listen failed %d %s\u0026#34;, errno, strerror(errno)); printf(\u0026#34;fd %d listening at %d\\n\u0026#34;, listenfd, port); // 接下来设置文件描述符为阻塞。 // 为什么要设置为非阻塞？https://www.zhihu.com/question/23614342 setNonBlock(listenfd); // 将其设置为可读取时触发，添加到epoll文件描述符池中 updateEvents(epollfd, listenfd, EPOLLIN, EPOLL_CTL_ADD); for (;;) { //实际应用应当注册信号处理函数，退出时清理资源 loop_once(epollfd, listenfd, 10000); } return 0; } 运行效果 sudo ./epoll fd 4 listening at 80 add fd 4 events read 1 write 0 epoll_wait return 1 this is accept accept a connection from 127.0.0.1 add fd 5 events read 1 write 0 epoll_wait return 1 this can read read 412 bytes now info is ---GET / HTTP/1.1 Host: 127.0.0.1 Connection: keep-alive User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36 Upgrade-Insecure-Requests: 1 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9,und;q=0.8,zh-TW;q=0.7,en;q=0.6,pl;q=0.5 --- write 4081834 bytes left: 14966851 update it to EPOLLIN|EPOLLOUT mod fd 5 events read 1 write 4 nothing to read from 5, return. epoll_wait return 1 handling epollout write 2226422 bytes left: 12740429 epoll_wait return 1 handling epollout write 2095456 bytes left: 10644973 epoll_wait return 1 handling epollout write 1964490 bytes left: 8680483 epoll_wait return 1 handling epollout write 1506109 bytes left: 7174374 epoll_wait return 1 handling epollout write 1833524 bytes left: 5340850 epoll_wait return 1 handling epollout write 1637075 bytes left: 3703775 write 130966 bytes left: 3572809 epoll_wait return 1 handling epollout write 1571592 bytes left: 2001217 epoll_wait return 1 handling epollout write 1440626 bytes left: 560591 epoll_wait return 1 handling epollout write 560591 bytes left: 0 mod fd 5 events read 1 write 0 epoll_wait return 1 this can read read 375 bytes now info is ---GET /favicon.ico HTTP/1.1 Host: 127.0.0.1 Connection: keep-alive User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36 Accept: image/webp,image/apng,image/*,*/*;q=0.8 Referer: http://127.0.0.1/ Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9,und;q=0.8,zh-TW;q=0.7,en;q=0.6,pl;q=0.5 --- write 10477280 bytes left: 8571405 update it to EPOLLIN|EPOLLOUT mod fd 5 events read 1 write 4 nothing to read from 5, return. epoll_wait return 1 handling epollout write 1440626 bytes left: 7130779 epoll_wait return 1 handling epollout write 1768041 bytes left: 5362738 epoll_wait return 1 handling epollout write 1571592 bytes left: 3791146 epoll_wait return 1 handling epollout write 1637075 bytes left: 2154071 epoll_wait return 1 handling epollout write 1702558 bytes left: 451513 epoll_wait return 1 handling epollout write 451513 bytes left: 0 mod fd 5 events read 1 write 0 epoll_wait return 0 epoll_wait return 0 epoll_wait return 0 这里我发送的资源改大了，改成如下的数值：\nhttpRes = \u0026#34;HTTP/1.1 200 OK\\r\\nConnection: Keep-Alive\\r\\nContent-Type: text/html; charset=UTF-8\\r\\nContent-Length: 19048576\\r\\n\\r\\n123456\u0026#34;; // 将剩下的内容填充成0。最后content的长度是大约1024*1024 for(int i=0;i\u0026lt;19048570;i++) { httpRes+=\u0026#39;\\0\u0026#39;; } 可以看到分了多次传输。最终终端页面上显示123456，后面全都是\\0，不会显示。 可以看到浏览器请求了两次，一次请求根目录，一次请求页面的图标favicon.ico\n","date":"2018-05-16T07:43:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E7%BD%91%E7%BB%9C/epoll%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8Bhandy%E5%BA%93%E8%87%AA%E5%B8%A6epoll-cc%E5%88%86%E6%9E%90/","title":"epoll代码示例——handy库自带epoll.cc分析"},{"content":"开始准备写ss助手的服务器端。有很多问题。\n语言 如果将来要从事C++后台开发，最好还是使用C++比较好。但是也想使用一下其他的方案，比如Python。Python试了一下webpy非常的轻量，估计不会再使用之前的flask框架了。另外一个就是Go。Go的语法也是个问题，还没有学习。\n框架 暂时看到了C++的handy。不是特别想用muduo库。还是不想使用boost，虽然effective c++上面说了要学习boost。handy第一印象感觉很好。还在学习中。\n目标是先用handy写一个静态的服务器。之后再扩展。\n","date":"2018-05-11T09:50:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/2018-05-11-%E9%9A%8F%E7%AC%94/","title":"2018-05-11 随笔"},{"content":"原始的单例模式 单例模式要做如下事情：\n不能通过构造函数构造，否则就能够实例化多个。构造函数需要私有声明 保证只能产生一个实例 下面是一个简单的实现：\nclass Singleton { private: static Singleton *local_instance; Singleton(){}; public: static Singleton *getInstance() { if (local_instance == nullptr) { local_instance = new Singleton(); } return local_instance; } }; Singleton * Singleton::local_instance = nullptr; int main() { Singleton * s = Singleton::getInstance(); return 0; } 使用局部静态对象来解决存在的两个问题 刚刚的代码中有两个问题，一个是多线程的情况下可能会出现new两次的情况。另外一个是程序退出后没有运行析构函数。 下面采用了静态对象来解决。\nclass Singleton { private: static Singleton *local_instance; Singleton(){ cout \u0026lt;\u0026lt; \u0026#34;构造\u0026#34; \u0026lt;\u0026lt; endl; }; ~Singleton(){ cout \u0026lt;\u0026lt; \u0026#34;析构\u0026#34; \u0026lt;\u0026lt; endl; } public: static Singleton *getInstance() { static Singleton locla_s; return \u0026amp;locla_s; } }; int main() { cout \u0026lt;\u0026lt; \u0026#34;单例模式访问第一次前\u0026#34; \u0026lt;\u0026lt; endl; Singleton * s = Singleton::getInstance(); cout \u0026lt;\u0026lt; \u0026#34;单例模式访问第一次后\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;单例模式访问第二次前\u0026#34; \u0026lt;\u0026lt; endl; Singleton * s2 = Singleton::getInstance(); cout \u0026lt;\u0026lt; \u0026#34;单例模式访问第二次后\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 该代码可能在c++11之前的版本导致多次构造函数的调用，所以只能在较新的编译器上使用。\n如果是c++11之前的版本，静态对象线程会不安全 下面这个版本使用了mutex以及静态成员来析构单例。该方案的劣处在于锁导致速度慢，效率低。但是至少是正确的，也能在c++11之前的版本使用，代码的示例如下：\nclass Singleton { private: static Singleton *local_instance; static pthread_mutex_t mutex; Singleton(){ cout \u0026lt;\u0026lt; \u0026#34;构造\u0026#34; \u0026lt;\u0026lt; endl; }; ~Singleton(){ cout \u0026lt;\u0026lt; \u0026#34;析构\u0026#34; \u0026lt;\u0026lt; endl; } class rememberFree{ public: rememberFree(){ cout \u0026lt;\u0026lt; \u0026#34;成员构造\u0026#34; \u0026lt;\u0026lt; endl; } ~rememberFree(){ if(Singleton::local_instance != nullptr){ delete Singleton::local_instance; } } }; static rememberFree remember; public: static Singleton *getInstance() { pthread_mutex_lock(\u0026amp;mutex); if (local_instance == nullptr) { local_instance = new Singleton(); } pthread_mutex_unlock(\u0026amp;mutex); return local_instance; } }; Singleton * Singleton::local_instance = nullptr; pthread_mutex_t Singleton::mutex = PTHREAD_MUTEX_INITIALIZER; Singleton::rememberFree Singleton::remember; 使用双锁检查导致未初始化的内存访问 使用如下的代码来实现已经初始化的对象的直接返回。可以使上述代码性能会大大加快。但是相同的代码在Java下面有很明显的问题，由于CPU乱序执行，可能导致访问到未经初始化的对象的引用。 C++是否有同样的问题呢？看下文: http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf 结论是一样的，c++也存在相同的问题，可能导致未定义行为导致段错误。双锁检查代码的例子如下：\nstatic Singleton *getInstance() { if(local_instance == nullptr){ pthread_mutex_lock(\u0026amp;mutex); if (local_instance == nullptr) { local_instance = new Singleton(); } pthread_mutex_unlock(\u0026amp;mutex); } return local_instance; } 假如线程A进入锁内并分配对象的空间，但是由于指令可能乱序，实际上导致local_instance被先指向一块未被分配的内存，然后再在这块内存上进程初始化。但是在指向后，未初始化前，另一线程B可能通过getInstance获取到这个指针。\n尝试使用局部变量并不能保证指令执行顺序 尝试使用临时变量强制指定指令运行顺序时，仍然会被编译器认为是无用的变量，然后被优化掉。下述代码是一个想法很好但是无法实现目的代码：\nif(local_instance == nullptr){ static mutex mtx; lock_guard\u0026lt;mutex\u0026gt; lock(mtx); if (local_instance == nullptr) { auto tmp = new Singleton() local_instance = tmp; } } return local_instance; 不优雅的使用volatile来解决指令乱序在双检查锁中出现的问题 尝试使用volatile声明内部的指针，代码如下：\nclass Singleton { private: static Singleton * volatile local_instance; Singleton(){ cout \u0026lt;\u0026lt; \u0026#34;构造\u0026#34; \u0026lt;\u0026lt; endl; }; ~Singleton(){ cout \u0026lt;\u0026lt; \u0026#34;析构\u0026#34; \u0026lt;\u0026lt; endl; } class rememberFree{ public: rememberFree(){ cout \u0026lt;\u0026lt; \u0026#34;成员构造\u0026#34; \u0026lt;\u0026lt; endl; } ~rememberFree(){ if(Singleton::local_instance != nullptr){ delete Singleton::local_instance; } } }; static rememberFree remember; public: static Singleton *getInstance() { if(local_instance == nullptr){ static mutex mtx; lock_guard\u0026lt;mutex\u0026gt; lock(mtx); if (local_instance == nullptr) { auto tmp = new Singleton(); local_instance = tmp; } } return local_instance; } }; Singleton * volatile Singleton::local_instance = nullptr; Singleton::rememberFree Singleton::remember; int main() { cout \u0026lt;\u0026lt; \u0026#34;单例模式访问第一次前\u0026#34; \u0026lt;\u0026lt; endl; Singleton * s = Singleton::getInstance(); cout \u0026lt;\u0026lt; \u0026#34;单例模式访问第一次后\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;单例模式访问第二次前\u0026#34; \u0026lt;\u0026lt; endl; Singleton * s2 = Singleton::getInstance(); cout \u0026lt;\u0026lt; \u0026#34;单例模式访问第二次后\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 在这份代码中，虽然temp是volatile，但是*temp不是，其成员也不是。所以仍然可能被优化。尝试将其*temp也声明为volatile，你会发现的的代码充满了volatile。但是至少是正确的：\nclass Singleton { private: static volatile Singleton * volatile local_instance; Singleton(){ cout \u0026lt;\u0026lt; \u0026#34;构造\u0026#34; \u0026lt;\u0026lt; endl; }; ~Singleton(){ cout \u0026lt;\u0026lt; \u0026#34;析构\u0026#34; \u0026lt;\u0026lt; endl; } class rememberFree{ public: rememberFree(){ cout \u0026lt;\u0026lt; \u0026#34;成员构造\u0026#34; \u0026lt;\u0026lt; endl; } ~rememberFree(){ if(Singleton::local_instance != nullptr){ delete Singleton::local_instance; } } }; static rememberFree remember; public: static volatile Singleton *getInstance() { if(local_instance == nullptr){ static mutex mtx; lock_guard\u0026lt;mutex\u0026gt; lock(mtx); if (local_instance == nullptr) { auto tmp = new Singleton(); local_instance = tmp; } } return local_instance; } }; volatile Singleton * volatile Singleton::local_instance = nullptr; Singleton::rememberFree Singleton::remember; int main() { cout \u0026lt;\u0026lt; \u0026#34;单例模式访问第一次前\u0026#34; \u0026lt;\u0026lt; endl; volatile Singleton * s = Singleton::getInstance(); cout \u0026lt;\u0026lt; \u0026#34;单例模式访问第一次后\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;单例模式访问第二次前\u0026#34; \u0026lt;\u0026lt; endl; volatile Singleton * s2 = Singleton::getInstance(); cout \u0026lt;\u0026lt; \u0026#34;单例模式访问第二次后\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 大杀器——内存栅栏 在新的标准中，atomic类实现了内存栅栏，使得多个核心访问内存时可控。这利用了c++11的内存访问顺序可控。下面是代码实现：\nclass Singleton { private: // static volatile Singleton * volatile local_instance; static atomic\u0026lt;Singleton*\u0026gt; instance; Singleton(){ cout \u0026lt;\u0026lt; \u0026#34;构造\u0026#34; \u0026lt;\u0026lt; endl; }; ~Singleton(){ cout \u0026lt;\u0026lt; \u0026#34;析构\u0026#34; \u0026lt;\u0026lt; endl; } class rememberFree{ public: rememberFree(){ cout \u0026lt;\u0026lt; \u0026#34;成员构造\u0026#34; \u0026lt;\u0026lt; endl; } ~rememberFree(){ Singleton* local_instance = instance.load(std::memory_order_relaxed); if(local_instance != nullptr){ delete local_instance; } } }; static rememberFree remember; public: static Singleton *getInstance() { Singleton* tmp = instance.load(std::memory_order_relaxed); atomic_thread_fence(memory_order_acquire); if(tmp == nullptr){ static mutex mtx; lock_guard\u0026lt;mutex\u0026gt; lock(mtx); tmp = instance.load(memory_order_relaxed); if (tmp == nullptr) { tmp = new Singleton(); atomic_thread_fence(memory_order_release); instance.store(tmp, memory_order_relaxed); } } return tmp; } }; atomic\u0026lt;Singleton*\u0026gt; Singleton::instance; Singleton::rememberFree Singleton::remember; int main() { cout \u0026lt;\u0026lt; \u0026#34;单例模式访问第一次前\u0026#34; \u0026lt;\u0026lt; endl; Singleton * s = Singleton::getInstance(); cout \u0026lt;\u0026lt; \u0026#34;单例模式访问第一次后\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;单例模式访问第二次前\u0026#34; \u0026lt;\u0026lt; endl; Singleton * s2 = Singleton::getInstance(); cout \u0026lt;\u0026lt; \u0026#34;单例模式访问第二次后\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 上述代码可能难以阅读，instance的两次加载可以被乱序执行。但是在此期间内的改动被其他CPU核心观察不到。在muduo一书上，内存栅栏也被评价为大杀器。\n使用原子操作的内存顺序 这里有六个内存序列选项可应用于对原子类型的操作：memory_order_relaxed, memory_order_consume, memory_order_acquire, memory_order_release, memory_order_acq_rel, 以及memory_order_seq_cst。除非你为特定的操作指定一个序列选项，要不内存序列选项对于所有原子类型默认都是memory_order_seq_cst。虽然有六个选项，但是它们仅代表三种内存模型：排序一致序列(sequentially consistent)，获取-释放序列(memory_order_consume, memory_order_acquire, memory_order_release和memory_order_acq_rel)，和自由序列(memory_order_relaxed)。\n这里可以采用的模型有：默认的memory_order_seq_cst即顺序一致与memory_order_acquire、memory_order_release即获取释放序列。后者性能可能更好。\n待完善\n使用pthread_once 或者call_once 前者来自pthread库。后者来自std::atomic。\n待完善\n","date":"2018-05-07T06:15:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/c++%E5%AE%8C%E7%BE%8E%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","title":"C++完美单例模式"},{"content":"从例子入手。\n#include \u0026lt;stdio.h\u0026gt; void my_itoa(int n,char s[]) { int i,j,sign; if((sign=n)\u0026lt;0) //记录符号 n=-n; //使n成为正数 i=0; do{ s[i++]=n%10+\u0026#39;0\u0026#39;; //取下一个数字 }while((n/=10)\u0026gt;0); //循环相除 if(sign\u0026lt;0) s[i++]=\u0026#39;-\u0026#39;; s[i]=\u0026#39;\\0\u0026#39;; for(j=i-1;j\u0026gt;=0;j--) //生成的数字是逆序的，所以要逆序输出 printf(\u0026#34;%c\u0026#34;,s[j]); } void main() { int n; char str[100]; my_itoa(-123,str); printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;%d\\n\u0026#34;,my_atoi(\u0026#34;123\u0026#34;)); system(\u0026#34;pause\u0026#34;); } 将上述文件保存到test.cpp文件，然后编译运行。\n然后我们来调试一下，看看具体应该怎么调试。按照下面的方式来调试代码。\nlinan@linan-PC:~$ gdb test GNU gdb (Debian 7.12-6) 7.12.0.20161007-git Copyright (C) 2016 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u0026lt;http://gnu.org/licenses/gpl.html\u0026gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \u0026#34;show copying\u0026#34; and \u0026#34;show warranty\u0026#34; for details. This GDB was configured as \u0026#34;x86_64-linux-gnu\u0026#34;. Type \u0026#34;show configuration\u0026#34; for configuration details. For bug reporting instructions, please see: \u0026lt;http://www.gnu.org/software/gdb/bugs/\u0026gt;. Find the GDB manual and other documentation resources online at: \u0026lt;http://www.gnu.org/software/gdb/documentation/\u0026gt;. For help, type \u0026#34;help\u0026#34;. Type \u0026#34;apropos word\u0026#34; to search for commands related to \u0026#34;word\u0026#34;... Reading symbols from test...done. (gdb) l 2\t3\tint func(int n) 4\t{ 5\tint sum=0,i; 6\tfor(i=0; i\u0026lt;n; i++) 7\t{ 8\tsum+=i; 9\t} 10\treturn sum; 11\t} (gdb) 12\t13\tmain() 14\t{ 15\tint i; 16\tlong result = 0; 17\tfor(i=1; i\u0026lt;=100; i++) 18\t{ 19\tresult += i; 20\t} 21\t(gdb) 22\tprintf(\u0026#34;result[1-100] = %d \\n\u0026#34;, result ); 23\tprintf(\u0026#34;result[1-250] = %d \\n\u0026#34;, func(250) ); 24\t} (gdb) Line number 25 out of range; test.cpp has 24 lines. (gdb) break 15 Breakpoint 1 at 0x706: file test.cpp, line 15. (gdb) break func Breakpoint 2 at 0x6d7: file test.cpp, line 5. (gdb) info break Num Type Disp Enb Address What 1 breakpoint keep y 0x0000000000000706 in main() at test.cpp:15 2 breakpoint keep y 0x00000000000006d7 in func(int) at test.cpp:5 (gdb) run Starting program: /home/linan/test Breakpoint 1, main () at test.cpp:16 16\tlong result = 0; (gdb) next 17\tfor(i=1; i\u0026lt;=100; i++) (gdb) next 19\tresult += i; (gdb) next 17\tfor(i=1; i\u0026lt;=100; i++) (gdb) continue Continuing. result[1-100] = 5050 Breakpoint 2, func (n=250) at test.cpp:5 5\tint sum=0,i; (gdb) p sum $1 = 32767 (gdb) n 6\tfor(i=0; i\u0026lt;n; i++) (gdb) p sum $2 = 0 (gdb) p i $3 = -134225552 (gdb) print i $4 = -134225552 (gdb) n 8\tsum+=i; (gdb) print i $5 = 0 (gdb) bt #0 func (n=250) at test.cpp:8 #1 0x000055555555474c in main () at test.cpp:23 (gdb) help bt Print backtrace of all stack frames, or innermost COUNT frames. With a negative argument, print outermost -COUNT frames. Use of the \u0026#39;full\u0026#39; qualifier also prints the values of the local variables. Use of the \u0026#39;no-filters\u0026#39; qualifier prohibits frame filters from executing on this backtrace. (gdb) bt #0 func (n=250) at test.cpp:8 #1 0x000055555555474c in main () at test.cpp:23 (gdb) finish Run till exit from #0 func (n=250) at test.cpp:8 0x000055555555474c in main () at test.cpp:23 23\tprintf(\u0026#34;result[1-250] = %d \\n\u0026#34;, func(250) ); Value returned is $6 = 31125 (gdb) c Continuing. result[1-250] = 31125 [Inferior 1 (process 11480) exited normally] (gdb) 使用GDB之前 首先确保你的程序在编译时使用了-g参数。这样才能将相关信息插入到可执行程序中。这些相关信息对程序是没有帮助的，但是对调试有帮助。\n使用GDB启动调试 启动GDB的方法有以下几种：\ngdb program也就是你的执行文件，一般在当然目录下。\ngdb core 用gdb同时调试一个运行程序和core文件，core是程序非法执行后core dump后产生的文件。\ngdb 如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动 attach 上去，并调试他。program应该在PATH环境变量中搜索得到。\n使用GDB的新手注意事项 GDB调试的时候需要知道源码的文件在哪里，在上面的例子中，源码和运行程序在一起。但是实际中不可能这样。在GDB命令加入参数-d或者在运行时使用direcotry 命令来添加源码目录。\n其他注意点：\n-symbols \u0026lt;file\u0026gt; -s \u0026lt;file\u0026gt; 从指定文件中读取符号表。 -se file 从指定文件中读取符号表信息，并把他用在可执行文件中。 -core \u0026lt;file\u0026gt; -c \u0026lt;file\u0026gt; 调试时core dump的core文件。 ","date":"2018-04-25T16:45:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/c++/gdb-%E4%BB%8E%E9%9B%B6%E5%AD%A6%E4%B9%A0/","title":"GDB从零学习"},{"content":"第一章 从 C 到 C++ 条款1 C++是语言联邦 这条意思是C++支持面向过程、面向对象、泛型编程、函数编程、元编程五中编程方式，但是会令人困惑。所以他是一门综合语言。\n条款2 const enum inline 代替 define define不是语言的一部分，而是预处理的部分。const enum inline可以被编译器发现错误\n条款3 使用const来限制出错的可能 例如返回const引用对象来防止用户修改。使用const成员函数来防止对类的破坏。\n条款4 使用对象前确保已经初始化 主要是使用参数初始化列表初始化成员或者父类。另外如果类使用了全局的对象，则无法知道什么时候初始化的这个对象。所以需要使用类内部的static变量。（也是只有一份）\n第二章 有关对象的构造与析构 条款5 了解对象的默认成员函数 编译器会根据需要的时候，默认生成的成员函数包括默认构造函数，拷贝构造函数，析构函数，拷贝赋值函数。 其中，默认拷贝赋值函数会可能无法拷贝引用成员。\n条款6 使用=delete来拒绝默认生成的成员函数 这个可以防止类被拷贝，组织拷贝\n条款7 为多态基类声明virtual析构函数 这个是基本功了。\n条款8 析构函数不要抛出异常 这个可能导致内存释放不完全，或者导致抛出多个异常\n条款9 构造函数和析构函数中中不调用虚函数 这条也比较明显，派生类的构造函数如果进入到基类构造函数中，调用了虚函数，此时派生类的虚函数还没有准备好。\n条款10 operator = 应该返回对象的引用 这样就可以连续赋值了\n条款11 在operator = 处理自我赋值 很难保证你的自我赋值代码没有问题，而且自我赋值是浪费时间的行为。\n条款12 复制对象时记得复制每一个部分 这个很显然了。你要实现赋值函数，那么就必须拷贝所有内容。\n第三章 有关对象的持有资源 条款13 对象是持有资源的基本单位 要能够获取资源，还要能够正确释放资源。关键在于使用shared_ptr来管理内存。可以自动释放持有的资源\n条款14 持有资源的对象复制 要么禁止复制，要么使用shared_ptr成员，要么进行深度拷贝，要么使拷贝过程变为资源的转移。\n条款15 持有资源的对象需要提供一个原始对象的方法 这个世界并不完美，许多APIs需要传递原始资源的指针才可以。使用shared_ptr会干扰这个对象的使用方式\n条款16 new数组对象的时候需要delete 为了避免这种错误，可以使用vector容器来进行操作，避免对new数组的需求\n条款17 new对象作为参数传入式可能导致内存泄漏 假如new对象和参数传入shared_ptr中间抛出了异常，那么就会导致内存泄漏\n第四章 设计与声明 条款18 让接口容易被正确使用 接口有的时候难以表述清楚，比如传入三个int值，你得清楚的记得这三个值每一个到底是什么。如果传入的参数反了怎么办？这里书上提到了传入特定对象以及使用explicit来限定参数。其实也可以构建一个日期对象，然后指定成员，我感觉这种还好一点。另外，接口除了参数要设置的合理，返回值也要设置的合理（比如返回智能指针而不是原始指针强迫对方）。\n条款19 设计class是个大工程 对象的创建、销毁，对象初始化与对象赋值，对象通过值拷贝传递会异常吗，新type的合法值是什么。类型转换函数写了吗。operator呢。哪些函数应该被delete？\n条款20 传递常量引用代替传值 传值会带来对象的构造函数的调用，消耗时间，传递引用就是传递指针\n条款21 返回临时对象时无法返回对临时对象的引用 如果返回一个由函数创建的对象时，无法返回对该对象的引用。编译器会自己做出正确的优化步骤。\n条款22 成员变量应该声明为private 如果声明为public，那么删除这个变量会导致所有程序重写。如果声明为private，那么删除这个变量会导致继承类程序重写。所以要声明为private\n条款23 使用非成员函数替换成员函数 如果一个方法只是调用了其他几个成员函数，没有必要将其设置为成员函数，把他放在外面，然后用相同的命名空间包裹就可以了\n条款24 如果成员函数的参数需要支持类型转换，则将其转为非成员函数 这是因为成员函数在某些情况下可能无法发挥作用。比如operator *只能支持该类型作为第一个参数。如果内置类型作为第一个参数的时候就会失效。\n条款25 swap函数与异常 swap是个有用的函数。为了实现高效率的swap，你需要设计一个swap成员函数来与另外一个对象进行交换。然后再命名空间设计一个非成员函数雨来调用上面的swap函数。最后特化std::swap来让编译器选择你自己的swap\n第五章 有关函数的实现 条款26 延迟定义出现的顺序 C++对于不同行的顺序不能随意更改其顺序，这意味着只有用到什么再去定义什么更能符合过程，如果在刚开始就将所有的定义，但是程序一开始就返回，这就会带来不必要的构造与析构过程。\n条款27 避免类型转换 四种c++类型转换的使用场景虽然可以使用，但是如果使用了都会带来更大的问题。旧式的类型转换就更不能用了。\n条款28 避免返回handles指向对象内部成分 尽量避免对象内部的数据的指针被返回到对象外部，这会带来很大的问题。vector []运算符就是这种情况。这种情况是特例\n条款29 异常安全 C++异常是最难以处理的一件事情了。但是还是要保证异常。\n条款30 了解inline inline是让编译器尽量避免栈的展开，而不是一定。八二法则告诉我们，程序只会花时间在20%的代码上，不一定见了函数就要都用inline。\n条款31 减少依赖——定义与声明相分离 两种处理方式——实施类与接口类。实施类就是使用另一个类来代理实现该类的功能。接口类就是使用面向对象的方法来将该类设计为接口。\n第六章 面向对象设计 条款32 public继承意味着is-a关系 这意味着所有基类能够办到的事情派生类也能办到。但是派生类能够办到的基类不一定能办到\n条款33 继承时会发生名称遮掩 如果在派生类中声明了父类函数的另一个重载版本，会将父类的原始版本也一并覆盖，使得无法正确的链接到父类函数。可以使用using来表示使用父类的函数空间。\n条款34 区分接口继承和实现继承 纯虚函数是只继承接口，虚函数继承接口和默认实现，非虚函数是继承接口和强制实现\n条款35 不是只有虚函数一种实现 可以使用其他设计模式来代替虚函数的实现，例如仿函数\n条款36 不要重新定义非虚函数 省的到时候你都不知道具体是哪个被调用了。没错说的就是析构函数。\n条款37 不要重新定义缺省参数 这是因为缺省参数是静态确定的而不是动态确定的。你定义的那个不一定有用\n条款38 区分复合与继承 public继承是is-a关系。复合是has-a关系。例如set的实现，如果继承list就会有一些问题了。set应该复合list。\n条款39 private继承意味着根据其实现 private的使用频率比复合使用的频率要更低。有两种情况需要这样实现，第一种情况是派生类需要访问基类的protected成员。第二种情况是需要重新定义virtual函数（这种情况难道不应该设计一种中间类吗）。\n条款40 小心的使用多重继承 多重继承使用的很少。虚继承内最好不要包含任何成员。因为虚继承的成员初始化是在派生类内完成的。\n第七章 泛型编程 条款41 了解隐式接口与编译器多态 就是静态多态。\n条款42 typename的双重含义 typename除了会在模板的template一行中使用，还会模板的处理中出现。当我们使用成员变量或者是成员类型时，编译器不知道用的是哪一个。默认使用的成员变量。加上typename来提醒编译器用的是成员类型\n条款43 继承一个模板类，对模板类内的符号要显示声明 这是因为模板类可能特化，如果特化，则可能有的符号不存在。所以需要显示的指示模板类内的符号，例如使用this指针或者是作用域\n条款44 template导致代码膨胀 template参数在传入一个非类型参数的时候，会生成多份代码。这些代码有一些方式可以避免重复生成，但是速度不如原来的快。\n条款45 运用成员函数模板接受所有兼容类型 类可以是模板的，成员函数也可以是模板的。\n条款46 需要类型转换时请为模板定义非成员函数 不仅要定义成非成员函数，还要定义成为friend函数。\n条款47 使用traits traits是使用了模板编程与特化的性质实现的一个triats类，通过triats类可以获得想要的泛化类内的数据类型。\n条款48 template元编程 元编程指的是在编译期间就知道结果的编程方法。比如在编译期间处理输入。类似于C++的hello world的程序就是阶乘。\n第八章 new 与 delete 条款49 了解new-handler的行为 就是不断尝试分配内存。我很好奇如果new-handler一直分配失败会不会出现卡死的现象。\n条款50 了解自定义new和delete的场合 貌似现在的new和delete性能都很高了。不用替换\n条款51 自定义new和delete要保持兼容性\n条款52 placement new 和placement delete placement delete会在placement new出现错误的时候自动运行\n第九章 现在的c++11 条款53 不要忽视warring\n条款54 熟悉tr1的标准程序库\n条款55 熟悉boost\n","date":"2018-04-23T10:40:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/c++/effective-c++-%E7%AC%94%E8%AE%B0/","title":"effective C++ 笔记"},{"content":"前言 提前批有两次电话一面，这里略过了。 首发于：https://www.jianshu.com/p/d5aa63a27172\n一面 成都4月11日\n介绍自己的项目、难点在哪里、怎么解决的 介绍C++11特性 介绍fork函数 介绍time_wait状态 为什么tcp连接握手需要三次 介绍迭代器失效。push_back会导致迭代器失效吗。 红黑树的特征，介绍 哈希冲突的解决方法。 进程和线程的区别 你都使用什么线程模型 介绍协程 介绍快排算法 什么是稳定性排序，快排是稳定性的吗，为什么 快排算法最差情况推导公式 析构函数虚函数为什么 构造函数为什么不能是虚函数 打印在纸上的题目，考察：new [] 对象。static 成员。子类构造函数具体调用了啥。拷贝构造函数与赋值函数的区别。等号在拷贝构造函数出现的时机。什么时候需要赋值函数。深拷贝与浅拷贝。虚函数的调用时机。 下面是其中一道题目，请写出运行结果\n#include \u0026lt;iostream\u0026gt; using namespace std; struct A{ A(){ local_var++; } virtual void func(){ cout \u0026lt;\u0026lt; \u0026#34;A\u0026#34; \u0026lt;\u0026lt; endl; } static int local_var; }; int A::local_var = 0; struct B : A{ B(){ local_var+=2; } virtual void func(){ cout \u0026lt;\u0026lt; \u0026#34;B\u0026#34; \u0026lt;\u0026lt; endl; } }; int main(){ A* a1 = new B[3]; cout \u0026lt;\u0026lt; a1[0].local_var \u0026lt;\u0026lt; endl; a1-\u0026gt;func(); A a2 = a1[0]; cout \u0026lt;\u0026lt; a2.local_var \u0026lt;\u0026lt; endl; a2.func(); A a3; a3 = a1[0]; cout \u0026lt;\u0026lt; a3.local_var \u0026lt;\u0026lt; endl; a3.func(); } 以下代码会出现什么问题。\n#include \u0026lt;iostream\u0026gt; using namespace std; struct A{ virtual void func1(){ cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } void func2(){ cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } void func3(){ cout \u0026lt;\u0026lt; \u0026#34;a\u0026#34; \u0026lt;\u0026lt; endl; } int a; }; int main(){ A * a = (A*)malloc(sizeof(A)); a-\u0026gt;func1(); a-\u0026gt;func2(); a-\u0026gt;func3(); } 笔试过程中（之前牛客笔试。面试官居然打印了我的笔试所有答案和结果，包括选择题和算法题，提交了多少次，失败了多少次）一道题的思路。考察虚指针的初始化时机。 随机出一道纸上的题目。给定前序遍历ABC后序遍历CBA，求中序遍历是什么，画出来两种情况。 笔试过程中（之前牛客笔试），第一道算法题的思路 有100个弹珠，双方轮流拿，每个人只能拿1~5个，无法拿的人输，必胜解法。 最近学什么（服务器编程）。之前学什么（TensorFlow），怎么学习的。你对Tensorflow强大的神经网络是怎么看待的。 家庭情况了解。 离开后在大厅手写代码，求char a数组中有的元素和char b数组中没有的元素，放到char c数组。这里我忘记把char字符转成unsigned char类型。 二面 成都4月13日\n自我介绍 系统调用是什么。你用过哪些系统调用。什么系统调用会耗时长。 gdb调试用过吗。什么是条件断点。 函数指针和指针函数的区别。写个例子出来。 手写fork调用示例。你在哪些场合使用过fork调用。 介绍udp的connect函数。 索引是什么。多加索引一定会好吗？（索引这个承认了看面经，但是后一个问题自己想出来了） 上一次面试中，你有哪些问题你回去查了。 上一次面试中，你的代码有问题，你知道吗。 你回答的问题是从哪里学习的。你这两天在干什么？ 给你提一些建议，看下gdb调试，看下数据库知识，看下网络编程，多实践。 后续 4月20日收到腾讯的电话offer确认。\n","date":"2018-04-11T08:39:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/%E8%85%BE%E8%AE%AF%E6%A0%A1%E6%8B%9B%E9%9A%8F%E7%AC%94/","title":"腾讯校招随笔"},{"content":"UDP 对于UDP协议来说，整个包的最大长度为65535，其中包头长度是65535-20=65515。\nTCP 对于TCP协议来说，整个包的最大长度是由最大传输大小（MSS，Maxitum Segment Size）决定，MSS就是TCP数据包每次能够传输的最大数据分段。为了达到最佳的传输效能TCP协议在建立连接的时候通常要协商双方的MSS值，这个值TCP协议在实现的时候往往用MTU值代替（需要减去IP数据包包头的大小20Bytes和TCP数据段的包头20Bytes）所以往往MSS为1460。通讯双方会根据双方提供的MSS值得最小值确定为这次连接的最大MSS值。\nIP 对于IP协议来说，IP包的大小由MTU决定。\n","date":"2018-03-26T16:41:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E7%BD%91%E7%BB%9C/tcp-udp-ip%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E9%95%BF%E5%BA%A6/","title":"TCP UDP IP最大报文长度"},{"content":"TCP 源端口 目标端口 序号 确认号 位标识 窗口 校验和 紧急指针 选项 数据 HTTP 请求 URL 协议版本\\r\\n 字段：值\\r\\n \\r\\n 正文 协议版本 状态码 状态码描述\\r\\n 字段：值\\r\\n \\r\\n 正文 ","date":"2018-03-26T16:37:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E7%BD%91%E7%BB%9C/tcp-%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F-http%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/","title":"TCP 报文格式 HTTP报文格式"},{"content":"TCP | 阶段 | 服务器 | 客户端 | | \u0026mdash;\u0026mdash;\u0026ndash; | \u0026mdash;\u0026ndash;: | :\u0026mdash;-: | | | socket | socket | | | bind | | | | listen | | | | accept | connect | | | write | write | | | read | read | | | close | close |\nUDP | 阶段 | 服务器 | 客户端 | | \u0026mdash;\u0026mdash;\u0026ndash; | \u0026mdash;\u0026ndash;: | :\u0026mdash;-: | | | socket | socket | | | bind | | | | sendto | recvfrom | | | recvfrom | sendto | | | close | close |\n","date":"2018-03-26T14:46:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E7%BD%91%E7%BB%9C/tcp-udp-%E9%80%9A%E8%BF%87socket%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B/","title":"TCP UDP 通过socket建立连接的过程"},{"content":"HTTPS认证过程：\n① 浏览器发送一个连接请求给安全服务器。\n② 服务器将自己的证书，以及同证书相关的信息发送给客户浏览器。\n③ 客户浏览器检查服务器送过来的证书是否是由自己信赖的 CA 中心所签发的。如果是，就继续执行协议；如果不是，客户浏览器就给客户一个警告消息：警告客户这个证书不是可以信赖的，询问客户是否需要继续。\n④ 接着客户浏览器比较证书里的消息，例如域名和公钥，与服务器刚刚发送的相关消息是否一致，如果是一致的，客户浏览器认可这个服务器的合法身份。\n⑤ 服务器要求客户发送客户自己的证书。收到后，服务器验证客户的证书，如果没有通过验证，拒绝连接；如果通过验证，服务器获得用户的公钥。\n⑥ 客户浏览器告诉服务器自己所能够支持的通讯对称密码方案。\n⑦ 服务器从客户发送过来的密码方案中，选择一种加密程度最高的密码方案，用客户的公钥加过密后通知浏览器。\n⑧ 浏览器针对这个密码方案，选择一个通话密钥，接着用服务器的公钥加过密后发送给服务器。\n⑨ 服务器接收到浏览器送过来的消息，用自己的私钥解密，获得通话密钥。\n⑩ 服务器、浏览器接下来的通讯都是用对称密码方案，对称密钥是加过密的。\n上面所述的是双向认证 SSL 协议的具体通讯过程，这种情况要求服务器和用户双方都有证书。单向认证 SSL 协议不需要客户拥有 CA 证书，具体的过程相对于上面的步骤，只需将服务器端验证客户证书的过程去掉，以及在协商对称密码方案，对称通话密钥时，服务器发送给客户的是没有加过密的 （这并不影响 SSL 过程的安全性）密码方案。这样，双方具体的通讯内容，就是加过密的数据，如果有第三方攻击，获得的只是加密的数据，第三方要获得有用的信息，就需要对加密 的数据进行解密，这时候的安全就依赖于密码方案的安全。而幸运的是，目前所用的密码方案，只要通讯密钥长度足够的长，就足够的安全。这也是我们强调要求使用128 位加密通讯的原因。\n","date":"2018-03-26T14:42:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E7%BD%91%E7%BB%9C/https-%E5%8F%8C%E5%90%91%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/","title":"HTTPS 双向加密过程分析"},{"content":"今天下午在刷牛客。忽然想看看腾讯的内推进展如何，微信公众号结果显示，目前的岗位可能并不适合你。\n并没有什么特殊的感想。\n还需要努力，争取一个好的结果吧。无论如何，还是有机会的。\n下午刷题，网易的8道题目有3道不会做，感觉确实有很多要学习的点。\n买了一堆书，不知道什么时候才能看完。\n总之还是要乐观一点。\n面试官说我挺适合的，虽然那是可能还是挺开心的，但是我不会因为我被抛弃了而伤心，也不会因为我被选择了而骄傲。\n","date":"2018-03-26T12:23:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/%E8%85%BE%E8%AE%AF%E5%86%85%E6%8E%A8%E9%9A%8F%E7%AC%94/","title":"腾讯内推随笔"},{"content":" 小Q非常富有，拥有非常多的硬币，小Q的拥有的硬币是有规律的，对于所有的非负整数K,小Q恰好\u0026gt; 各有两个数值为2^k，的硬币，所以小Q拥有的硬币是1，1，2，2，4，4……，小Q卖东西需要支付元钱，请问小Q想知道有多少种组合方案。 输入：一个n (1\u0026lt;=n\u0026lt;=10^18),代表要付的钱 输出：表示小Q可以拼凑的方案数目\n参考答案\n#coding=utf-8 import math n = int(input()) def getMaxCoin(n): tmp = int(math.log(n,2)) return 2**tmp buff = {} def dp(n, coin): if (n, coin) in buff: return buff[(n,coin)] if n == 0: # 找0块钱，必然可以 return 1 if coin == 1: # 只用1元找 if n == 1 or n == 2: return 1 return 0 # 当前面值无解 if n \u0026gt; coin * 4 -2: return 0 ret = 0 # 只用了一枚 if n \u0026gt;= coin: ret += dp(n-coin, coin//2) if n \u0026gt;= coin*2: # 用了两枚 ret += dp(n-coin*2, coin//2) # 没有用 ret += dp(n, coin//2) buff[(n,coin)] = ret return ret print(dp(n,getMaxCoin(n))) 思路： 对于当前的面额，最大可能用到的硬币面额可以通过getMaxCoin函数计算得到。 对于问题面额n和可以使用的最大硬币面额，求dp(n, coin)的值。 coin会不断减小，对于coin为1时，面额为1或2只有1种情况。对于面额为0时，不需要硬币就可以有解。对于面额大于coin*4-2时，超过了能找的上限，无解。对于其他情况，分三种情况，coin用了一枚，coin用了两枚，coin用了零枚。分别计算对应的dp值即可。使用buff缓存已经计算出来的面值。\n","date":"2018-03-26T03:57:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E7%AE%97%E6%B3%95/%E8%85%BE%E8%AE%AF%E6%A8%A1%E6%8B%9F%E8%80%83%E8%AF%95%E4%B9%8B%E6%89%BE%E9%9B%B6%E9%97%AE%E9%A2%98/","title":"腾讯模拟考试之找零问题"},{"content":"前言 留白\n尝试 在大一的时候，我记得当时参加了一个学院的比赛，这是我第一次接触到有关编程的概念。\n这个比赛是通过该实验室提供的带有编程功能的积木与玩具，搭建出一个作品。有点类似于米兔机器人一样的概念，只不过当时时间比较早而已。\n我搭建了一个智能的小车，它能够按照地面上的黑色胶带的轨迹来行动，然后做出相应的动作。他拥有以下三个功能：\n按照地面上的单线胶带行动。该功能是通过两个红外传感器实现的。 遇到障碍可以按照事先约定好的动作绕过障碍。通过一个红外传感器实现。 可以用爪子抓取地面上的乒乓球。通过一个电机带动行动。 我记得当时的编程界面是通过一个图形界面操作的，这个程序中可以拖动不同的矩形，代表程序体。然后用连线来表示状态的转移。编写好代码，需要通过红外线装置传输到可编程积木中。红外线的传输装置有点像立起来的熨斗，积木很大一块，可以安装锂电池，上面有一些齿轮状的物体，可以将其他的轮胎或者是滑动装置安装上去。这样整个装置就可以按照你的期望运动了。\n我记得当时评比的时候，除了我自己的作品外，没有一个队伍的作品能够动起来（就是没有写程序）。\n其他队伍在介绍自己的机器人的时候，只是介绍了功能，但是很遗憾，动不了。\n轮到我介绍的时候，确实惊艳了全场，评委老师很惊奇的看到我的机器人能动。\n实际上，这个内置的程序是掉电消失的，并且，由于积木很老了，里面的锂电池根本就撑不了多久。我在基地写好程序，拿到比赛现场，为了防止程序丢失，我找了充电器。因为在运行的时候，不带充电线的锂电池会瞬间掉电，然后程序消失。所以能动起来也很幸运。\n我本来就没期待什么，我感觉只是按照自己的想法实现了这个小作品。后来宣布第一名的时候，居然不是我。我没有觉得很失落，毕竟也是很好玩的。只是上去领奖的那个人不是我，这让在场的所有人都感到十分的诧异。\n然后颁奖人员说弄错了，最后我还是获得了第一名。\n失败 学校要举行一个电子设计竞赛，面向全校人员开放。\n我看了比赛的题目，然后觉得可以尝试一下。我在百度上找到了类似的题目。内容是需要一系列的电子原件，焊接在一起，然后烧录所需要的程序，程序已经提供了。\n对于当时的我，那堆代码就是一堆乱码。\n我去了杭州电子市场，我在无数家商铺中穿梭，商店主人一个个看我感觉就像是异人一样。\n我笨拙着说出我想要的电子原件。商店主人好心的送了我一些LED小灯泡。\n她还说电烙铁要用扁头的，尖头的初学者用不好。\n他们很好奇我到底要做什么。\n原件买回来了，我坐在地板上，按照那篇博客给的电路图，在椅子上将东西焊好了。\n噢，对了，那个时候我也没有学过电路图，所以我只是按照想法焊好的。\n我觉得那时候的我挺单纯的，没有一点基础还想把东西焊出来。但是我却没有资格嘲笑他。\n然后开始烧录程序，我把单芯片放到了插座上，然后又把插座接上电源，开始用软件把那篇博客提供的程序尝试下载到芯片中。\n我其实想对他说，嘿，你确定这个网站提供的固件程序和你的芯片型号一致吗？芯片好烫，其实你插反了你知道吗，芯片估计已经被你烧毁了。\n然而我什么都不知道，我傻傻的拿着一个不知道什么原件焊出来的玩意和一个其实已经烧毁的芯片去参加评比，可想而知，我被评审专家鄙视了。\n然而我不知道的是，几乎没有像我这样的人去报名参加比赛。学校有一个电子设计竞赛实验班，在这个班上可以学习到所有你想学习的有关电子设计的知识。\n虽然比赛是面向全校的，但是报名的也只有这个实验班的会报名。\n我的第一个程序 后来我才明白有电子设计班的存在。大二我报名了，我记得有一个考试和面试，通过才能进入。\n我记得当时他们问了几个问题，我都答不上来。后来问我C语言成绩是多少，我说97，然后就说可以，你通过了。\n第一个星期主要讲焊接的基本知识。虽然似乎故事才刚刚开始，然而我的这篇文章要讲的故事也快要结束了。\n第二个星期主要讲LED数码管的知识，我拿到了发的51开发板。晚上，我在寝室里学习让数码管按照自己的想法亮起来。\n我学习了怎么显示数字，是常亮的，我明白了原来是先要位选然后段选，我突然明白了很多，这就是最最原始的时间分片法吧。\n我突然有一个想法，我想让数码管实现跑马灯的效果，就是外面的一圈不断的转圈圈。\n我写也写，写呀写。\n我写出来了。\n烧进去，运行，居然和我想象的一样，外面的一圈转呀转，真的很好看。我很开心。\n后记 也许那算不上我写的第一个程序，毕竟在那之前，C语言课也要求设计程序，那我应该已经写过程序了。\n然而对我而言，那个跑马灯，才是对我真正意义上的第一个程序，完全由我创造。\n就算有一天我死了，如果我写的程序能够运行下去，我可以以另一种方式来延续自己的生命。\n","date":"2018-03-21T08:06:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/","title":"我的第一个程序"},{"content":"前言 C++中在以往版本中不支持线程。需要使用pthread之类的使用线程。如果能够使用C++自身的线程则可以使程序变得统一简洁。\n头文件 该头文件包含有std::thread类与std::this_thread类。以及管理线程的函数。是实现线程的主要文件。 该头文件包含有std::atomic和std::atomic_flag类，是实现原子操作的的主要文件。 包含互斥相关的类与函数。 包含有future类及相关的函数。 \u0026lt;condition_variable\u0026gt; 包含有条件变量的类。 以上就是c++11 的线程部分了。虽然有关pthread与c++ thread有很多争议，但是对于跨平台的c++ thread来说，似乎更为标准一些。\n推荐此书来学习c++11的线程。 https://www.gitbook.com/book/chenxiaowei/cpp_concurrency_in_action/details\nhello world 线程 简单认识thread类\n#include \u0026lt;thread\u0026gt; using namespace std; // 下面这个函数是一个我们想要运行的线程任务 void hello() { printf(\u0026#34;%s\u0026#34;, \u0026#34;hello\\n\u0026#34;); } // 使用thread类，传入一个函数作为我们的初始任务。不仅如此，还能传入类等其他的参数 int main() { thread t(hello); // 使用join来等待结束 t.join(); } 除了join来等待结束，可以使用detach来不等待线程结束。\nstruct func { int\u0026amp; i; func(int\u0026amp; i_) : i(i_) {} void operator() () { for (unsigned j=0 ; j\u0026lt;1000000 ; ++j) { do_something(i); // 1. 潜在访问隐患：悬空引用 } } }; void oops() { int some_local_state=0; func my_func(some_local_state); std::thread my_thread(my_func); my_thread.detach(); // 2. 不等待线程结束 } // 3. 新线程可能还在运行 这个例子中，已经决定不等待线程结束(使用了detach()②)，所以当oops()函数执行完成时③，新线程中的函数可能还在运行。如果线程还在运行，它就会去调用do_something(i)函数①，这时就会访问已经销毁的变量。如同一个单线程程序——允许在函数完成后继续持有局部变量的指针或引用；当然，这从来就不是一个好主意——这种情况发生时，错误并不明显，会使多线程更容易出错。\n如何等待线程结束？ 如果需要等待线程，相关的std::thread实例需要使用join()。清单2.1中，将my_thread.detach()替换为my_thread.join()，就可以确保局部变量在线程完成后，才被销毁。在这种情况下，因为原始线程在其生命周期中并没有做什么事，使得用一个独立的线程去执行函数变得收益甚微，但在实际编程中，原始线程要么有自己的工作要做；要么会启动多个子线程来做一些有用的工作，并等待这些线程结束。\njoin()是简单粗暴的等待线程完成或不等待。当你需要对等待中的线程有更灵活的控制时，比如，看一下某个线程是否结束，或者只等待一段时间(超过时间就判定为超时)。想要做到这些，你需要使用其他机制来完成，比如条件变量和期待(futures)。调用join()的行为，还清理了线程相关的存储部分，这样std::thread对象将不再与已经完成的线程有任何关联。这意味着，只能对一个线程使用一次join();一旦已经使用过join()，std::thread对象就不能再次加入了，当对其使用joinable()时，将返回false。\n向线程传递参数 void f(int i, std::string const\u0026amp; s); std::thread t(f, 3, \u0026#34;hello\u0026#34;); 代码创建了一个调用f(3, \u0026ldquo;hello\u0026rdquo;)的线程。注意，函数f需要一个std::string对象作为第二个参数，但这里使用的是字符串的字面值，也就是char const *类型。之后，在线程的上下文中完成字面值向std::string对象的转化。\n需要注意的是，构造函数无视函数期待的参数类型，并盲目的拷贝已提供的变量。\n例如一：\nvoid f(int i,std::string const\u0026amp; s); void oops(int some_param) { char buffer[1024]; // 1 sprintf(buffer, \u0026#34;%i\u0026#34;,some_param); std::thread t(f,3,buffer); // 2 t.detach(); } 这种情况下，buffer②是一个指针变量，指向本地变量，然后本地变量通过buffer传递到新线程中②。并且，函数有很有可能会在字面值转化成std::string对象之前崩溃(oops)，从而导致一些未定义的行为。并且想要依赖隐式转换将字面值转换为函数期待的std::string对象，但因std::thread的构造函数会复制提供的变量，就只复制了没有转换成期望类型的字符串字面值。 解决方案就是在传递到std::thread构造函数之前就将字面值转化为std::string对象：\nvoid f(int i,std::string const\u0026amp; s); void not_oops(int some_param) { char buffer[1024]; sprintf(buffer,\u0026#34;%i\u0026#34;,some_param); std::thread t(f,3,std::string(buffer)); // 使用std::string，避免悬垂指针 t.detach(); } 例如二： 还可能遇到相反的情况：期望传递一个引用，但整个对象被复制了。当线程更新一个引用传递的数据结构时，这种情况就可能发生，比如：\nvoid update_data_for_widget(widget_id w,widget_data\u0026amp; data); // 1 void oops_again(widget_id w) { widget_data data; std::thread t(update_data_for_widget,w,data); // 2 display_status(); t.join(); process_widget_data(data); // 3 } 使用互斥 C++中通过实例化std::mutex创建互斥量，通过调用成员函数lock()进行上锁，unlock()进行解锁。不过，不推荐实践中直接去调用成员函数，因为调用成员函数就意味着，必须记住在每个函数出口都要去调用unlock()，也包括异常的情况。C++标准库为互斥量提供了一个RAII语法的模板类std::lock_guard，其会在构造的时候提供已锁的互斥量，并在析构的时候进行解锁，从而保证了一个已锁的互斥量总是会被正确的解锁。下面的程序清单中，展示了如何在多线程程序中，使用std::mutex构造的std::lock_guard实例，对一个列表进行访问保护。std::mutex和std::lock_guard都在头文件中声明。\n#include \u0026lt;list\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;algorithm\u0026gt; std::list\u0026lt;int\u0026gt; some_list; // 1 std::mutex some_mutex; // 2 void add_to_list(int new_value) { std::lock_guard\u0026lt;std::mutex\u0026gt; guard(some_mutex); // 3 some_list.push_back(new_value); } bool list_contains(int value_to_find) { std::lock_guard\u0026lt;std::mutex\u0026gt; guard(some_mutex); // 4 return std::find(some_list.begin(),some_list.end(),value_to_find) != some_list.end(); } 当其中一个成员函数返回的是保护数据的指针或引用时，会破坏对数据的保护。具有访问能力的指针或引用可以访问(并可能修改)被保护的数据，而不会被互斥锁限制。互斥量保护的数据需要对接口的设计相当谨慎，要确保互斥量能锁住任何对保护数据的访问，并且不留后门。\n使用锁 试想有一个玩具，这个玩具由两部分组成，必须拿到这两个部分，才能够玩。例如，一个玩具鼓，需要一个鼓锤和一个鼓才能玩。现在有两个小孩，他们都很喜欢玩这个玩具。当其中一个孩子拿到了鼓和鼓锤时，那就可以尽情的玩耍了。当另一孩子想要玩，他就得等待另一孩子玩完才行。再试想，鼓和鼓锤被放在不同的玩具箱里，并且两个孩子在同一时间里都想要去敲鼓。之后，他们就去玩具箱里面找这个鼓。其中一个找到了鼓，并且另外一个找到了鼓锤。现在问题就来了，除非其中一个孩子决定让另一个先玩，他可以把自己的那部分给另外一个孩子；但当他们都紧握着自己所有的部分而不给予，那么这个鼓谁都没法玩。\n很幸运，C++标准库有办法解决这个问题，std::lock——可以一次性锁住多个(两个以上)的互斥量，并且没有副作用(死锁风险)。\n如何避免死锁？\n避免嵌套锁 第一个建议往往是最简单的：一个线程已获得一个锁时，再别去获取第二个。如果能坚持这个建议，因为每个线程只持有一个锁，锁上就不会产生死锁。\n使用固定顺序获取锁 当硬性条件要求你获取两个以上(包括两个)的锁，并且不能使用std::lock单独操作来获取它们;那么最好在每个线程上，用固定的顺序获取它们获取它们(锁)。\n同步等待 假设你在旅游，而且正在一辆在夜间运行的火车上。在夜间，如何在正确的站点下车呢？一种方法是整晚都要醒着，然后注意到了哪一站。这样，你就不会错过你要到达的站点，但是这样会让你感到很疲倦。另外，你可以看一下时间表，估计一下火车到达目的地的时间，然后在一个稍早的时间点上设置闹铃，然后你就可以安心的睡会了。这个方法听起来也很不错，也没有错过你要下车的站点，但是当火车晚点的时候，你就要被过早的叫醒了。当然，闹钟的电池也可能会没电了，并导致你睡过站。理想的方式是，无论是早或晚，只要当火车到站的时候，有人或其他东西能把你唤醒，就好了。\nC++标准库对条件变量有两套实现：std::condition_variable和std::condition_variable_any。这两个实现都包含在\u0026lt;condition_variable\u0026gt;头文件的声明中。两者都需要与一个互斥量一起才能工作(互斥量是为了同步)；前者仅限于与std::mutex一起工作，而后者可以和任何满足最低标准的互斥量一起工作，从而加上了_any的后缀。因为std::condition_variable_any更加通用，这就可能从体积、性能，以及系统资源的使用方面产生额外的开销，所以std::condition_variable一般作为首选的类型，当对灵活性有硬性要求时，我们才会去考虑std::condition_variable_any。\n","date":"2018-03-18T08:29:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80-c++-11-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/","title":"Linux多线程服务器编程基础 C++ 11 并发编程学习"},{"content":"来源 阿里菜鸟java实习电话面试经，凉凉~！~ https://www.nowcoder.com/discuss/67251?type=2\u0026order=0\u0026pos=7\u0026page=1\n去除了java部分的题目\n用户请求在服务器是一个线程一个请求吗 这个问题搜了下有两种模型，一种是阻塞的一种是非阻塞的。现在一般使用基于IO多路复用的技术，Reactor模式，只需要一个线程或者少量线程，就可以处理大量请求。\n服务器抗压策略 这个问题就更大了。百度了一下有两点，一个是缓存，一个是分布式。网友回答了消息队列，可以减轻大量并发量突发的情况。\n很多很多个数，找到前十个 可以使用快排的变体\n堆排序时间复杂度如何计算？ n×log n，就是n次，每次从低向顶出堆要log n次\nHTTP和TCP 这个不知道问的具体是什么，可能是联系？\nTCP关闭连接四次挥手，为啥 两次fin+ack，中间插入未发送完的数据。在带有延迟ack的\n来源 网易内推（C++/C研发）offer之路 https://www.nowcoder.com/discuss/3038?type=2\u0026order=0\u0026pos=15\u0026page=4\nC++多态性都有哪些？ 多态是一种接口多种实现。静态多态和动态多态。静态多态是通过泛型编程实现的，动态多态是通过虚函数实现的。 动态绑定是怎么实现的？ 静态绑定：编译时绑定，通过对象调用 动态绑定：运行时绑定，通过地址实现 动态绑定是通过虚表实现的。 类型转换有哪些？ C风格的转换，强制类型转换，隐式类型转换。C++四种类型转换：static_cast，const_cast，dynamic_cost，reinterpret_cost。分别用于内置静态类型转换（int float）、去掉类型的const属性，用于动态类型转换（必须为父子类），重新解释类型而不做实质转换（指针强转）。 内存对齐的原则 结构体基本数据类型成员要从成员大小的整数倍开始对齐，结构体作为成员要从最宽的数据类型的整数倍对齐。结构体的大小为内部最大的成员的整数倍对齐。 模板是如何实现的？ 编译器在遇到模板声明时记住这个模板名称。在调用时根据模板传入的参数类型产生出具体的类型的代码，然后进行编译。 指针和const的用法？ const类型的指针，指向const类型的指针，指向const类型的const类型的指针。 虚函数、纯虚函数、虚函数与析构函数？为什么析构函数要定义成虚函数？ http://liaoxl.github.io/blog/20131205/virtual-destructor/ 根据这篇文章所述，意思是如果定义为虚函数并且子类也实现了的话，那么子类的析构函数和父类的析构函数都会调用。 内联函数 const 和 typedef 排序算法有哪些？快速排序怎么实现的？最好时间复杂度，平均时间复杂度。 插入、冒泡、堆排序、归并排序、桶排序、希尔排序、快速排序。 extern “C”有什么用 主要是为了调用C编写的程序。 2017暑期实习C++面经(阿里，网易游戏，腾讯等) 来源：https://www.nowcoder.com/discuss/23512?type=2\u0026amp;order=0\u0026amp;pos=20\u0026amp;page=2\nmap由什么实现的？你知道红黑树和AVL树有什么区别吗？为什么像map，set都用红黑树来实现？你有听过skip-list吗？ 用过vector.reserve()吗，vector的数组是怎么增长的？ map-reduce了解吗？ linux熟悉吗？目录权限，如644代表什么，目录如果有可执行权限代表什么？ 平时有使用vi吗？一般的linux命令熟悉吗？(如awk，grep等) 有用过gdb的调试吗？ TCP/UDP的区别，如何实现拥塞控制，如何实现可靠传输？UDP的应用？ 可靠/不可靠 字节流/报文 连接/非连接 开销大/开销小 有拥塞控制/无拥塞控制 全双工/单工 拥塞控制目的是为了防止发送的数据包超出了网络的承载能力，涉及到所有的主机和路由器。拥塞控制认为丢包是因为数据包超出了网络的承载能力，所以在发送数据包的，需要慢开始，不断地达到网络的承载能力，将拥塞窗口以指数的规律增长到慢开始门限，超出门限后，如果继续增大数据包的发送量，认为网络将会出现拥塞，所以进入拥塞避免状态，该阶段以线性的增长规模扩大拥塞窗口，直到拥塞发生。如果某个数据包在超时计时器已到仍然没有收到对方的ACK，则认为网络中出现了拥塞，此时将慢开始门限设置为当前窗口的一半，并执行慢开始算法。如果收到了对方的三个重复的确认报文，则认为对方尚未收到丢失的报文，则尽早重传未被确认的报文，而不是等到超时计时器到时时才重传，这就是快速重传。如果出现了快速重传，则不执行慢开始算法，而是将拥塞窗口设置为慢开始门限，然后执行拥塞避免，这就是快恢复。 作者：Simon_ 链接：https://www.nowcoder.com/discuss/23512?type=2\u0026amp;order=0\u0026amp;pos=20\u0026amp;page=2 来源：牛客网\n总结：\n我觉得阿里更注重项目和分布式，多线程方面的知识。网易游戏的话更注重算法和C++吧。腾讯的话就什么都问，从C++的内存结构，RTTI，到网络编程，到智力题的算法实现。同学们可以根据自己要投的公司再好好准备准备。与君共勉。\n准备实习之前刷过的书籍有《C++ primer》, 《深度探索C++对象模型》，《Effective C++》，《STL源码解析》，《剑指offer》还有就是一些网络和操作系统的书。刷了leetcode前120的题 目。\n给未来找C++研发实习的学弟学妹的一些建议：\n最好在找实习之前，先把C++ primer刷几遍，不懂的可以做个笔记，下次再看。当你看《对象模型》的时候，你会发现Primer中看不懂的知识都能在《对象模型》中迎刃而解。（关于Primer的学习方法我是参照https://www.zhihu.com/question/32087709中的第一个回答来做的） 《STL源码解析》最好也看看。面试官很喜欢问vector，map等的底层实现或者动态增长，如果不看书，关靠看博客和面经的话可能理解起来比较困难。 剑指offer是大部分公司一面的算法题，我觉得最好把每个题目都看懂吧。leetcode的话前100题确实很经典，二分查找，hash，动态规划，二叉树等的知识也可以通过刷题来巩固。 网络的话肯定是TCP/IP详解 卷1，有时间的话可以再看看Unix网络编程。时间更充裕的话最好刷一刷陈硕的《linux多线程服务器编程》，对多线程的知识会有一个了解。 最后一个建议就是越早准备越好，投递简历、面试期间只适合整理牛客网上的面经以及自己的面经，补缺补漏。毕竟面试题都是随机的，想要在面试中表现好一些，最好还是平时多积累。 C/C++后台研发 腾讯实习春招一面 凉凉~ https://www.nowcoder.com/discuss/68508?type=0\u0026order=0\u0026pos=8\u0026page=0\nvector底层的实现. 这里我说的比较多,所以他问到了insert具体做里那些事情. resize函数调用的是什么样. 扩容的情况. 进程间通信机制 管道（pipe），有名管道（FIFO） 信号（signal） 消息队列 共享内存 信号量 套接字（socket) 阿里巴巴菜鸟网络二面 http://blog.csdn.net/caishenfans/article/details/44496581\nfill和memset的区别 fill 是stl算法，会调用拷贝构造函数，如果是基础类型应该会直接按位复制。memset是c算法，就是一个字节一个字节拷贝到原始指针指向的位置。\nC++内存管理方法 RAII全称为Resource Acquisition Is Initialization 利用栈展开过程栈上对象的析构函数将被 自动调用的保证，从而正确地释放先前获取的资源。RAII只有在栈展开正常执行的前提下才能正常工作。函数调用和正常的C++异常处理流程(异常处于 try-catch块)都存在栈展开。\n智能指针的实现 当有另外一个智能指针对当前智能指针进行拷贝时，引用计数器加1。 当两个智能指针进行赋值操作时，左边的指针指向的对象引用计数减1，右边的加1。 析构时，同样引用计数减1。 当引用计数为0时，对象被回收。 重新定义了一组operator ：-\u0026gt;指针，返回原始指针的指针。解引用*T，返回原始指针的解引用。\n阿里实习电话面试经验，一个多小时 https://www.nowcoder.com/discuss/3836\n什么是二叉平衡树，如何插入节点，删除节点，说出关键步骤。 学生党如何拿到阿里技术offer：《阿里实习生面试经验（成功）》 https://yq.aliyun.com/articles/6395\n阿里C++研发实习二面和三面面经(已跪) https://www.nowcoder.com/discuss/27801?type=2\u0026order=3\u0026pos=55\u0026page=1\n实习面试总结 https://www.nowcoder.com/discuss/25302?type=2\u0026order=3\u0026pos=190\u0026page=1\n知乎牛客总结 阿里C++研发实习二面和三面面经(已跪)\n【阿里、腾讯、头条】等12家企业【C++方向】30场面试经验\n阿里校招实习一面面经\n阿里巴巴秋招再见\n百度三面（offer）\u0026amp;\u0026amp;阿里四面（进行中）\n双非大三春招实习面经\n实习面试总结\n阿里，摩根，野村，腾讯，微软，图鸭科技面经分享\n阿里四面面经 + 已成功拿到offer\n我的2016笔试面试经验(送给下一届的学弟学妹们)\n阿里巴巴2017实习面试分享（技术三面+HR面） https://www.nowcoder.com/discuss/25446\n","date":"2018-03-17T06:42:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/%E7%89%9B%E5%AE%A2%E7%BD%91%E9%9D%A2%E7%BB%8F%E9%A2%98%E7%9B%AE%E6%91%98%E6%8A%84/","title":"牛客网面经题目摘抄"},{"content":"来源 ：\nhttps://kelvinh.github.io/blog/2014/04/19/research-on-operator-new-and-delete/\nnew 与 delete代码意味着什么 Class *pc = new Class; // ... delete pc; 上面代码的第一行即为 new operator ，而第三行即为 delete operator ，代码很简单，但对编译器来说，它需要做额外的工作，将上述代码翻译为近似于下面的代码：\nvoid *p = operator new(sizeof(Class)); // 对p指向的内存调用Class的构造函数，此处无法用直观的代码展现 Class *pc = static_cast\u0026lt;Class*\u0026gt;(p); // ... pc-\u0026gt;~Class(); operator delete(pc); operator new 操作符到底做了什么，delete 操作符又做了什么？ void * operator new(std::size_t size) throw(std::bad_alloc) { if (size == 0) size = 1; void* p; while ((p = ::malloc(size)) == 0) { std::new_handler nh = std::get_new_handler(); if (nh) nh(); else throw std::bad_alloc(); } return p; } void operator delete(void* ptr) { if (ptr) ::free(ptr); } 实际上是malloc的包装，但是至少分配一个字节，并且在内存失败时会尝试获取用户设置的new_handler，如果用户事先设置了new_handler，那么会调用new_handler，否则会执行异常抛出bad_alloc。\nplacement new是什么 inline _LIBCPP_INLINE_VISIBILITY void* operator new (std::size_t, void* __p) _NOEXCEPT {return __p;} 这个是operator new的一个重载。直接返回指针的值。感觉挺没有用的。那怎么使用呢？\nvoid *buf = // 在这里为buf分配内存 Class *pc = new (buf) Class(); 上面是将buf的内存分给pc指针。其实就相当于：\n((* Class)buf)-\u0026gt;Class(); Class *pc = buf; ","date":"2018-03-14T03:52:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/c++/c++-new-%E4%B8%8E-delete/","title":"c++ new 与 delete"},{"content":"来源 https://cloud.tencent.com/developer/article/1005481\n函数简介 select 函数原型如下：\nint select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); fd_set是包含有文件描述符的集合，是一个位图，总共有n位。这意味这每次调用就会拷贝一次文件描述符集合到内核。\npoll 函数原型如下：\nint poll (struct pollfd *fds, unsigned int nfds, int timeout); 不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的数组实现。传入他的长度，以及超时。\nepoll epoll是在2.6内核中提出的，是之前的select和poll的增强版本。\nint epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)； int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); epoll_create是用于创建epoll的句柄。size是建议内核预先分配的文件描述符数目，不会限制实际运行的数目。 epoll_ctl会控制epoll的句柄，我们可以向其中添加、删除、修改文件描述符。ctl与epoll_wait相分离的机制使得只用复制一次事件集合。 epoll_wait可以用于获得从内核得到的事件的集合。\nsocket 事件 在Linux 2.6内核事件中，设置了wakeup callback机制。当socket在等待事件发生时，由内核的socket睡眠队列管理。当socket事件发生时，内核会顺序遍历socket睡眠队列上的每个process，通知该进程事件发生。通知时，会依次调用该事件的回调函数。\n最初的select select最初只是一个朴素的实现，来尝试解决多个文件描述符的检查问题。\nselect做了什么？ select调用后，做了以下事情：\n将参数传进来的文件描述符集合拷贝到内核空间 依次遍历文件描述符，查看是否有事件可读，如果可读就返回 没有可读的文件描述符，开始睡眠，等待内核socket事件发生 被唤醒，再次检查到底是哪个文件描述符发生了操作 select的问题？ 每次调用socket都会拷贝一次到内核空间，性能低下 任意一个socket被唤醒都需要遍历所有的socket，浪费时间 select的改进？ 被监控的fds集合限制为1024，1024太小了，我们希望能够有个比较大的可监控fds集合 fds集合需要从用户空间拷贝到内核空间的问题，我们希望不需要拷贝 被监控的fds中某些有数据可读的时候，我们希望通知更加精细一点，就是我们希望能够从通知中得到有可读事件的fds列表，而不是需要遍历整个fds来收集。 鸡肋的poll poll只解决了第一个问题。fds的大小是1024限制的问题。仅仅是传入的参数的接口变了而已。\n成熟的epoll epoll解决了第二个和第三个问题。\n对于第二个问题\n拆分函数调用，再细分函数调用 对于IO多路复用，我们会发现，每次调用select或poll都在重复地准备(集中处理)整个需要监控的fds集合。然而对于频繁调用的select或poll而言，fds集合的变化频率要低得多，我们没必要每次都重新准备(集中处理)整个fds集合。 于是，epoll引入了epoll_ctl系统调用，将高频调用的epoll_wait和低频的epoll_ctl隔离开。同时，epoll_ctl通过(EPOLL_CTL_ADD、EPOLL_CTL_MOD、EPOLL_CTL_DEL)三个操作来分散对需要监控的fds集合的修改，做到了有变化才变更，将select或poll高频、大块内存拷贝(集中处理)变成epoll_ctl的低频、小块内存的拷贝(分散处理)，避免了大量的内存拷贝。 使用红黑树 另外，epoll通过epoll_ctl来对监控的fds集合来进行增、删、改，那么必须涉及到fd的快速查找问题，于是，一个低时间复杂度的增、删、改、查的数据结构来组织被监控的fds集合是必不可少的了。在linux 2.6.8之前的内核，epoll使用hash来组织fds集合，于是在创建epoll fd的时候，epoll需要初始化hash的大小。于是epoll_create(int size)有一个参数size，以便内核根据size的大小来分配hash的大小。在linux 2.6.8以后的内核中，epoll使用红黑树来组织监控的fds集合，于是epoll_create(int size)的参数size实际上已经没有意义了。\n对于第三个问题\n使用回调机制 通过上面的socket的睡眠队列唤醒逻辑我们知道，socket唤醒睡眠在其睡眠队列的wait_entry(process)的时候会调用wait_entry的回调函数callback，并且，我们可以在callback中做任何事情。为了做到只遍历就绪的fd，我们需要有个地方来组织那些已经就绪的fd。为此，epoll引入了一个中间层，一个双向链表(ready_list)，一个单独的睡眠队列(single_epoll_wait_list)，并且，与select或poll不同的是，epoll的process不需要同时插入到多路复用的socket集合的所有睡眠队列中，相反process只是插入到中间层的epoll的单独睡眠队列中，process睡眠在epoll的单独队列上，等待事件的发生。同时，引入一个中间的wait_entry_sk，它与某个socket sk密切相关，wait_entry_sk睡眠在sk的睡眠队列上，其callback函数逻辑是将当前sk排入到epoll的ready_list中，并唤醒epoll的single_epoll_wait_list。而single_epoll_wait_list上睡眠的process的回调函数就明朗了：遍历ready_list上的所有sk，挨个调用sk的poll函数收集事件，然后唤醒process从epoll_wait返回。 最后，边缘触发与水平触发 说到Epoll就不能不说说Epoll事件的两种模式了，下面是两个模式的基本概念\nEdge Triggered (ET) 边沿触发 .socket的接收缓冲区状态变化时触发读事件，即空的接收缓冲区刚接收到数据时触发读事件 .socket的发送缓冲区状态变化时触发写事件，即满的缓冲区刚空出空间时触发读事件 仅在缓冲区状态变化时触发事件，比如数据缓冲去从无到有的时候(不可读-可读)\nLevel Triggered (LT) 水平触发 .socket接收缓冲区不为空，有数据可读，则读事件一直触发 .socket发送缓冲区不满可以继续写入数据，则写事件一直触发 符合思维习惯，epoll_wait返回的事件就是socket的状态\n","date":"2018-03-12T13:19:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E7%BD%91%E7%BB%9C/select-poll-epoll-%E7%AE%80%E6%98%8E%E4%BB%8B%E7%BB%8D/","title":"select poll epoll 简明介绍"},{"content":"前言 我是研二学生，而且导师不放实习，但是为了增加面试经验所以面了春招实习。 我的简历写的很朴素很简单，所以面试官的题目难度比较低。一面，面试时间是2018年3月8日晚7点。由于前一晚我在做阿里测试，所以面试官说延后一天面试，这也给了我时间来准备面试。特别是又把基础知识复习了一遍，很有帮助。\n自我介绍 略 项目的经历和对你的影响 略 四层网络结构有哪些 我回答了包含有光纤、交换机、双绞线的物理层，ip的网络层，tcp icmp udp的传输层，http dns的应用层。 标准答案：实际上TCP/IP标准并不定义与ISO数据链路层和物理层相对应的功能。相反，它定义像地址解析协议（Address Resolution Protocol,ARP）这样的协议，提供TCP/IP协议的数据结构和实际物理硬件之间的接口。所以第一个应该是链路层，包含有ARP协议，以及设备的驱动。 你对其中的哪一层比较熟悉？ 我回答了传输层的tcp协议。 TCP与udp的区别？ 略 三次握手与四次挥手？ 略 你为什么对这个过程比较熟悉？ 我回答了是主要看书看的。当然项目里也用到了，自己用tcpdump和wireshark抓包看过过程。 I/O多路复用是怎么样的？ 我回答了因为多线程比较占开销之类的，对方听了一会说，不是，他想问I/O多路复用的实现原理。我回答说忘记了，但是我记得select poll epoll的实现过程中使用了高效的数据结构来检查到底是哪一个文件描述符上出现了io操作。\n标准答案是\nepoll的高效就在于，当我们调用epoll_ctl往里塞入百万个句柄时，epoll_wait仍然可以飞快的返回，并有效的将发生事件的句柄给我们用户。这是由于我们在调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。 传统的select/poll另一个致命弱点就是当你拥有一个很大的socket集合，不过由于网络延时，任一时间只有部分的socket是“活跃”的，但是select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。但是epoll不存在这个问题，它只会对“活跃”的socket进行操作\u0026mdash;这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。那么，只有“活跃”的socket才会主动的去调用 callback函数，其他idle状态socket则不会。\n介绍C++里的多态 略 什么是析构函数，作用呢 略 虚析构函数的作用？ 略 父类的析构函数是否要设置成为虚函数？ 肯定要 浅拷贝和深拷贝的区别？ 略 如果一个函数传入一个对象，那么这是浅拷贝还是深拷贝？ 我回答了这要看拷贝构造函数。但是具体是如何的我不确定。 标准答案应该是，如果使用的是引用或指针不会发生拷贝，如果传入的类没有实现拷贝构造函数则是浅拷贝，如果实现了拷贝构造函数则看实现的拷贝构造函数是浅拷贝还是深拷贝。 C语言里的指针是什么。 我回答是首先它是一个变量，里面存的是所指向的内部数据类型或对象的地址。取内容可以获得这个数据或对象。 实际上指针不一定是变量，也有常量指针，不过一般都说指针是指针变量的简称。所以上述表达没有什么问题。 形参实参的区别。 说实话我也搞不清楚，我说不知道但是把指针、引用、普通传参都说了一遍。 后来查到形参指的是外部调用的时候传入的参数，实参是函数在处理内部所使用的参数。 介绍模拟退火算法 由于简历上写了 熵是什么，增大代表什么 略 部门主要以Java开发，如果让你做Java开发你会抵触吗？ 略 对于公司有什么想了解的。 略 后记 总时长27分钟，语速比较快，有点紧张和激动。大概就是这些，有想起来的再补充。\n","date":"2018-03-09T02:30:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/%E8%8F%9C%E9%B8%9Fb2b%E9%9D%A2%E8%AF%95%E4%B8%80%E9%9D%A2%E7%BB%8F%E5%8E%86%E8%AE%B0%E5%BD%95c++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/","title":"菜鸟B2B面试一面经历记录、c++后台开发"},{"content":"HTTP协议与TCP/IP协议的关系 HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。\n如何理解HTTP协议是无状态的 HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。\n什么是长连接、短连接 在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：Connection:keep-alive。在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。\nTCP连接 当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接 时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的。\nTCP短连接 接下来我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。\nTCP长连接 接下来我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。\n首先说一下TCP/IP详解上讲到的TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务 器端检测到这种半开放的连接。\n如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下4个状态之一：\n客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。 客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。 客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。 客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。 如何选择长连接还是短连接 长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。\n而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。\n","date":"2018-03-07T03:15:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E7%BD%91%E7%BB%9C/http%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5/","title":"HTTP长连接与短连接"},{"content":"前言 这里使用docker进行学习。配置了docker-cn的镜像。\nMysql集群建立 使用下面的命令拉取mysql镜像\ndocker pull mysql 使用下面的命令建立一个master和一个slave\ndocker run --name mysql-master -P -d -e MYSQL_ROOT_PASSWORD=ln mysql docker run --name mysql-slave1 -P -d -e MYSQL_ROOT_PASSWORD=ln mysql 其中-d是配置成为守护进程。-P暴露所有端口。设置root密码为ln。\n使用下面命令分别进入两个docker中\ndocker exec -it mysql-master bash docker exec -it mysql-slave1 bash 查看网卡ip。这里首先要安装net-tools，安装前要update，update前要换源\nsed -i \u0026#39;s/deb.debian.org/mirrors.ustc.edu.cn/g\u0026#39; /etc/apt/sources.list apt updaet apt install net-tools 输入ifconfig查看ip。 其中master是172.17.0.2，slave1是172.17.0.3\n设置登录权限 在master中的mysql中按照如下步骤操作，首先登录，然后设置名称为root用户都可以无密码访问。\nmysql -uroot -p mysql\u0026gt; grant all privileges on *.* to root@\u0026#39;%\u0026#39; identified by \u0026#39;\u0026#39;; Query OK, 0 rows affected (0.02 sec) mysql\u0026gt; flush privileges; Query OK, 0 rows affected (0.02 sec) 在slave1中使用master的数据库，密码为空\nmysql -uroot -p -h 172.17.0.2 在master中创建一个database\ncreate database test_docker; 在slave1中查看该数据库是否存在。\nshow databases; 琐事 sql对大小写不敏感，SELECT与select是一样的。 sql语句后面最好加上分号。 use用于选择数据库。set用于设置值。 添加用户的方式使用create来添加。 然后授权用户使用数据库与表。\nmysql -u root -p Enter password:** mysql\u0026gt; use mysql; mysql\u0026gt; create user \u0026#39;linanwx\u0026#39;@\u0026#39;%\u0026#39; identified by \u0026#39;ln\u0026#39;; mysql\u0026gt; grant all on *.* to \u0026#39;linanwx\u0026#39;@\u0026#39;%\u0026#39;; SHOW DATABASES用于展示当前数据库中的数据。 SHOW TABLES则用于展示当前的表。\n","date":"2018-03-05T07:04:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"MySQL学习笔记"},{"content":"前言 对SQL不熟悉，但是又不想花时间学习。那就以题代学吧。\n事务 事务(Transaction)是并发控制的基本单位。所谓事务,它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。例如，银行转帐工作：从一个帐号扣款并使另一个帐号增款，这两个操作要么都执行，要么都不执行。所以，应该把他们看成一个事务。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。\n说白了事务就是原子操作，不可分割。\n视图 视图是一个虚拟的表，实际上不存在。只是为了方便给某些人看的时候，从数据库中摘出来的部分表。视图由select查询所定义—— 当创建一个视图时，实际上是在数据库里执行了一个select语句\ninstead of 触发器 触发器定义 触发器实际上是一种特殊的存储的过程。触发器的主要功能是监视用户对数据的修改。如果针对一个数据表建了触发器，则 当数据表被修改（插入、更新或者删除）时，SQL Server便使触发器自动执行，以便对数据的修改采用一些适当的措施，从而保证数据的完整性和安全性。 INSTEAD OF触发器指定执行触发器而不是执行触发 的SQL 语句，从而替代触发语句的操作。\n存储过程 存储过程是数据库中，一组为了完成特定功能的SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中的一个重要对象。\nsql 关系代数 五个基本操作：\n并(∪)、差(-)、笛卡尔积(×)、投影(σ)、选择(π)\n四个组合操作：\n交(∩)、联接(等值联接)、自然联接、除法(÷) 并是在两个表中都有的记录。差是在第一个表中有在第二个表中没有。笛卡尔积是两个表记录一对一的所有组合。投影是纵向选择，选择是横向选择。交和并类型，连接是通过共同属性联接。除法是一种复杂的运算。\n关系模式 关系模式是指关系的描述，现实世界随着时间在不断地变化，因而在不同的时刻，关系模式的关系也会有所变化。但是，现实世界的许多己有事实限定了关系模式所有可能的关系必须满足一定的完整性约束条件。这些约束或者通过对属性取值范围的限定，例如职工年龄小于65岁（65岁以后必须退休），或者通过属性值间的相互关连（主要体现于值的相等与否）反映出来。关系模式应当刻画出这些完整性约束条件。\n非关系数据库 NoSQL(NoSQL = Not Only SQL )，意即\u0026quot;不仅仅是SQL\u0026quot;。用于超大规模数据的存储。\n","date":"2018-03-05T07:04:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%89%9B%E5%AE%A2%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/","title":"牛客数据库笔记"},{"content":"前言 智能指针似乎越来越广泛的使用了。有必要好好记住。\nshared_ptr shared_ptr允许多个指针指向同一个对象，unique_ptr则独占所指的对象。\n例子\n#include \u0026lt;memory\u0026gt; #include \u0026lt;thread\u0026gt; class A { char * str; public: A(){ str = new char[20]; printf(\u0026#34;构造\\n\u0026#34;); } ~A() { printf(\u0026#34;析构\\n\u0026#34;); delete [] str; } }; std::shared_ptr\u0026lt;A\u0026gt; xixi; void test() { std::shared_ptr\u0026lt;A\u0026gt; shared_a = std::make_shared\u0026lt;A\u0026gt;(); xixi = shared_a; printf(\u0026#34;%d\\n\u0026#34;, xixi.use_count()); } int main() { test(); std::this_thread::sleep_for(std::chrono::seconds(1)); } 上面这个例子中，xixi是全局智能指针，会在程序结束时才会释放自己所指向的对象，如果去掉了xixi=shared_a，则在main函数延迟之前就会看到析构。\nunique_ptr unique_ptr独占对象，只能在不同的unique_ptr中移动（std::move）。没有make_unique语句。只能在构造函数中传入对象的指针来构造unique_ptr。\nunique_ptr使用场景 1、为动态申请的资源提供异常安全保证 我们先来看看下面这一段代码：\nvoid Func() { int *p = new int(5); // ...（可能会抛出异常） delete p; } 这是我们传统的写法：当我们动态申请内存后，有可能我们接下来的代码由于抛出异常或者提前退出（if语句）而没有执行delete操作。\n解决的方法是使用unique_ptr来管理动态内存，只要unique_ptr指针创建成功，其析构函数都会被调用。确保动态资源被释放。\nvoid Func() { unique_ptr\u0026lt;int\u0026gt; p(new int(5)); // ...（可能会抛出异常） } week_ptr week_ptr也是一种强大的指针，名字起的比较弱。week_ptr不控制对象的生命周期，用于在不持有对象时使用。week_ptr可以在对象存在时提升为shared_ptr。\n","date":"2018-02-03T09:30:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/c++-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0/","title":"C智能指针学习"},{"content":"前言 最近由于项目需要要进行交叉编译libcurl以完成https通信。这里记录一下过程。\n首先下载最新版本的源码文件，并解压，如下：\n我用的deepin自带交叉编译工具链，sudo apt install gcc-5-arm-linux-gnueabihf安装就可以了。\narm-linux内容\n在openssl目录下运行以下命令：\nsource ../arm-linux ./Configure --prefix=$(pwd)/../output shared no-asm linux-armv4 make -j4 make install 首先导入环境变量。然后进行编译，输出路径在output下面。\n然后在libcurl 下运行以下命令\nsource ../arm-linux ./configure --with-ssl=$(pwd)/../output --prefix=$PWD/../output --build=x86_64-pc-linux-gnu --host=arm-linux-gnueabihf CC=arm-linux-gnueabihf-gcc-5 --without-zlib curl配置结果一览\ncurl version: 7.58.0 Host setup: x86_64-pc-linux-gnu Install prefix: /media/linan/72605383-b1ba-4c79-90fd-443514396fbc/curl_workdir/curl-7.58.0/output Compiler: arm-linux-gnueabihf-gcc-5 SSL support: enabled (OpenSSL) SSH support: no (--with-libssh2) zlib support: no (--with-zlib) brotli support: no (--with-brotli) GSS-API support: no (--with-gssapi) TLS-SRP support: enabled resolver: POSIX threaded IPv6 support: enabled Unix sockets support: enabled IDN support: no (--with-{libidn2,winidn}) Build libcurl: Shared=yes, Static=yes Built-in manual: enabled --libcurl option: enabled (--disable-libcurl-option) Verbose errors: enabled (--disable-verbose) SSPI support: no (--enable-sspi) ca cert bundle: no ca cert path: no ca fallback: no LDAP support: no (--enable-ldap / --with-ldap-lib / --with-lber-lib) LDAPS support: no (--enable-ldaps) RTSP support: enabled RTMP support: no (--with-librtmp) metalink support: no (--with-libmetalink) PSL support: no (libpsl not found) HTTP2 support: disabled (--with-nghttp2) Protocols: DICT FILE FTP FTPS GOPHER HTTP HTTPS IMAP IMAPS POP3 POP3S RTSP SMB SMBS SMTP SMTPS TELNET TFTP 然后在运行make 以及make install，在curl目录下就会出现output目录。\n最终，我们需要的是openssl以及curl的动态库，分别是：libssl.so libcrypto.so libcurl.so\n","date":"2018-01-30T10:53:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E5%B5%8C%E5%85%A5%E5%BC%8F/libcurl%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91arm%E7%89%88%E6%9C%AC%E5%8A%A8%E6%80%81%E5%BA%93/","title":"libcurl交叉编译arm版本动态库"},{"content":"链接：https://www.nowcoder.com/questionTerminal/d3f26db0325444078717cc802e0056d8 来源：牛客网\n小易正在玩一款新出的射击游戏,这个射击游戏在一个二维平面进行,小易在坐标原点(0,0),平面上有n只怪物,每个怪物有所在的坐标(x[i], y[i])。小易进行一次射击会把x轴和y轴上(包含坐标原点)的怪物一次性消灭。 小易是这个游戏的VIP玩家,他拥有两项特权操作: 1、让平面内的所有怪物同时向任意同一方向移动任意同一距离 2、让平面内的所有怪物同时对于小易(0,0)旋转任意同一角度 小易要进行一次射击。小易在进行射击前,可以使用这两项特权操作任意次。\n小易想知道在他射击的时候最多可以同时消灭多少只怪物,请你帮帮小易。\n如样例所示:\n所有点对于坐标原点(0,0)顺时针或者逆时针旋转45°,可以让所有点都在坐标轴上,所以5个怪物都可以消灭。\n输入描述: 输入包括三行。 第一行中有一个正整数n(1 ≤ n ≤ 50),表示平面内的怪物数量。 第二行包括n个整数x[i](-1,000,000 ≤ x[i] ≤ 1,000,000),表示每只怪物所在坐标的横坐标,以空格分割。 第二行包括n个整数y[i](-1,000,000 ≤ y[i] ≤ 1,000,000),表示每只怪物所在坐标的纵坐标,以空格分割。\n输出描述: 输出一个整数表示小易最多能消灭多少只怪物。\n示例1\n输入 5 0 -1 1 1 -1 0 -1 -1 1 1\n输出 5\n分析 题目等价于，找一个十字架能够尽可能多的覆盖所有节点。 考虑到一根线至少能够覆盖到两个点，再加一根垂直于这条线至少能够覆盖3个点，在此基础上进行遍历。对任意三个点，我们选择其中两个点做一条直线(三种情况)，对于第三个点，我们做一条垂线到这条直线上。这样的十字架已经经过了三个点。对于剩下的点，我们判断是否在这个十字架上。要判断是否在十字架上，首先判断是否和第一条直线在同一条直线上。否则，判断这个点和第三个点所构成的直线是否和第二条直线垂直。 当点数小于等于3个点，则可以把所有点都覆盖到。\n#include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; struct point{ int x = 0; int y = 0; }; bool is_sameline(point p1, point p2, point p3){ return ((p1.x - p2.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p2.y)) == 0; } bool is_vertical(point p1, point p2){ return (p1.x * p2.x + p1.y * p2.y) == 0; } bool is_vertical(point p1, point p2, point p3, point p4){ point v1, v2; v1.x = p1.x - p2.x; v1.y = p1.y - p2.y; v2.x = p3.x - p4.x; v2.y = p3.y - p4.y; return is_vertical(v1, v2); } int main() { int n, ret = 0; cin \u0026gt;\u0026gt; n; point inputs[n]; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; inputs[i].x; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; inputs[i].y; if (n \u0026lt; 4) { cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; return 0; }; vector\u0026lt;int\u0026gt; select = {1, 1, 1}; for (int i = 0; i \u0026lt; n - 3; i++) select.push_back(0); do { vector\u0026lt;point\u0026gt; shizi; for (int i = 0; i \u0026lt; n; i++) { if (select[i]) { shizi.push_back(inputs[i]); } } vector\u0026lt;vector\u0026lt;point\u0026gt;\u0026gt; status; status.push_back({shizi[0], shizi[1], shizi[2]}); status.push_back({shizi[0], shizi[2], shizi[1]}); status.push_back({shizi[1], shizi[2], shizi[0]}); for (auto points : status) { int count = 0; for (int i = 0; i \u0026lt; n; i++) { if (!select[i]) { if (is_sameline(points[0], points[1], inputs[i])) count++; if (is_vertical(points[0], points[1], points[2], inputs[i])) count++; } } ret = max(ret, count); } } while (prev_permutation(select.begin(), select.end())); cout \u0026lt;\u0026lt; ret + 3 \u0026lt;\u0026lt; endl; return 0; } ","date":"2018-01-23T01:39:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E5%B0%84%E5%87%BB%E6%B8%B8%E6%88%8F/","title":"算法题目——射击游戏"},{"content":"链接：https://www.nowcoder.com/questionTerminal/504ad6420b314e5bb614e1684ad46d4d 来源：牛客网\n一个合法的括号匹配序列被定义为: 1. 空串\u0026quot;\u0026ldquo;是合法的括号序列 2. 如果\u0026quot;X\u0026quot;和\u0026quot;Y\u0026quot;是合法的序列,那么\u0026quot;XY\u0026quot;也是一个合法的括号序列 3. 如果\u0026quot;X\u0026quot;是一个合法的序列,那么\u0026rdquo;(X)\u0026ldquo;也是一个合法的括号序列 4. 每个合法的括号序列都可以由上面的规则生成 例如\u0026rdquo;\u0026quot;, \u0026ldquo;()\u0026rdquo;, \u0026ldquo;()()()\u0026rdquo;, \u0026ldquo;(()())\u0026rdquo;, \u0026ldquo;(((()))\u0026ldquo;都是合法的。 从一个字符串S中移除零个或者多个字符得到的序列称为S的子序列。 例如\u0026quot;abcde\u0026quot;的子序列有\u0026quot;abe\u0026rdquo;,\u0026rdquo;\u0026quot;,\u0026ldquo;abcde\u0026quot;等。 定义LCS(S,T)为字符串S和字符串T最长公共子序列的长度,即一个最长的序列W既是S的子序列也是T的子序列的长度。 小易给出一个合法的括号匹配序列s,小易希望你能找出具有以下特征的括号序列t: 1、t跟s不同,但是长度相同 2、t也是一个合法的括号匹配序列 3、LCS(s, t)是满足上述两个条件的t中最大的 因为这样的t可能存在多个,小易需要你计算出满足条件的t有多少个。\n如样例所示: s = \u0026ldquo;(())()\u0026quot;,跟字符串s长度相同的合法括号匹配序列有: \u0026ldquo;()(())\u0026rdquo;, \u0026ldquo;((()))\u0026rdquo;, \u0026ldquo;()()()\u0026rdquo;, \u0026ldquo;(()())\u0026quot;,其中LCS( \u0026ldquo;(())()\u0026rdquo;, \u0026ldquo;()(())\u0026rdquo; )为4,其他三个都为5,所以输出3.\n输入描述: 输出描述: 输出一个正整数,满足条件的t的个数。\n示例1\n输入 (())()\n输出 3\n分析 题目要求对所有的相同长度的括号序列进行遍历，并计算每一个括号序列与题目中给定的字符串的最长公共子序列的长度。然后，计算长度最大的值出现了多少次。\n如果真的按照题目的描述去做，显然是不可能做出来的。光是生成长达50个字符串的括号序列可能花的时间就超了。\n既然要搜索最长的出现了多少次，不如假设出现了最长的子串是原串长度-1，然后求所有由这个子串所构成的括号序列。如果不存在，则求子串长是原串长度-2的串所能构成的括号序列。依次递减这个子串的长度，直到能求出来为止。\n其实，一定存在子串长度为原串长度-1的串通过添加新的括号所构成的另一个和原串不同的括号序列。这是因为，任何一个括号序列都可以只移动一个括号构成另外一个和原来不同的括号序列(思考为什么)。如果可以这样，那么新串和原串的最长公共括号子序列就是n-1个。因为你只移动了一个括号并插入到其他地方。那么除了这个括号外，其他的顺序都没有变。那么，每次将其中一个括号拿掉，然后插入到新的地方。我们统计一下总共能构成多少个合法的括号序列，将这个数字减去原来的那个串，也就是减去1，就是题目的答案。\n#include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; bool isKuohao(const string \u0026amp; str) { int count=0; for(auto c:str) { if(c == \u0026#39;(\u0026#39;) count ++; if(c == \u0026#39;)\u0026#39;) count --; if(count\u0026lt;0) return false; } return count == 0; } int main() { int ret=0; string input; cin \u0026gt;\u0026gt; input; set\u0026lt;string\u0026gt; haveChose; set\u0026lt;string\u0026gt; haveBuild; /* 选出其中任意一个括号 */ for (int i = 0; i \u0026lt; input.size(); i++) { char q[] = {input[i], \u0026#39;\\0\u0026#39;}; /* 删除该括号 */ string delete_char(input); delete_char.erase(delete_char.begin() + i); if (haveChose.count(delete_char)) continue; else haveChose.insert(delete_char); /* 将原来的括号插入新的数组中 */ for (int j = 0; j \u0026lt; delete_char.size() + 1; j++) { string add_delete_char(delete_char); add_delete_char.insert(j, q); if (haveBuild.count(add_delete_char)) continue; else haveBuild.insert(add_delete_char); if(isKuohao(add_delete_char)){ ret ++; } } } cout \u0026lt;\u0026lt; ret-1 \u0026lt;\u0026lt; endl; } ","date":"2018-01-21T14:05:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/","title":"算法题目——最长公共子括号序列"},{"content":"链接：https://www.nowcoder.com/questionTerminal/f58859adc39f4edc9cd8e40ba4160339 来源：牛客网\n魔法王国一共有n个城市,编号为0~n-1号,n个城市之间的道路连接起来恰好构成一棵树。 小易现在在0号城市,每次行动小易会从当前所在的城市走到与其相邻的一个城市,小易最多能行动L次。 如果小易到达过某个城市就视为小易游历过这个城市了,小易现在要制定好的旅游计划使他能游历最多的城市,请你帮他计算一下他最多能游历过多少个城市(注意0号城市已经游历了,游历过的城市不重复计算)。\n输入描述: 输入包括两行,第一行包括两个正整数n(2 ≤ n ≤ 50)和L(1 ≤ L ≤ 100),表示城市个数和小易能行动的次数。 第二行包括n-1个整数parent[i](0 ≤ parent[i] ≤ i), 对于每个合法的i(0 ≤ i ≤ n - 2),在(i+1)号城市和parent[i]间有一条道路连接。\n输出描述: 输出一个整数,表示小易最多能游历的城市数量。\n分析 题目经过抽象之后，意思是在一个树中进行遍历，经过指定步数，可以获取最长经过节点树量的路径。如果把这个树按照根节点进行悬挂，可能更好理解一些。虽然有些答案是从低向上生长，但是我还是重建了树，采用悬挂树来做的。\n从这个根节点开始遍历，先判断左树深度大还是右树深度大，先遍历树深度大的那个节点。直到步数用完为止。\n树的深度通过后序遍历很容易求出来，结果发现这样的答案只能通过60%。\n45 73 0 0 0 1 0 0 3 5 6 8 7 9 1 10 1 2 15 6 8 11 14 17 8 14 3 21 23 3 21 15 12 5 21 31 11 13 7 17 20 26 28 16 36 26 错在这个用例上了。这个正确答案是41，通过简单的贪心算法只能得到39个城市。\n后来看了解析也是看不太懂。总之之后看到正确答案中是求出来深度后直接获得最终答案。\n假设我们已经求出了每一个节点的最大深度，用deep[i]来表示，树的最下面一层的深度是1。\n显然，根节点到任意一个节点的最长路径=deep[0]-1。\n以这条路径为基础，我们可以额外访问一些节点。但是每次访问完这些节点的时候，我们必须回来这个路径。这一来一回，每次访问一个节点都必须额外走两步，访问两个节点就必须走4步。\n看图就容易明白一些：\n参考代码\n#include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; tree; vector\u0026lt;int\u0026gt; deep; void calc_deep(int i) { int max_deep = 0; for(auto j:tree[i]) { calc_deep(j); max_deep = max(deep[j], max_deep); } deep[i] = max_deep + 1; } int main() { int n, L; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; L; /* 建立树 */ tree.resize(n); deep.resize(n); for(int i=0;i\u0026lt;n-1;i++) { int num; cin \u0026gt;\u0026gt; num; tree[num].push_back(i+1); } /* 计算深度 */ calc_deep(0); // int validpath = min(deep[0] -1,L); // cout \u0026lt;\u0026lt; min(n, 1 + validpath + (L - validpath)/2) \u0026lt;\u0026lt; endl; int long_path = deep[0] - 1; if(long_path \u0026gt; L) cout \u0026lt;\u0026lt; L + 1; else cout \u0026lt;\u0026lt; 1 + long_path + (L - long_path)/2; } ","date":"2018-01-19T10:05:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E6%B8%B8%E5%8E%86%E9%AD%94%E6%B3%95%E7%8E%8B%E5%9B%BD/","title":"算法题目——游历魔法王国"},{"content":"前言 大部分人都用过终端命令行。有的时候需要繁琐的输入同样的命令，我们可以编写自己的脚本来完成这个工作。\n指定解释器 #!/bin/bash 这句是指定bash作为我们脚本的解释器。如果我们写的语法是Python，那么应该换成Python。\n定义变量 变量名=变量值 例如 name=\u0026ldquo;hahaha\u0026rdquo; 对于普通的字符，加不加双引号，单引号都一样。name=hahaha也行。\n使用变量 在变量名前加上$表示使用变量。也就是说求这个符号的的值。\n字符串 引号有如下特点：\n空格作为词的分割符 单引号中的词 字符模式匹配 路径名扩展 进程替换 (重定向） 其中单引号不会对内容进行二次处理，而双引号会对内容做处理，例如双引号会对其中的内容进行求值。你可以看看echo \u0026ldquo;$name\u0026rdquo; 和 echo \u0026lsquo;$name\u0026rsquo;就明白了。\n拼接字符串就是把两个字符串放在一起。 ${#string}用于获取字符串长度，${string:1:4}用于切片\n获取输入内容 read inputstr read -p \u0026ldquo;please input : \u0026quot; inputstr 上面两句是从标准输入中获取输入内容。\n获取脚本执行结果 例如获取Python脚本的执行输出 into=$(\u0026lsquo;python3\u0026rsquo; \u0026lsquo;pyscript.py\u0026rsquo; \u0026lsquo;arg1\u0026rsquo; \u0026lsquo;arg2\u0026rsquo;) arg1 和arg2 是参数\n","date":"2018-01-18T09:23:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/linux%E7%BC%96%E7%A8%8B/bash-%E8%AF%AD%E8%A8%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"bash 语言 学习笔记"},{"content":"前言 动态规划是笔试中经常出现的一类题目。掌握他很关键。\n网易题目 小Q和牛博士合唱一首歌曲,这首歌曲由n个音调组成,每个音调由一个正整数表示。 对于每个音调要么由小Q演唱要么由牛博士演唱,对于一系列音调演唱的难度等于所有相邻音调变化幅度之和, 例如一个音调序列是8, 8, 13, 12, 那么它的难度等于|8 - 8| + |13 - 8| + |12 - 13| = 6(其中||表示绝对值)。 现在要对把这n个音调分配给小Q或牛博士,让他们演唱的难度之和最小,请你算算最小的难度和是多少。 如样例所示: 小Q选择演唱{5, 6}难度为1, 牛博士选择演唱{1, 2, 1}难度为2,难度之和为3,这一个是最小难度和的方案了。\n贪心解法（错误） 将所有数字进行排序，取最大的两个数字差作为间隔，取其中一下半作为小Q的音符，取另一上半作为牛博士的音符，然后计算结果。最终能过通过60%的用例。 如果时间不够，或者不会的情况可以使用这种解法。\n#include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main(){ int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; nums; for(int i=0;i\u0026lt;n;i++) { int num; cin \u0026gt;\u0026gt; num; nums.push_back(num); } vector\u0026lt;int\u0026gt; nums_sort(nums.begin(), nums.end()); sort(nums_sort.begin(), nums_sort.end()); int max_gap = 0; auto max_gap_it = nums_sort.begin(); for(auto it=nums_sort.begin(); it!=nums_sort.end()-1; it++){ if(*(it+1) - *it \u0026gt; max_gap){ max_gap = *(it+1) - *it; max_gap_it = it; } } int max_gap_num = *max_gap_it; int ret = 0; int last_1 = -1; int last_2 = -1; for(auto it = nums.begin(); it!=nums.end(); it++){ if(*it \u0026lt;= max_gap_num){ if(last_1 != -1){ ret += abs(*it - last_1); } last_1 = *it; } else{ if(last_2 != -1){ ret += abs(*it - last_2); } last_2 = *it; } } cout \u0026lt;\u0026lt; ret; } 动态规划小思 由于我对动态规划一点也不了解，先从找零开始。\n找零问题 动态规划的核心在于问题的分解和子问题递归组合变成原问题。\n举个例子，假设我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？ 如果你是个人类的话，你会说，我大眼一瞪，两个五元和一个一元，总共3个硬币。我们换个例子，假设题目是237元呢？你可能会说，我先用5块钱换出200元，然后找到剩下37元的最优组合。这种方法实际上是默认了将237元分成了两份，并假设两份的组合是最优组合。如果真是这样的话，那么就没什么问题了。可问题就出在分的200和37元，没有方法能证明这是有效的分割，所以动态规划就是建立在有效分割上的。\n分治算法与动态规划也是建立在分割上的。只是动态规划涉及到状态转移，而分治算法没有状态转移。分治算法可以由上向下分解，而动态规划通常由下向上构建。\n动态规划会涉及到两个维度，第一个维度通常和问题的规模相关，第二个维度需要从题目中提取出来。在本题目中，第二个维度是允许使用的硬币，例如，允许使用1元、允许使用1元和3元、允许使用1元3元5元。我们把他记为下标1,2,3，我们用j来代表这个变量，如果用i来表示当前题目的规模，也就是237，那么我们要求的是c[i][j] 为 c[237][3]的值。对于这个问题，我们可以分两种假设，第一种假设，这个最优解中5元的数量\u0026gt;0，第二种假设，这个最优值中5元的数量=0.对于第一种假设c[237][3]=c[237][2]，因为没有使用5元，那么就不需要5元了，这个最优解的解应该和只是用1元和3元的情况一致。对于第二种情况，由于这个解中必然有一个5元（因为你假设他大于0），那么，除了这枚5元钱，剩下的钱数是232元钱。由于原来c[237][3]是135元找237元的最优值，又因为其中必然有一枚5元，在最优值状态下拿掉其中必然存在的一枚硬币，剩下的钱所组成的钱数必然也是最优状态，(假设子问题不是最优的，即237元找135元的硬币数中构成232元的解有更优解，则237找135元也有更有解，和c[237][3]为最优解矛盾)，那么c[232][3]的值就是c[237][3]-1的值。\n这样我们可以推导出 c[i][j] = c[i][j-1] 假设1 c[i][j] = c[i-j下标代表的钱数][j]+1 假设2 如果写成min的形式，就是熟知的状态转移方程了。\n最终求的是c[11][5]，使用表格从c[0][0]状态开始向右下角推，最终可以推出答案。\n双人合唱难度问题 https://www.nowcoder.com/questionTerminal/fddf64d5757e41ec93f3ef0c0a10b891 我们要记住\n题目的最优解不一定是状态矩阵的右下角的值\n我们必须时刻记住，状态矩阵的右下角方格不一定就是直接的最优解。如果这样想的话，往往会陷入困境。为此，我们只能这样设想，矩阵i，j一定和题目中的两个维度有关，但是dp[i][j]不一定代表了最优解的值。\n例如本题目，题目要求求出最优难度系数。假如dp[i_max][j_max]就是最优难度系数，那i和j是什么的下标呢？？是无解的。反过来想，最优难度系数到底是什么呢？我们想想看，因为存在状态转移，最优状态必然是从多个状态中获取到的最小值。i代表什么呢？i如果代表当前唱的音符，那么j代表什么呢？j就只能代表另外一个人唱的音符了。那么最优状态下，一共会有多少种情况，就从这些情况来推算最优的值是哪个。在最优状态下，必然有一个人在唱最后一个音符，那么另一个人可能一个都没有唱，可能在唱第一个音符，可能在唱第二个音符。。。可能在唱倒数第二个音符。然后我们计算所有情况的最小值，就知道了问题的最优解。\n还有一个问题，i和j是不是要分人？如果i代表小Q唱的，j代表牛博士唱的，那么这个矩阵就是对称的，我们多计算了一半的内容。其实我们不关心到底是谁唱的，因为都一样。我们只能这样想，其中一个i是当前人唱的，j是上一个人唱到哪里了。\nc[i][j]可能由哪些状态转移过来呢？ 例如某人唱到了第6个音符，另一个人最后一次唱到了第3个音符，此时如果当前的总的难度是最小的，那么有以下结论： 第6个音符、第5、第4个音符都是第一个人唱的。因为第二个人才唱到了第三个音符，他不可能去唱后面的音符。 所以c[6][3] = c[5][3] + 56难度差 = c[4][3] + 45难度差。 但是c[4][3]是怎么转移来的呢？如果此时第一个人唱到了第4个音符，另一个人唱到了第3个音符，这说明第一个人唱第4个音符中断了第二个人唱的音符。由于不知道上一次第一个人是从哪里跳到第4个音符的，所以我们分别假设是从可能的所有音符跳过来的，如果是从第二个音符跳过来的，那么就是c[3][2]+ 34差。如果是从第一个音符跳过来的，那么就是c[3][1]+14差。如果是从没有跳过来的，那么就是c[3][0]+04差。由于第一个人唱的时候，第二个人上一次唱的总是比第一个人唱的要小，所以我们不需要考虑j\u0026gt;=i的时候。\n基于此，有以下代码\n#include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;array\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; nums; array\u0026lt;array\u0026lt;int, 2100\u0026gt;, 2100\u0026gt; dp; /* 计算两个音符之间的难度。注意第一个音符的下标在输入数据里面是0，有个差1的关系。如果起始音符是0，说明第一次唱，不增加难度 */ int diffcult(int s, int e) { if(s == 0) return 0; // printf(\u0026#34;diffcult %d %d to %d %d is %d \\n\u0026#34;, s,nums[s-1], e,nums[e-1], abs(nums[e-1] - nums[s-1])); return abs(nums[e-1] - nums[s-1]); } int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { int num; cin \u0026gt;\u0026gt; num; nums.push_back(num); } /* 从0开始向后考虑，直到考虑完所有音符，第一个人最差的情况是没有唱，此时j也没有唱，直接continue了 */ for (int i = 0; i \u0026lt;= n; i++) { /* 这里也是从0开始考虑，因为第一个人最差一个都不唱，就是处于0 */ for (int j = 0; j \u0026lt;= n; j++) { /* 不考虑后面的情况。当然也可以直接写到上面的范围限制里面 */ if (j \u0026gt;= i) continue; /* 如果是一般情况下，比如第一个人在唱6音符时，第二个人在唱3音符，显然是从dp[5][3]转移来的 */ if (j + 1 \u0026lt; i) { dp[i][j] = dp[i - 1][j] + diffcult(i - 1, i); } /* 否则，如果第二个人刚唱完就被第一个人抢唱了，那么第一个人唱的音符就可能是前面跳过来的 */ if (j + 1 == i) { /* k表示i是从第几个跳过来的 */ int min_cost = -1; for (int k = 0; k \u0026lt; j; k++) { int cost = dp[j][k] + diffcult(k, j + 1); /* 只用记录最小跳唱难度 */ if(min_cost == -1 || min_cost \u0026gt; cost){ min_cost = cost; } } if(min_cost == -1) min_cost = 0; dp[i][j] = min_cost; } // for(int a=0;a\u0026lt;=n;a++){ // for(int b=0;b\u0026lt;=n;b++){ // if(a==i \u0026amp;\u0026amp; b == j){ // printf(\u0026#34;\\t【%d】\u0026#34;, dp[a][b]); // } // else printf(\u0026#34;\\t%d\u0026#34;, dp[a][b]); // } // // printf(\u0026#34;\\n\u0026#34;); // } // printf(\u0026#34;\\n\u0026#34;); } } int min_cost = -1; for(int j=0;j\u0026lt;n;j++){ if(min_cost == -1 || min_cost \u0026gt; dp[n][j]){ min_cost = dp[n][j]; } } printf(\u0026#34;%d\u0026#34;, min_cost); } 最长回文子串问题 https://leetcode.com/problems/longest-palindromic-substring/description/ 其实已经明白了为什么动态规划会以这种方式进行呈现了。二维动态规划问题的最关键的点在于：\n线性增长问题的平面展开\n例如找零问题，展开第二个维度就是以当前硬币种类找零。而合唱问题，则是以唱到当前位置时且上一个唱到某个位置时的难度最小值。最长回文子串，则变得是起始位置。\n最长回文子串的i表示从第i个字符开始，第j个字符结束时的最长子串问题。当i是起始字符，j是终止字符，则是问题的答案。\n对于最小的子问题来说，就是单个字符了，他的长度就是1，对于长字符串来说，如果他两边的字符不一样，那么等于去掉右边或者左边的字符中小的那一个。如果两边的字符一样，那么就等于去掉两边的子串的值加2。\n#include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Solution { public: int longestPalindromeSubseq(string s) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp; dp.resize(s.size() + 1); for (int i = 0; i \u0026lt; s.size() + 1; i++) { dp[i].resize(s.size() + 1); } int len = s.size(); for(int t=0;t\u0026lt;len;t++){ for(int j=t; j\u0026lt;len;j++){ int i = j-t; if(i==j){ dp[i][j] = 1; } else if(s[i] == s[j]){ dp[i][j] = dp[i+1][j-1] + 2; } else{ if(dp[i+1][j]\u0026gt; dp[i][j-1]){ dp[i][j] = dp[i+1][j]; } else{ dp[i][j] = dp[i][j-1]; } } } } return dp[0][len-1]; } }; 最大子串问题 这个题目也很经典，按照上一个题目的思路，我们依次求出所有串的长度，就得到了最大的子串。\n然而事情不是这么简单，这个题目可以用一维来做。（注意其中有负数）。\n我们的记得，最后一个方格内存的不一定就是最优解。往往我们会认为dp[i]就是从开始到这个位置中，能够找到的最大的子串的值。但是这个最大的子串与i又没有什么关系，似乎i往左一位和往右移一位没有什么区别。如果我们的下标与题目中的最优解产生了“松弛”的关系，我们一定要警惕起来。我们需要紧紧把下标和最优解绑在一起。最优解必然和i产生直接关系。那么i是最优的什么。你会想到，i就是必须以第i个数字为结尾的串的最大值。最大子串就是遍历dp矩阵，找到那个最大的值。\n状态方程也容易写出来了，每当我们多考虑一个数字，以这个数字为结尾的子串的最大值有两种情况，第一种就是以上一个数字为结尾的最大子串加上这个数字，第二种情况就是不以上一个数字 为结尾。显然第二种情况就是以这个数字为开头的情况，并且只有这一个数字。\ninput表示输入矩阵，dp表示状态矩阵 我们有 dp[i] = max (dp[i-1] + input[i] , input[i])\n","date":"2018-01-18T08:52:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%80%9D%E8%80%83/","title":"动态规划算法学习与思考"},{"content":"前言 二叉排序树存在劣化情况 二叉平衡树为了维持查找性能在插入和删除的时候开销太大 红黑树就出现了。红黑树不像二叉平衡树在任意时刻两个子树高度差相差最多1 参考自 http://www.sohu.com/a/201923614_466939\n性质 节点由红色和黑色构成，根节点为黑色 叶子节点由黑色的NIL节点构成 红色节点的子节点一定是黑色节点，并且一定包含两个叶子节点。这意味着不存在连续的两个红色节点。 从任意一个节点出发，到任意一个NIL节点，都经历了相同数目的黑色节点 这意味着从根节点出发，到任意一个叶子节点，最长路径和最短路径差不超过最长路径的一半。这种情况下，最长路径和最短路径的黑色数目一样，最长路径最多多黑色个红色节点。\n变色与旋转 当插入一个节点（或删除一个节点），红黑树的性质被破坏。使用变色和旋转来调整。\n变色 如果两个节点连续为红色，需要变色\n旋转 如果有一条路径上的黑色节点太多，需要旋转\n变色与旋转的条件 这个之后在总结\n","date":"2018-01-15T10:00:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","title":"红黑树实现原理"},{"content":"byobu byobu是代替screen以及tmux的一款工具。使用apt install byobu就可以安装好。运行byobu就可以查看他的命令很简单：\nf2 创建新窗口 f3 返回左侧的窗口 f4 返回右侧的窗口 f9 离开byobu，打开的窗口所运行的命令不会因此中断。 强烈推荐不想使用screen和tmux的人试一下！包你满意。\n","date":"2018-01-11T15:01:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/linux%E7%BC%96%E7%A8%8B/linux-%E7%BB%88%E7%AB%AF%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1%E5%A4%9A%E7%AA%97%E5%8F%A3%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8/","title":"Linux 终端后台任务、多窗口怎么使用"},{"content":"指针与引用的区别 指针可以是空指针，但是引用不能是空引用。这就导致下面一个区别。 指针可能是非法的，引用总是合法的。如果指针是空指针，那么就不能合法的使用它。这要求在每次使用指针时都需要判断它的合法性。相反引用则不用判断。 指针是可以修改的，引用不可以。指针是变量，他存储的地址所指向的对象可以被修改为其他地址，不再指向原对象。但是引用在初始化时被限定指向对象，可以修改对象的内容，但是不允许引用再引用其他对象。 基于上述情况，指针和引用的应用场合不一样。指针可以应用在指向对象存在不同时刻指向不同对象或者需要指向不存在任何对象的场合。如果总是指向一个对象且指向该对象之后不再改变，则应该使用引用。 ","date":"2018-01-10T08:44:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/c++/c++%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/","title":"C++基本问题——指针与引用的区别"},{"content":"前言 最近疑似被电信劫持，遂将分析记录下来\n现象 我的三星S8使用的是四川电信卡，在访问如下网站时会被跳转到全屏广告，也就是支付宝红包界界面，体验非常差，下面这个就是一个会被劫持的地址。 http://m.blog.csdn.net/skyroben/article/details/70195575\n分析 手机使用ss代理（4G）再访问上述网站，没有广告，没有劫持 手机直连，电信wifi，访问有劫持 使用热点，用电脑点击上面的网址，不会出现劫持 使用热点，使用插件更改电脑端user agent为Android客户端，有一定概率出现劫持？？ 不使用热点，电脑有线（电信），更改电脑端user agent为Android客户端，有一定概率出现劫持？？ 使用手机端chrome（s8），连上电信wifi，在网址前加上view-source:查看网页源码，并将结果分别保存，在电脑端查看两文件进行差分对比，并没有不同。 使用手机端chrome（s8），连上移动wifi，有劫持！（脚本缓存？） 使用ios chrome，连电信wifi，没有劫持 综上 由于劫持后网页源码没有变化，可能是劫持了脚本。由于使用移动wifi访问也会出现劫持，所有不能排除csdn自己加入的广告。使用ss代理就可以破解劫持，说明劫持是区域性的。电脑和ios访问不会被劫持，说明劫持只针对Android浏览器。\n结论 一般用户最好不要使用电信网络和Android手机，并且建议所有网站使用https进行加密\n","date":"2017-12-31T06:24:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/%E5%85%B3%E4%BA%8Ecsdn%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%A2%AB%E7%94%B5%E4%BF%A1%E5%8A%AB%E6%8C%81%E7%BA%A2%E5%8C%85%E5%B9%BF%E5%91%8A%E7%9A%84%E7%8E%B0%E8%B1%A1%E4%B8%8E%E6%84%9F%E6%83%B3/","title":"关于CSDN移动端被电信劫持红包广告的现象与感想"},{"content":"前言 面试中可能会考你，怎么去实现一个vector呢？这需要了解vector的底层实现。 在这之前，需要学习动态内存管理，特别是allocator，在c++ primer一书中有讲解。\n要实现的基础内容 在cplusplus网站上，查看常见用法如下： 成员函数 (构造器) Construct vector (public member function ) (析构函数) Vector destructor (public member function )\n迭代器: begin Return iterator to beginning (public member function ) end Return iterator to end (public member function )\n容量: size Return size (public member function )\n元素访问: operator[] Access element (public member function ) at Access element (public member function )\n修改器: push_back Add element at the end (public member function ) pop_back Delete last element (public member function )\n基础的vector的主要结构 #include \u0026lt;cstddef\u0026gt; #include \u0026lt;stdexcept\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;iterator\u0026gt; template \u0026lt;typename T\u0026gt; class vector { public: using value_type = T; using iterator = value_type *; using size_type = std::size_t; public: vector() = default; ~vector(); iterator begin() const; iterator end() const; size_type size() const; value_type \u0026amp;operator[](size_type i) const; value_type \u0026amp;at(size_type i) const; void push_back(const value_type \u0026amp;new_elem); void pop_back(); private: iterator startptr = nullptr; iterator endptr = nullptr; iterator capptr = nullptr; std::allocator\u0026lt;value_type\u0026gt; alloc; private: void check_cap(); void free(); }; 在我们这个类中，简单的实现了迭代器，push_back，pop_back，以及[]，at函数，size函数。为了实现内存管理还需要实现构造、析构函数，以及检查容量函数。\n基础功能的内部实现 template \u0026lt;typename T\u0026gt; typename vector\u0026lt;T\u0026gt;::iterator vector\u0026lt;T\u0026gt;::begin() const { return startptr; } template \u0026lt;typename T\u0026gt; typename vector\u0026lt;T\u0026gt;::iterator vector\u0026lt;T\u0026gt;::end() const { return endptr; } template \u0026lt;typename T\u0026gt; typename vector\u0026lt;T\u0026gt;::size_type vector\u0026lt;T\u0026gt;::size() const { return endptr - startptr; } template \u0026lt;typename T\u0026gt; typename vector\u0026lt;T\u0026gt;::value_type \u0026amp;vector\u0026lt;T\u0026gt;::operator[](size_type i) const { return *(startptr + i); } template \u0026lt;typename T\u0026gt; typename vector\u0026lt;T\u0026gt;::value_type \u0026amp;vector\u0026lt;T\u0026gt;::at(size_type i) const { if (startptr + i \u0026gt;= endptr) { throw std::runtime_error(\u0026#34;out of range!\u0026#34;); } return *(startptr + i); } template \u0026lt;typename T\u0026gt; vector\u0026lt;T\u0026gt;::~vector() { free(); } 上面是简单函数的实现。仅仅是取出内部的数据而已。\ntemplate \u0026lt;typename T\u0026gt; void vector\u0026lt;T\u0026gt;::free() { if (startptr) { for (auto p = startptr; p != endptr; p++) { alloc.destroy(p); } alloc.deallocate(startptr, endptr - startptr); } } template \u0026lt;typename T\u0026gt; void vector\u0026lt;T\u0026gt;::check_cap() { if (endptr == capptr) { int newsize = size() ? size() \u0026lt;\u0026lt; 1 : 1; auto newstartptr = alloc.allocate(newsize); auto newendptr = uninitialized_copy(std::make_move_iterator(startptr), std::make_move_iterator(endptr), newstartptr); free(); startptr = newstartptr; endptr = newendptr; capptr = newstartptr + newsize; } } template \u0026lt;typename T\u0026gt; void vector\u0026lt;T\u0026gt;::push_back(const value_type \u0026amp;new_elem) { check_cap(); alloc.construct(endptr, new_elem); endptr++; } template \u0026lt;typename T\u0026gt; void vector\u0026lt;T\u0026gt;::pop_back() { if(endptr-startptr\u0026gt;0){ alloc.destroy(endptr); endptr--; } } 这部分是涉及到内存的部分，使用了allocator来管理内存。构造器将分配空间和构造函数分开，分为分配空间、回收空间、析构过程、构造过程，检查容量这部分涉及到这四个情况，首先分配新空间，然后在新位置上构造新元素，然后析构旧元素，释放旧空间。析构旧元素、释放旧空间使用free函数来完成。这里使用uninitialized_copy函数和make_move_iterator，移动迭代器以及无初始化拷贝函数来实现在新的位置上构造新的元素，以求加速新元素构造的速度。\n高级函数与实现 erase 接下来完成一些额外的函数的实现，我们先从erase开始吧 erase删除从指定位置到指定位置的所有内容。函数原型为如下：\npublic: iterator erase(const_iterator position); iterator erase(const_iterator first, const_iterator last); 第一个函数也可以看做是第二个函数的调用而已。我们实现第二个函数如下：\ntemplate \u0026lt;typename T\u0026gt; typename vector\u0026lt;T\u0026gt;::iterator vector\u0026lt;T\u0026gt;::erase(const_iterator first, const_iterator last) { if(last \u0026gt;= endptr || first \u0026lt; startptr) throw std::runtime_error(\u0026#34;out of range!\u0026#34;); iterator newendptr = std::copy(last, static_cast\u0026lt;const_iterator\u0026gt;(endptr), first); while(newendptr \u0026lt; endptr){ alloc.destroy(--endptr); } return endptr; } 首先进行合法性检测。然后，使用std::copy将后面的内容部分复制到被删除的部分。注意copy被覆盖的部分会自动调用赋值函数，赋值函数内应该会调用析构函数。然后，如果还有需要析构的内容（这种情况发生在所移动的内容没有删除的内容长时才会发生），析构这些内容。之后返回end指针。\n另外一个重载函数实现比较简单：\ntemplate\u0026lt;typename T\u0026gt; typename vector\u0026lt;T\u0026gt;::iterator vector\u0026lt;T\u0026gt;::erase(const_iterator position) { return erase(position, position+1); } ","date":"2017-12-30T08:49:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/c++/c++%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-stl-%E4%B8%AD%E7%9A%84vector/","title":"c++如何实现 STL 中的vector"},{"content":"根据c++ primer第五版总结，可以用来快速回顾一下这些性质 long long 类型 定义为至少有32位那么长。一般没用。\n列表初始化 列表是一组由花括号和逗号组成的元素集合，例如{1,2,3}。 我们可以使用花括号来进行初始化变量。 int a{0}; 等号运算符在声明时不是赋值，而是初始化，所以也可以用下面的形式初始化： int a = {0}; 这样的效果和int a = 0;是一样的。\nnullptr 常量 这是由于在c++11之前，为指针赋值空指针用的是0来直接赋值的。现在使用nullptr更好。nullptr实质上是一个只可以有右值并只能类型转换为指针且值为0地址的一个对象，由此可以解决一些问题，相关资料可以查看如何实现nullptr。\nconstexpr 变量 const expressions 常量表达式的意思。和const修饰的区别是，const表示这个变量名在之后使用的时候得是常量，而constexpr不仅如此，还要求初始化该变量时使用的表达式必须也为常量才可以。\n类型别名 using uint = unsigned int typedef uint unsigned int 这两句是等价的\nauto 类型说明符 声明并定义变量时，求助编译器根据定义类型自动推断声明的变量类型。\ndecltype 类型指示符 声明变量时，可以使用decltype(expressions)求出表达式的类型，作为被声明变量的类型\n类内初始化\nclass A { public: int a = 7; }; 这等同于之前版本中的：\nclass A { public: int a; A() : a(7) {} }; 使用auto或decltype推断类型 auto len = line.size(); 自动推断string::size_type更好\n范围for语句 打印字符串中的字符 for(auto c:str) cout \u0026laquo; c \u0026laquo; endl; 类似于Python中的for in语句\nvector嵌套 vector\u0026lt;vector这里在旧的编译器上需要有个空格不能让两个尖尖连在一起\u0026gt;\n列表初始化vector对象 vector strs = {\u0026ldquo;a\u0026rdquo;, \u0026ldquo;bb\u0026rdquo;, \u0026ldquo;ccc\u0026rdquo;};\ncbegin 和 cend 返回类型是const_iterator类型的迭代器\n在二维数组中使用auto\nint mat[3][4]; int main() { for (int(*p)[4] = mat; p != mat + 3; p++) { /* ... */ } for (auto p = mat; p != mat + 3; p++) { /* ... */ } } 除法取整 c++11规定除法一律向0取整\n列表赋值vector对象 vector strs; strs = {\u0026ldquo;a\u0026rdquo;, \u0026ldquo;bb\u0026rdquo;, \u0026ldquo;ccc\u0026rdquo;};\n139 使用sizeof获取类的成员的大小 通常情况下只有通过对象才能访问类的成员。但是sizeof可以直接判断成员大小。\n168 范围for语句 在范围for语句中不能增加vector对象的元素，这是因为可能导致范围for语句的end元素变得无效了。这和Python中范围循环可能导致的问题是一样的。\n197 initializer_list initializer_list是一种模板类型，对象元素永远是常量，类型必须相同。花括号的列表就是这种对象。\n203 列表初始化返回值 return 一个 initializer_list 列表可以对返回类型为vector的对象进行临时量初始化。\n206 定义尾置返回类型 声明一个返回数组指针的函数 int * func(int i)这样是不太对的，因为返回了一个指针而不是数组指针 int (* func(int i))[10] 这样的话才是返回大小为10的一个数组指针 也可以这样写：auto func(int i) -\u0026gt; int(*)[10];\n206 使用decltype简化返回类型 可以使用decltype来简化返回类型，但是这种需求较少见。\n214 constexpr 函数 constexpr 函数是返回类型为字面值的函数，且只能有一条return语句。\n237 default默认构造函数 可以对构造函数赋值等号表示使用编译器提供的默认的构造函数。\n246 类内的初始化 新标准可以在类内就初始化赋值成员\n261 委托构造函数 构造函数初始化时，使用初始值列表来初始化成员。除此之外，还可以使用其他构造函数帮助构造。 例如构造函数是func(int a,int b)委托构造函数func():func(0,0){}这样就可以当做默认是0,0来构造了。\n268 constexpr 构造函数 用于生成constexpr对象\n284 使用string类型来表示文件路径 在stream类型中，原来只能使用c字符串，现在可以使用string类型的字符串了\n293 array 与 forward_list 非常的快，与手写list速度相当，比数组安全\n300 使用列表初始化容器 list authors = {\u0026ldquo;milton\u0026rdquo;, \u0026ldquo;shakespeare\u0026rdquo;, \u0026ldquo;austen\u0026rdquo;}; vector\u0026lt;const char*\u0026gt; articles = {\u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;, \u0026ldquo;cc\u0026rdquo;};\n303 容器的非成员swap 使用swap可以快速交换两个内容的容器\n308 使用insert的返回之值 新标准的insert在插入成功之后返回一个迭代器，该迭代器的位置是指向插入的新元素。使用这个特性可以反复在该位置插入多个元素。\n308 使用emplace函数 使用emplace函数可以实现构造而不是复制。 使用这个方法可以传入构造函数所所需要的参数而不用构造出对象在2复制一份进取。\nshrink_to_fit 对容器调用该函数，会释放多余的vector或者是string所占用的空间。一般没什么用\nstring 类型的数值转换函数 to_string 表示一组重载函数，可以将int、double类型的数据转换为string类型的数据。 Stoi 可以将string转换为int，类似的还有其他的函数，包括不同基的、还有浮点数的\n346 lambda 表达式 简单的lambda表达式 auto f = []{return 42；}; 这里将一个lambda表达式赋值给f。之后可以调用f()获得42 如何向lambda表达式传递参数？ [](int a, int b){return a\u0026gt;b;}; 但是有的时候不想传递参数，仍然使得lambda表达式使用外部的变量怎么办？ [\u0026amp;out](int a, int b){return a\u0026lt;out \u0026amp;\u0026amp; out \u0026lt; b;}; 但是我不想让上面这个表达式返回int，而是double怎么办？ [\u0026amp;out](int a, int b)-\u0026gt;double{return a\u0026lt;out \u0026amp;\u0026amp; out \u0026lt; b;}\n354 bind bind函数可以将一个函数的调用改成简单的调用\n377 关联容器的列表初始化 map\u0026lt;string, string\u0026gt; authors={ {\u0026ldquo;joncy\u0026rdquo;, \u0026ldquo;james\u0026rdquo;} }; set exclude = {\u0026ldquo;the\u0026rdquo;, \u0026ldquo;but\u0026rdquo; };\n380 列表初始化pair的返回类型 return 一个 {}表示的列表到pair类型可以自动转换。\n384 pair的列表初始化 当向map插入pair时，最简单的方式是插入花括号表示的一对键值。插入的内容会初始化为pair插入。\n394 无序容器 map和set前面加上unordered就是无序容器。底层使用hash实现。需要实现存储元素的hash模板。\n400 智能指针 shared_ptr允许多个指针指向同一个对象。unique_ptr则独占所指的对象。 智能指针是模板，在声明时需要显示提供类型，类似vector的使用。 shared_ptr p1;\n","date":"2017-12-28T07:31:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/c++/c++11-%E7%89%B9%E6%80%A7-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/","title":"c++11 特性 简单介绍"},{"content":"前言 epoll是Linux专有API，提供高效的文件描述符管理，常用于批量监听文件描述符的可读情况，是高并发服务器的有效手段之一。下面是一个简单的epoll服务器与客户端例子。\n服务器端 #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/epoll.h\u0026gt; using namespace std; const int MAX_EPOLL_EVENTS = 1000; const int MAX_MSG_LEN = 1024; void setFdNonblock(int fd) { fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) | O_NONBLOCK); } void err_exit(const char *s){ printf(\u0026#34;error: %s\\n\u0026#34;,s); exit(0); } int create_socket(const char *ip, const int port_number) { struct sockaddr_in server_addr = {0}; /* 设置ipv4模式 */ server_addr.sin_family = AF_INET; /* ipv4 */ /* 设置端口号 */ server_addr.sin_port = htons(port_number); /* 设置主机地址 */ if(inet_pton(server_addr.sin_family, ip, \u0026amp;server_addr.sin_addr) == -1){ err_exit(\u0026#34;inet_pton\u0026#34;); } /* 建立socket */ int sockfd = socket(PF_INET, SOCK_STREAM, 0); if(sockfd == -1){ err_exit(\u0026#34;socket\u0026#34;); } /* 设置复用模式 */ int reuse = 1; if(setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, \u0026amp;reuse, sizeof(reuse)) == -1) { err_exit(\u0026#34;setsockopt\u0026#34;); } /* 绑定端口 */ if(bind(sockfd, (sockaddr *)\u0026amp;server_addr, sizeof(server_addr)) == -1){ err_exit(\u0026#34;bind\u0026#34;); } /* 设置被动打开 */ if(listen(sockfd, 5) == -1){ err_exit(\u0026#34;listen\u0026#34;); } return sockfd; } int main(int argc, const char *argv[]) { /* 帮助 */ if(argc \u0026lt; 3){ printf(\u0026#34;usage:%s ip port\\n\u0026#34;, argv[0]); exit(0); } /* 获取服务器参数 */ const char * ip = argv[1]; const int port = atoi(argv[2]); /* 创建套接字 */ int sockfd = create_socket(ip, port); printf(\u0026#34;success create sockfd %d\\n\u0026#34;, sockfd); setFdNonblock(sockfd); /* 创建epoll */ int epollfd = epoll_create1(0); if(epollfd == -1) err_exit(\u0026#34;epoll_create1\u0026#34;); /* 添加sockfd到epollfd兴趣列表 */ struct epoll_event ev; ev.data.fd = sockfd; ev.events = EPOLLIN ; if(epoll_ctl(epollfd, EPOLL_CTL_ADD, sockfd, \u0026amp;ev) == -1){ err_exit(\u0026#34;epoll_ctl1\u0026#34;); } /* 创建一个列表用于存放wait所返回的events */ struct epoll_event events[MAX_EPOLL_EVENTS] = {0}; /* 开始等待所有在epoll上挂上去的事件 */ while(1){ /* 等待事件 */ printf(\u0026#34;begin wait\\n\u0026#34;); int number = epoll_wait(epollfd, events, MAX_EPOLL_EVENTS, -1); printf(\u0026#34;end wait\\n\u0026#34;); sleep(1); if(number \u0026gt; 0){ /* 遍历所有事件 */ for (int i = 0; i \u0026lt; number; i++) { int eventfd = events[i].data.fd; /* 如果触发事件的fd是sockfd，则说明有人连接上来了，我们需要accept他 */ if(eventfd == sockfd){ printf(\u0026#34;accept new client...\\n\u0026#34;); struct sockaddr_in client_addr; socklen_t client_addr_len = sizeof(client_addr); int connfd = accept(sockfd, (struct sockaddr *)\u0026amp;client_addr, \u0026amp;client_addr_len); setFdNonblock(connfd); /* accept之后，需要将文件描述符加入到监听列表中 */ struct epoll_event ev; ev.data.fd = connfd; ev.events = EPOLLIN; if(epoll_ctl(epollfd, EPOLL_CTL_ADD, connfd, \u0026amp;ev) == -1){ err_exit(\u0026#34;epoll_ctl2\u0026#34;); } printf(\u0026#34;accept new client end.\\n\u0026#34;); } /* 如果触发的fd不是sockfd，那就是新加的connfd */ else{ /* 读出内容，直到遇到回车。然后显示该内容。 */ printf(\u0026#34;read start...\\n\u0026#34;); while(1){ char buff = -1; int ret = read(eventfd, \u0026amp;buff, 1); if(ret \u0026gt; 0){ printf(\u0026#34;%c\u0026#34;, buff); } if(buff == \u0026#39;\\n\u0026#39;){ break; } else if (ret == 0){ printf(\u0026#34;client close.\\n\u0026#34;); close(eventfd); epoll_ctl(epollfd, EPOLL_CTL_DEL, eventfd, NULL); break; } else if (ret \u0026lt; 0){ printf(\u0026#34;read error.\\n\u0026#34;); break; } } printf(\u0026#34;read end.\\n\u0026#34;); } } } } } 客户端 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; void err_exit(const char *s){ printf(\u0026#34;error: %s\\n\u0026#34;,s); exit(0); } int create_socket(const char *ip, const int port_number) { struct sockaddr_in server_addr = {0}; /* 设置ipv4模式 */ server_addr.sin_family = AF_INET; /* ipv4 */ /* 设置端口号 */ server_addr.sin_port = htons(port_number); /* 设置主机地址 */ if(inet_pton(PF_INET, ip, \u0026amp;server_addr.sin_addr) == -1){ err_exit(\u0026#34;inet_pton\u0026#34;); } /* 建立socket */ int sockfd = socket(PF_INET, SOCK_STREAM, 0); if(sockfd == -1){ err_exit(\u0026#34;socket\u0026#34;); } if(connect(sockfd, (struct sockaddr*)\u0026amp;server_addr, sizeof(server_addr)) == -1){ err_exit(\u0026#34;connect\u0026#34;); } return sockfd; } int main(int argc, const char *argv[]){ if(argc \u0026lt; 3){ printf(\u0026#34;usage:%s ip port\\n\u0026#34;, argv[0]); exit(0); } /* 获取服务器参数 */ const char * ip = argv[1]; const int port = atoi(argv[2]); //创建套接字 int sock = create_socket(ip, port); //向服务器（特定的IP和端口）发起请求 while(1){ string buff; getline(cin, buff); if(buff == \u0026#34;exit\u0026#34;) break; write(sock, buff.c_str(), buff.size()); char end = \u0026#39;\\n\u0026#39;; write(sock, \u0026amp;end, 1); } close(sock); return 0; } 编译 将上述文本存为socket_server.cpp与socket_client.cpp，编译链接该程序。\ng++ -Wall socket_server.cpp -o server \u0026amp;\u0026amp; g++ -Wall socket_client.cpp -o client 运行 ./server localhost 1234 ./client localhost 1234 在client端输入文字并回车，会出现在服务器端。按下Ctrl C关闭客户端或者输入exit关闭客户端。\n运行流程 服务器首先创建被动打开socket文件描述符，然后将该文件描述符加入到epoll兴趣列表。接下来进入循环。每当兴趣列表wait结束时，说明对应文件描述符可以进行操作。当有客户端连上被动打开socket文件描述符时，说明有客户端连上，被动打开文件描述符可以被accept。accept后所创建的新的文件描述符是与客户端通信的文件描述符，该文件描述符继续加入兴趣列表。当客户端发送数据时，该文件描述符也会产生可读信号，会导致wait结束，此时进入处理模式，读取并显示客户端所发送的数据。\n","date":"2017-12-25T02:52:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E7%BD%91%E7%BB%9C/epoll-tcp%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AE%80%E6%98%8E%E4%BE%8B%E5%AD%90/","title":"epoll TCP服务器与客户端简明例子"},{"content":"前言 面经中提到的epoll，涉及到了socket编程。为了深入了解epoll原理，需要首先了解socket编程。socket是进程间通信IPC，就算在网络中也是如此，所以说网络中通信的主体是进程，而不是计算机。socket学习内容一个是如何建立服务器和客户端，一个是如何使用socket API。\nfd=socket(domain, type, protocol); socket调用可以用来创建一个socket，例如 domain可以用来指定ipv4，type可以用来指定tcp，protocol一般是0。\ndomain domain是通信范围与通信地址的类型。有下面几个经典类型： UNIX IPV4 IPV6，分别对应的参数是AF_UNIX AF_INET AF_INET6。 domain 的参数都是以AF开头的代表地址簇。PF开头的代表协议簇。本来设计是地址簇和协议簇是多对多的，但是后来实现过程中，一个协议簇和地址簇是一一对应的。所以基本上domain就是指定了协议簇，地址簇也被指定了。\ntype socket表示是流还是数据包，其实就是TCP还是UDP。如果是TCP就是SOCK_STREAM，如果是UDP就是SOCK_DGRAM\nbind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 该调用用于将socket绑定到一个地址上。之后可以发送TCP报文，在一些场合下也可以通过write发送UDP报文，但是只能在该socket上读取对等socket数据。\nsockaddr 该结构体有一个整形表示地址类型，然后后面跟着一个char数组。后面可以看到具体传进来的是根据使用场合的其他数据结构，但是是通用的 listen(int sockfd, int backlog) 将一个socket描述符标记为被动。可以被主动socket连接。backlog是用于限制等待连接的数量。\naccept(int sockfd, struct sockaddr *addr, socklen_t * addrlen); accept调用会阻塞并等待在文件描述符sockfd上的接入请求。一旦请求成功，会创建一个新的socket，这个新的socket与对方进行连接。\naddr 返回对方的地址 addrlen 传入addr的长度，用于告知能够写入输入的最大长度。 connect(int sockfd, const struct sockaddr * addr, socklen_t addrlen); 将sockfd连接到addr所述的地址上。\nclose(int fd) 用于关闭连接\nread write 用于对sockfd进行读入或读出\nrecvfrom(int sockfd, void *buffer, size_t length, int flags, struct sockaddr *src_addr, socklen_t *addrlen); sendto(int sockfd, const void *buffer, size_t length, int flags, const struct sockaddr *dest_addr, socklen_t addrlen); 用于发送和接受udp报文。服务器端不能使用listen函数和accept函数，客户端不能使用connect函数。\nunix domain 使用上面的API就可以实现本机上通过文件的通信。 unix domain所使用的sockaddr是sockaddr_run，如下表示：\nstruct sockaddr_un{ sa_family_t sun_family; char sun_path[108]; } 网络字节序 网络字节顺序是按照大端来的，x86是小端结构。转换使用的是如下的函数进行的\nhtons htonl ntohs ntohl h是host，n是net，s是16位，l是32位。s和l是short和long，虽然现在已经不再使用这样的标准了。 Internet socket 地址结构 网络下使用的socket地址是sockaddr_in，定义如下\nstruct sockaddr_in{ sa_family_t sin_family; in_port_t sin_port; struct in_addr sin_addr; unsigned char __pad[X]; } 可以看出不一样的地方是后面的char数组变成了一个端口和地址。sin是socket Internet的简写，简写的和sun一样很差。\nInternet socket 地址转换 字符串式的地址格式和二进制地址格式转换API:\ninet_pton(int domain, const char *src, void *addrptr); 该函数用于将src中包含的字符串转换为网络字节的二进制地址，存入addrptr。p是presentation的意思，就是人类方便的地址。\nconst char * inet_ntop(int domain, const void *addrptr, char *dst_str, size_t len); 该函数执行网络字节的二进制地址转换为人类可读的地址，写入到dst_str中，缓冲区的大小有len传入。\ngetaddrinfo(const char *host, const char *service, const struct addrinfo *hints, struct **result); 该函数给定一个主机名和服务器名，返回socket地址和端口号。 getaddrinfo以host、service、hints参数作为输入，其中host参数包括一个主机名或一个以IPV4字符串。service是服务名或者是端口号。该函数的调用之后需要使用freeaddrinfo来释放空间。\ngetnameinfo(const struct sockaddr *addr, socklen_t addrlen, char *host, size_t hostlen, char *service, size_t servlen, int flags); 给定一个socket地址结构，返回一个主机和服务器名的字符串。\nsetsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen); sockfd是代表指向套接字的文件描述符。参数level制定了套接字选项所适用的协议。例如TCP或者是IP，这表示选项作用的套接字API层。一般来说，该选项会设置为SOL_SOCKET，表示作用于套接字API层。参数optname表示了我们期待设置的选项，optvalue是用来设置刚刚的选项的值，可以是整数或者是结构体的指针，指向了一个缓冲区，而参数optlen是刚刚那个指针所指向区域的大小。\n例如，要设置sockfd为reuseaddr属性时，可以如下调用：\nint reuse = 1; if(setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, \u0026amp;reuse, sizeof(reuse)) == -1) { err_exit(\u0026#34;setsockopt\u0026#34;); } getsockopt(int sockfd, int level, int optname, void *optval, socklen_t optlen); 用法和上面一样，只是获取而已。\n","date":"2017-12-25T02:34:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E7%BD%91%E7%BB%9C/socket-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"SOCKET 学习笔记"},{"content":" I/O 多路复用 信号驱动I/O Linux专有epoll I/O多路复用 通过select系统调用或者poll系统调用，来对文件描述符进行检查。\nselect函数 int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout); 参数分别的意思是：需要测试的fd范围0～fd-1，满足三种情况要求的文件描述符号，超时时间。 poll函数 int poll(struct pollfd fds[], nfds_t nfds, int timeout); 参数分别是：元素包含文件描述符、需要检查的状态、返回的状态的一个数组，数组长度以及超时时间。 二者的区别在于poll里面传进去的数组大小不受fd_set定义的大小限制。poll的events和revents更丰富一些。select用的更为广泛一些。新版中select的性能经过优化与poll差不多。\nepoll函数 epoll函数包括三个API：epoll_create()、epoll_ctl()、epoll_wait()三个调用。 epoll是三个调用中性能最好，效果最多的。但是只有Linux才可以使用。 主要是因为服务器上面会连接多个socket链接，如果为每一个套接字建立一个线程的话，会比较占用资源，所以需要使用epoll来优化性能。\n","date":"2017-12-21T06:18:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E7%BD%91%E7%BB%9C/%E5%85%B6%E4%BB%96-i-o-%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/","title":"其他 I/O 模型总结"},{"content":"前言 C++与C最大的不同是面向对象。虽然我了解一些有关面向对象的概念，写过一些函数，可惜实际中很少用到。本文是C++ Primer第15章的快速总结。\n概述 面向对象程序设计又称为OOP，其核心思想是：数据抽象、继承和动态绑定。数据抽象指的是，声明与实现分离，继承指的是子类获得父类的所有成员，动态绑定是调用类的函数时根据类的不同进行区别调用。\n声明基类与派生类 下面的代码进行简单的示例，声明了一个基类animal与派生类cat。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;iostream\u0026gt; class animal { public: virtual void eat(){}; }; class cat : public animal { public: void eat() { std::cout \u0026lt;\u0026lt; \u0026#34;eat fish\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { cat c; c.eat(); } 类型转换与继承 派生类的指针和引用可以转为基类的指针或引用，基类的指针或引用不能转化为派生类的指针或引用。这意味着，一个基类的指针，指向的对象，有可能是基类，也有可能是派生类，但肯定不是基类的父类。\n派生类对象可以赋值给基类，但只会拷贝基类的部分。\n虚函数 虚函数在运行时进行解析。我们继续上面的例子，假如我们写了一个新的函数，是doeat，内部调用了animal的eat方法。eat对animal是eat meat or grass，但是最后显示的结果是eat fish。这就证明了，在运行时，doeat函数调用animal的eat方法时，eat方法找到了引用对象的真实对象cat的eat方法并进行了调用。\nclass animal { public: virtual void eat() { std::cout \u0026lt;\u0026lt; \u0026#34;eat meat or grass\u0026#34; \u0026lt;\u0026lt; std::endl; }; }; class cat : public animal { public: void eat() { std::cout \u0026lt;\u0026lt; \u0026#34;eat fish\u0026#34; \u0026lt;\u0026lt; std::endl; } }; void doeat(animal \u0026amp;a) { a.eat(); } int main() { cat c; doeat(c); } 另外，为了养成良好的习惯，在派生类中最好使用override来显式的声明覆盖的虚函数。\n纯虚函数 在定义虚函数后赋值为0则声明了纯虚函数，纯虚函数相当于接口，派生类必须实现该接口。\n抽象基类 含有纯虚函数的类是抽象基类。抽象基类不能创建。\n示例 文本行查询程序 给定一段文本，要求查询其中的内容。支持单词查询、逻辑查询。\n","date":"2017-12-14T05:53:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/c++/c++-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E6%80%BB%E7%BB%93/","title":"C++ 面向对象程序设计 总结"},{"content":"虚函数是 C++ 实现多态的方式。\n什么是多态？ 多态性常被视为自封装和继承之后，面向对象的编程的第三个支柱。 如果举一个简单的例子，比如有动物（Animal）之类别（Class），而且由动物继承出类别鸡（Chicken）和类别狗（Dog），并对同一源自类别动物（父类别）之一消息有不同的响应，如类别动物有“叫()”之动作，而类别鸡会“啼叫()”，类别狗则会“吠叫()”，则称之为多态。 根据维基百科上所解释，多态可定义为，“一种将不同的特殊行为和单个泛化记号相关联的能力”，是指计算机程序运行时，相同的消息可能会送给多个不同的类别之对象，而系统可依据对象所属类别，引发对应类别的方法，而有不同的行为。简单来说，所谓多态意指相同的消息给予不同的对象会引发不同的动作称之。 虚函数是动态多态，在运行时决定，只有在程序运行时才决定调用基类的还是子类的，系统会根据基类指针所指向的对象来决定要调用的函数。\n如何声明虚函数？ 在声明前加上virtual关键字来声明虚函数。在父类中声明，在子类中做具体实现。\n什么是纯虚函数？ 纯虚函数是在声明虚函数时赋值为0的函数，使用这种声明方式后，继承类必须对该虚函数做实现。\n虚函数是如何实现的？ 通过虚表来实现的。每个对象里有虚表指针，指向虚表。虚表实质上是一个数组而不是什么链表。虚函数的地址按照声明顺序依次存放在虚表中。\n虚函数表是怎么实现的？ 为了完成虚函数的功能，编译器（注，这就是为什么C++会被叫做面向编译器编程的原因）会对每一个内部成员声明了虚函数的类创建一个表，称为vtable。在vtable中，以声明顺序放置特定类型的虚函数地址。每一个带有虚函数类的内部都会放置一枚指针，称为vpointer，或者叫vptr，指向这个vtable。每当发生对类的虚函数的调用时，编译器转为调用这个vptr指向的vtable中的函数，而不是静态的调用某个具体的函数。\n","date":"2017-12-14T05:53:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/c++/c++-%E8%99%9A%E5%87%BD%E6%95%B0-%E6%80%BB%E7%BB%93/","title":"C++ 虚函数 总结"},{"content":"system命令返回值是个整型，很难判断具体情况是否正确。可以通过popen来执行bash命令，并获取返回值。注意popen获取的字符串返回值是标准输出，如需获取错误输出内容需要将错误输出重定向至标准输出中。\nvoid system_cmd(const char * command, char * result) { FILE *fpRead; fpRead = popen(command, \u0026#34;r\u0026#34;); char buf[1024] = {0}; memset(buf,\u0026#39;\\0\u0026#39;,sizeof(buf)); while(fgets(buf,1024-1,fpRead)!=NULL) { if (buf[strlen(buf) - 1] == \u0026#39;\\n\u0026#39;) { buf[strlen(buf) - 1] = \u0026#39;\\0\u0026#39;; //去除换行符 } strcpy(result, buf); } if(fpRead!=NULL) pclose(fpRead); } 调用示例：\nchar pid[10]={0}; system_cmd(\u0026#34;pgrep bash\u0026#34;, pid); ","date":"2017-11-08T07:22:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/linux%E7%BC%96%E7%A8%8B/linux-popen%E6%89%A7%E8%A1%8Cbash%E5%91%BD%E4%BB%A4%E5%B9%B6%E8%8E%B7%E5%8F%96%E8%BF%94%E5%9B%9E%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"Linux popen执行bash命令并获取返回字符串"},{"content":"前言 虽然有很多教程都给出了如何在Ubuntu上安装Tensorflow，但是却没有一篇文章讲如何在Deepin系统安装Tensorflow，这里将安装过程的几个要点讲解一下\n流程 首先下载Nvidia的Linux驱动。在官网可以下载。然后运行，如果不能运行，则需要修改驱动运行权限，使用chmod u+x来添加运行权限。关于deepin安装显卡驱动，可以参考这个文章 https://wiki.deepin.org/index.php?title=%E6%98%BE%E5%8D%A1 安装Docker-ce。这里一定要遵循官方的安装方案，只此一个方法可以正常安装最新版docker。https://wiki.deepin.org/index.php?title=Docker 下载Nvidia-docker。在Github的Nvidia-Docker页面找到Ubuntu的安装包和安装步骤，安装即可 接下来运行 docker run -it -p 8888:8888 tensorflow/tensorflow:latest-gpu 此时可以进入官方的tensorflow带GPU版本的镜像啦，打开localhost:8888可以看到jupyter的页面 坑 在安装Nvidia显卡驱动的时候，根据安装软件的提示，需要关闭Linux的桌面系统X server，此时可以通过tty1~6来进行终端操作。但是如果Deepin已经安装了自带的Nvidia驱动，要停止lightdm服务时，在Deepin在关闭X server的同时，显示器也关闭了，无法显示tty1 ~6的屏幕，由于这个问题，导致Nvidia驱动无法安装。即使手动卸载安装的Deepin官方Nvidia驱动，经过了繁琐的卸载指令，在切换到tty1 ~6后，在关闭图形界面的时候，仍然会导致tty屏幕被关闭，黑屏一片，无法继续后面的驱动卸载和重新安装官方Nvidia驱动。\n解决方案 为了避免Nvidia驱动无法安装，又能简洁科学的操作，所以必须在第一次安装Deepin系统的时候，在未安装显卡驱动的情况下对电脑进行操作进行安装Nvidia显卡官方linux驱动，首先按下快捷键“Ctrl+Alt+F2”，进入tty2，然后输入sudo systemctl stop lightdm 停止lightdm服务，此时电脑关闭X server的时候不会导致显示器的关闭，之后运行chmod u+x NVIDIA-Linux-x86_64-352.55.run #赋予可执行权限 以及sudo ./NVIDIA-Linux-x86_64-352.55.run #安装驱动文件 然后重启就可以正常的使用官方闭源驱动啦。\n后续 使用GPU来运行Tensorflow程序是非常快的。一般的程序可以提速10倍以上，有些程序可以提速50到100倍的速度，所以使用GPU来进行Tensorflow编程是非常有必要的。 另外，不知道是Deepin的问题还是Nvidia-Dcoker的问题还是驱动的问题，在电脑待机之后会导致Tensorflow镜像出错，所以在训练的时候不要让机器进行待机动作。\n","date":"2017-09-13T10:44:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/deepin-%E5%AE%89%E8%A3%85-gpu%E7%89%88-tensorflow-%E8%A6%81%E7%82%B9/","title":"Deepin 安装 GPU版 Tensorflow 要点"},{"content":"案例 假如我有一系列的数据x-y，x-y之间是呈线性关系的，如果我们需要用一条直线拟合这条直线，我们该如何做？\n下面的程序中，train_x是一系列从-1到1之间的数字，train_y是x的两倍加10，然后随机加了一个0~1之间的数字 接下来我们建立模型，X和Y是一个待初始化的张量占位符，在优化过程中，模型中的XY会一直改变为train_x和train_y中的数据，然后优化器会进行优化，使得w斜率和b截距按照使误差减小的方向变化，这样，w和b经过迭代最终就使模型满足数据了\n模型建立好了以后，我们开始运行模型。首先打开一个会话，然后一定要记得初始化全部变量。接下来我们对全体数据进行10次遍历，在每一次迭代过程中，将一个坐标输入，并计算误差，然后利用梯度下降更正w和b。最后，我们输出解出来的w和b。\nimport tensorflow as tf import numpy as np train_x = np.linspace(-1, 1, 101) train_y = 2 * train_x + np.random.rand(train_x.shape[0]) + 10 X = tf.placeholder(\u0026#34;float\u0026#34;) Y = tf.placeholder(\u0026#34;float\u0026#34;) w = tf.Variable(0.0, name = \u0026#34;w\u0026#34;) b = tf.Variable(0.0, name = \u0026#34;b\u0026#34;) loss = tf.square(Y - tf.multiply(X,w) - b) train_op = tf.train.GradientDescentOptimizer(0.01).minimize(loss) with tf.Session() as session: session.run(tf.global_variables_initializer()) for i in range(10): for x,y in zip(train_x, train_y): session.run(train_op, feed_dict={X:x, Y:y}) print(\u0026#34;w: \u0026#34;, session.run(w)) print(\u0026#34;b: \u0026#34;, session.run(b)) 运行效果： ","date":"2017-08-09T07:08:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/tensorflow-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%85%A5%E9%97%A8%E7%94%A8%E4%BE%8B/","title":"TensorFlow 一个简单的入门用例"},{"content":"快速安装教程 一、安装docker https://www.docker-cn.com/community-edition#/download\n然后配置官方中国镜像。\n二、tensorflow环境搭建 $ docker run -it -p 8888:8888 tensorflow/tensorflow 运行上述命令会自动下载tensorflow镜像，前提是仓库镜像设置成中国的镜像，否则下载很慢。运行命令后，命令行会出现一个网址，会提示你打开网页，打开这个网址以后会显示tensorflow的jupyter编辑环境，之后我们将在网页中输入所有代码。\n挂载docker的文件目录 如果我们需要打开本地文件，需要挂载本地的文件夹到容器目录中。关闭容器，重新打开容器，使用-v 主机目录:容器目录来进行挂载。 docker run -v /Users/hahaha/tensorflow/:/notebooks -it -p 8888:8888 tensorflow/tensorflow 其中/Users/hahaha/tensorflow/是我的mac的一个文件夹，根目录下的notebooks是tensorflow中的jupyter默认编辑目录。\n运行hello world 代码 新建一个Python2 Jupyter文件，在文件中输入如下的代码，然后点击播放按钮，此时在下方应该会出现一段Hello, TensorFlow!字符串。说明程序运行成功了。\n程序解释 从这段简单的代码可以了解到TensorFlow的使用非常方便，通过Python标准库的形式导入，不需要启动额外的服务。第一次接触TensorFlow可能比较疑惑，输出一段helloworld Python本身可以实现，为什么要使用tf.constant()和tf.Session()呢？其实TensorFlow通过Graph和Session来定义运行的模型和训练，这在复杂的模型和分布式训练上有非常大好处。 首先，在TensorFlow中，有Graph和Operation这两个概念。Operation代表需要计算的内容。一个Graph中有很多Operation。通过Session来执行Graph中的Operation。\n基本使用 使用 TensorFlow, 你必须明白 TensorFlow:\n使用 图 (graph) 来表示计算任务. 在被称之为 会话 (Session) 的 上下文 (context) 中执行图. 使用 tensor 表示数据. 通过 变量 (Variable) 维护状态. 使用 feed 和 fetch 可以为任意的操作(arbitrary operation) 赋值或者从其中获取数据. 综述 TensorFlow 是一个编程系统, 使用图来表示计算任务. 图中的节点被称之为 op (operation 的缩写)。 一个 op 使用 0 个或多个 Tensor ，执行计算产生0个或多个 Tensor。 每个 Tensor 是一个类型化的多维数组。 例如，你可以将一小组图像集表示为一个四维浮点数数组，这四个维度分别是 [batch, height, width, channels]。\n一个 TensorFlow 图 描述 了计算的过程。 为了进行计算，图必须在会话 里被启动。 会话 将图的 op 分发到诸如 CPU 或 GPU 之类的设备上，同时提供执行 op 的方法。这些方法执行后， 将产生的 tensor 返回。 在 Python 语言中, 返回的类型是 tensor 是numpy中的ndarray对象。在 C 和 C++ 语言中, 返回的 tensor 是 tensorflow::Tensor 实例。\n","date":"2017-08-08T09:58:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/tensorflow-hello-world-%E5%85%A5%E9%97%A8/","title":"TensorFlow Hello World 入门"},{"content":"引入必要库 import csv import tensorflow as tf import numpy as np import random import sys import pandas as pd from pandas import DataFrame from __future__ import absolute_import from __future__ import division from __future__ import print_function 读取源文件并打印 在这部分，我们接触了基本的csv操作，并显示结果。 我们读入kaggle上下载的train.csv文件，并展示内容\ntrainFilePath = \u0026#39;./train.csv\u0026#39; trainSize = 0 def testCSV(filePath): with open(filePath, \u0026#39;rb\u0026#39;) as trainFile: global trainSize csvReader = csv.reader(trainFile) dataList = [data for data in csvReader] df = DataFrame(dataList[1:], columns=dataList[0]) trainSize = len(df) print(df) print(\u0026#34;trainSize\u0026#34;, trainSize) testCSV(trainFilePath) 读取源文件并提取数据，建立神经网络 在这部分，我们读取源文件中的性别，阶级，船费以及SibSp，用于拟合最终的生存概率 然后我们建立一个总共5层，中间3层的神经网络，神经元的个数分别是4-10-20-10-2。 然后运行读取函数。\ndef readTrainDataCSV(filePath): global trainData, targetData, classifier with open(filePath, \u0026#39;rb\u0026#39;) as trainFile: csvReader = csv.reader(trainFile) dataList = [data for data in csvReader] dataSize = len(dataList) - 1 trainData = np.ndarray((dataSize, 4), dtype=np.float32) targetData = np.ndarray((dataSize, 1), dtype=np.int32) trainDataFrame = DataFrame(dataList[1:], columns=dataList[0]) trainDataFrame_fliter = trainDataFrame.loc[:,[\u0026#39;Pclass\u0026#39;,\u0026#39;Sex\u0026#39;,\u0026#39;SibSp\u0026#39;,\u0026#39;Fare\u0026#39;,\u0026#39;Survived\u0026#39;]] for i in range(dataSize): thisData = np.array(trainDataFrame_fliter.iloc[i]) Pclass,Sex,SibSp,Fare,Survived = thisData Pclass = float(Pclass) Sex = 0 if Sex == \u0026#39;female\u0026#39; else 1 SibSp = float(SibSp) Fare = float(Fare) Survived = int(Survived) print(Pclass,Sex,SibSp,Fare,Survived) trainData[i,:] = [Pclass,Sex,SibSp,Fare] targetData[i,:] = [Survived] print(thisData) print(trainData) print(targetData) feature_columns = [tf.contrib.layers.real_valued_column(\u0026#34;\u0026#34;, dimension=4)] classifier = tf.contrib.learn.DNNClassifier(feature_columns=feature_columns, hidden_units=[10, 20, 10], n_classes=2) # model_dir=\u0026#34;/tmp/titanic_model\u0026#34;) readTrainDataCSV(trainFilePath) 创建输入数据 我们将训练数据和标签包装成一个二元组，并返回\ndef get_train_inputs(): x = tf.constant(trainData) y = tf.constant(targetData) print(x) print(y) return x, y get_train_inputs() 训练数据 我们开始训练神经网络\ndef train(): classifier.fit(input_fn=get_train_inputs, steps=2000) train() 检查准确度 我们使用整个数据集来查看准确度。注意，我们应该使用验证集来完成这件事。但是由于我们只是用来演示，所以就算了\naccuracy_score = classifier.evaluate(input_fn=get_train_inputs, steps=1)[\u0026#34;accuracy\u0026#34;] print(\u0026#34;accuracy:\u0026#34;,accuracy_score) 读入测试集，并输出结果 在这一部分，我们将读入kaggle中的数据，并输出到文件中，最终提交官网\ntestFilePath = \u0026#39;./test.csv\u0026#39; def readTestDataCSV(filePath): global testData, PassengerIdStart with open(filePath, \u0026#39;rb\u0026#39;) as testFile: csvReader = csv.reader(testFile) dataList = [data for data in csvReader] dataSize = len(dataList)-1 trainDataFrame = DataFrame(dataList[1:], columns=dataList[0]) trainDataFrame_fliter = trainDataFrame.loc[:,[\u0026#39;Pclass\u0026#39;,\u0026#39;Sex\u0026#39;,\u0026#39;SibSp\u0026#39;,\u0026#39;Fare\u0026#39;]] testData = np.ndarray((dataSize, 4), dtype=np.float32) PassengerIdStart = trainDataFrame[\u0026#39;PassengerId\u0026#39;][0] PassengerIdStart = int(PassengerIdStart) print(\u0026#39;PassengerId\u0026#39;,PassengerIdStart) for i in range(dataSize): thisData = np.array(trainDataFrame_fliter.iloc[i]) Pclass,Sex,SibSp,Fare = thisData Pclass = float(Pclass) Sex = 0 if Sex == \u0026#39;female\u0026#39; else 1 SibSp = float(SibSp) Fare = 0 if Fare==\u0026#39;\u0026#39; else float(Fare) print(Pclass,Sex,SibSp,Fare) testData[i,:] = [Pclass,Sex,SibSp,Fare] print(thisData) print(testData) def testData_samples(): return testData readTestDataCSV(testFilePath) predictions = list(classifier.predict(input_fn=testData_samples)) print(predictions) with open(\u0026#39;predictions.csv\u0026#39;, \u0026#39;wb\u0026#39;) as csvfile: writer = csv.writer(csvfile, dialect=\u0026#39;excel\u0026#39;) writer.writerow([\u0026#39;PassengerId\u0026#39;,\u0026#39;Survived\u0026#39;]) PassengerId = PassengerIdStart for i in predictions: writer.writerow([PassengerId, i]) PassengerId += 1 最终在只使用了4个特征值的情况下，准确率有75%。接下来的目标是将其他数据进行利用。\n","date":"2017-08-04T10:08:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E4%BD%BF%E7%94%A8tensorflow%E5%AE%8C%E6%88%90kaggle%E4%BB%BB%E5%8A%A1%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7titanic--machine-learning-from-disaster/","title":"使用Tensorflow完成Kaggle任务——泰坦尼克号Titanic: Machine Learning from Disaster"},{"content":"前言 源码可直接运行，支持markdown语法，支持邮箱注册，任何问题均可参考《Flask Web开发：基于Python的Web应用开发实战》。\n博客网址：http://www.unrealblue.cc 项目地址：https://github.com/linanwx/unrealblue-blog\n效果预览 部署过程 首先为了验证程序功能，需要在本机上部署，之后使用nginx反向代理工具，可以将端口号暴露出去，这样其他人就可以在公网访问你的博客了，之后在服务器进行同样的步骤。具体过程如下。\n安装virtualenv python虚拟环境，pip install virtualenv 或者 pip3 install virtualenv 。然后使用virtualenv在一个合适的目录，例如在该项目下面建立venv环境virtualenv venv， 激活virtualenv环境，运行venv目录下的activate，. venv/bin/activate， 注意点的位置，之后你会看到命令行前面多了(venv)这个标记。 在虚拟环境下安装所有requirements.txt中的模块, pip3 install -r requirements.txt。如果安装太慢，你可能需要配置pip的国内源。更改pip源的方法参见pip官方页面。 导入坏境变量，在项目目录下创建文件 env ，输入如下字段： MAIL_USERNAME=email@example.com (服务器发验证码用的邮箱，开启了smtp服务的邮箱账号，程序里默认使用qq邮箱，修改config文件可成其它类型邮箱) MAIL_PASSWORD=password (上面邮箱的密码，注意qq邮箱使用特殊16位专用密码) FLASK_ADMIN=admin@example.com (服务器运行后，使用该邮箱创建账号就是管理者) MAIL_SERVER=smtp.qq.com(邮箱服务器地址) FLASKY_MAIL_SENDER=example@foxmail.com(发送人) 安装数据库迁移。输入以下命令 python manager.py db init (使用init命令创建迁移仓库，此时会多出 migrations 文件夹) python manager.py db migrate -m \u0026quot;initial migration\u0026quot;(migrate命令用来自动创建迁移脚本) python manager.py db upgrade(更新数据库，第一次使用该命令会新建一个数据库data-dev.sqlite) 部署程序， python manager.py deploy 在本地运行程序, python manager.py runserver打开 http://127.0.0.1:5000 端口查看，按Ctrl+C退出程序。 如果在服务器运行，要保留数据，则可以复制数据库 migrations 文件夹以及数据库 data-dev.sqlite 到服务器，然后使用 ./venv/bin/gunicorn -w 4 -b 127.0.0.1:8080 manager:app 此时应该可以查看8080端口显示了网页，且该端口是暴露外网的。在本地浏览器输入服务器地址，此时就可以看到博客了。 ","date":"2017-07-30T17:38:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E7%BD%91%E7%BB%9C/%E5%9F%BA%E4%BA%8Eflask%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","title":"基于Flask的个人博客搭建"},{"content":"前言 突发奇想想学机器学习，这里是学习过程的笔记\n准备 我做了这些准备工作\nMacBook 一台，搭建好Python环境，安装numpy和matplotlib 优达学城注册免费的《深度学习》课程（Google合作） 廖雪峰Python入门教程学习 花费两天时间大致浏览《机器学习实战》 学习这些知识应该足以进行接下来的优达学城的学习\n课程一 从机器学习到深度学习 小节1-8，主要介绍了深度学习的发展现状等等知识。\n小节9-12介绍了softmax模型。\n粗略浏览机器学习实战后，在机器学习实战这本书中，大致介绍了机器学习的几种算法。从表面上来看，机器学习是一些分类和聚类算法。在这些算法中，介绍了一种算法，叫做逻辑回归分类。\n在小节9-12中，主要介绍了分类器模型——逻辑回归，分类函数使用的是softmax函数。\n什么是softmax函数 这张图片可以表明什么是softmax函数了。对原来数列中的每个数z求exp(z)，新数的大小所占的比例就是新数的softmax概率。\n性质 如果输入同比例扩大，则分类器的结果越两极化，越自信，如果输入同比例缩小，分类器结果趋于平均，不自信。\n算法 import numpy as np def softmax(x): \u0026#34;\u0026#34;\u0026#34;Compute softmax values for each sets of scores in x.\u0026#34;\u0026#34;\u0026#34; expList = [np.exp(i) for i in x] expSum = sum(expList) x = [i/expSum for i in expList] return np.array(x) 13-14节主要讲One-Hot编码。在softmax函数给出一组概率数列之后，如何确定分类呢？例如概率最高的为1，其他的为0，这样的一个数列，属于One-Hot编码。这种编码是已经确定了分类。\n15-16节讲了交叉熵。softmax可以计算概率数列，OneHot是已经确定的分类，那如何计算概率数列到某个分类的距离呢？使用交叉熵来度量这个距离。\n17-20 节讲解了如何使用这个分类器。其中，18节讲了为什么需要采用一种特殊的初始数据。\nsum = 1000000000 for i in range(1000000): sum += 0.000001 sum -= 1000000000 print(sum) 这段代码运行结果不是1。如果把sum换成一个很小的数字，例如1，而不是1000000000，我们发现结果误差变小了。基于这个原因，我们希望初始数据总是均值为0，并且各个方向的方差为一致的。例如一个灰度图片的像素值0-255，我们需要把它减去128，然后除以128，这样每一个数字都是-1到1之间的数字，这样的初始数据更适合用来训练。\n这样，我们就可以进行训练了。回顾一下视频内容，xi是训练数据矩阵，w是随机权重矩阵，为了性能，随机值取自正态分布中轴为0，方差很小的分布函数，然后计算概率数列，和目标的距离。然后求出到所有目标的平均距离。我们的目的是让距离变小，所以我们沿着梯度下降的方向优化权重矩阵，同时优化截距b。不断重复这一个过程，直到局部最优为止。\n安装docker https://www.docker-cn.com/community-edition#/download\n配置官方中国镜像。\n安装jupyter notebook $ pip3 install jupyter $ jupyter notebook 此时可以使用命令jupyter notebook打开一个jupyter编辑器\ntensorflow环境搭建 $ docker run -it -p 8888:8888 tensorflow/tensorflow 运行上述命令会自动下载tensorflow镜像，前提是仓库镜像设置成中国的镜像，否则下载很慢。运行命令后，会提示你打开网页，打开这个网址以后会显示tensorflow的jupyter编辑环境，前提是jupyter notebook安装正确\n挂载docker的文件目录 我们需要把官方的作业导进去。关闭容器，重新打开容器，使用-v 主机目录:容器目录来进行挂载。 docker run -v /Users/hahaha/tensorflow/:/notebooks -it -p 8888:8888 tensorflow/tensorflow 其中/Users/hahaha/tensorflow/是我的mac的一个文件夹，notebooks是tensorflow中的jupyter默认编辑目录。\n在主机目录的挂载目录下面粘贴第一个作业文件，1_notmnist.ipynb。这个文件可以在这里找到： 1_notmnist.ipynb\n作业代码段一 首先运行一下第一段代码的import，应该是没有任何出错的，此时什么也不会发生，如果出现了红色的输出错误，那就说明这些from import没有导入成功。\n# These are all the modules we\u0026#39;ll be using later. Make sure you can import them # before proceeding further. from __future__ import print_function # print函数 import matplotlib.pyplot as plt # 绘图工具 import numpy as np # 矩阵计算 import os # 文件路径 import sys # 文件输出 import tarfile # 解压缩 from IPython.display import display, Image # 显示图片 from scipy import ndimage # 图像处理 from sklearn.linear_model import LogisticRegression # 逻辑回归模块线性模型 from six.moves.urllib.request import urlretrieve # url处理 from six.moves import cPickle as pickle # 数据处理 # Config the matplotlib backend as plotting inline in IPython %matplotlib inline # matplotlib是最著名的Python图表绘制扩展库， # 它支持输出多种格式的图形图像，并且可以使用多种GUI界面库交互式地显示图表。 # 使用%matplotlib命令可以将matplotlib的图表直接嵌入到Notebook之中， # 或者使用指定的界面库显示图表，它有一个参数指定matplotlib图表的显示方式。 # inline表示将图表嵌入到Notebook中。 作业代码段二 接下来是第二段代码，会进行下载用于训练和测试的字母集合，大概是300mb大小。下载成功后，可以看到挂载目录下面的这两个文件。\nurl = \u0026#39;https://commondatastorage.googleapis.com/books1000/\u0026#39; last_percent_reported = None data_root = \u0026#39;.\u0026#39; # Change me to store data elsewhere def download_progress_hook(count, blockSize, totalSize): \u0026#34;\u0026#34;\u0026#34;A hook to report the progress of a download. This is mostly intended for users with slow internet connections. Reports every 5% change in download progress. \u0026#34;\u0026#34;\u0026#34; # 钩子函数用来实时显示下载进度 global last_percent_reported percent = int(count * blockSize * 100 / totalSize) if last_percent_reported != percent: if percent % 5 == 0: sys.stdout.write(\u0026#34;%s%%\u0026#34; % percent) sys.stdout.flush() else: sys.stdout.write(\u0026#34;.\u0026#34;) sys.stdout.flush() last_percent_reported = percent def maybe_download(filename, expected_bytes, force=False): \u0026#34;\u0026#34;\u0026#34;Download a file if not present, and make sure it\u0026#39;s the right size.\u0026#34;\u0026#34;\u0026#34; dest_filename = os.path.join(data_root, filename) # data_root是当前目录，在这个目录上加上文件名，设置为要保存的文件位置 if force or not os.path.exists(dest_filename): # force是强制下载，忽略已经下载的文件 print(\u0026#39;Attempting to download:\u0026#39;, filename) filename, _ = urlretrieve(url + filename, dest_filename, reporthook=download_progress_hook) # 使用urlretrieve来下载文件，挂上钩子 print(\u0026#39;\\nDownload Complete!\u0026#39;) statinfo = os.stat(dest_filename) # 获取下载到的文件的信息 if statinfo.st_size == expected_bytes: # 正确大小 print(\u0026#39;Found and verified\u0026#39;, dest_filename) else: # 错误大小，提示用户使用浏览器下载 raise Exception( \u0026#39;Failed to verify \u0026#39; + dest_filename + \u0026#39;. Can you get to it with a browser?\u0026#39;) return dest_filename train_filename = maybe_download(\u0026#39;notMNIST_large.tar.gz\u0026#39;, 247336696) test_filename = maybe_download(\u0026#39;notMNIST_small.tar.gz\u0026#39;, 8458043) 作业代码段三 解压缩用例\nnum_classes = 10 # 数字总共有多少个 np.random.seed(133) # 初始化随机种子 def maybe_extract(filename, force=False): # 假设已经解压缩了 root = os.path.splitext(os.path.splitext(filename)[0])[0] # remove .tar.gz # splitext(filename)[0]用于去除一个后缀，用两次就是去除两次后缀，也就是去除.tar.gz这个后缀 if os.path.isdir(root) and not force: # You may override by setting force=True. # 已经解压缩了就不再解压缩了 print(\u0026#39;%s already present - Skipping extraction of %s.\u0026#39; % (root, filename)) else: print(\u0026#39;Extracting data for %s. This may take a while. Please wait.\u0026#39; % root) tar = tarfile.open(filename) sys.stdout.flush() tar.extractall(data_root) tar.close() # 解压缩到当前目录下面 data_folders = [ os.path.join(root, d) for d in sorted(os.listdir(root)) if os.path.isdir(os.path.join(root, d))] if len(data_folders) != num_classes: raise Exception( \u0026#39;Expected %d folders, one per class. Found %d instead.\u0026#39; % ( num_classes, len(data_folders))) print(data_folders) # 检查解压缩文件目录的数量与期待是否一致，并且打印解压缩出来文件的目录 return data_folders train_folders = maybe_extract(train_filename) test_folders = maybe_extract(test_filename) 问题一 写出代码显示解压缩的文件内容信息\n参考答案 import random import matplotlib.image as mpimg def plot_samples(data_folders, sample_size, title=None): fig = plt.figure() # 建立空图像 if title: fig.suptitle(title, fontsize=16, fontweight=\u0026#39;bold\u0026#39;) # 加入标题 for folder in data_folders: # 遍历每个字母 image_files = os.listdir(folder) image_sample = random.sample(image_files, sample_size) # 从该字母中随机选取一定数量的图片 for image in image_sample: image_file = os.path.join(folder, image) ax = fig.add_subplot(len(data_folders), sample_size, sample_size * data_folders.index(folder) + image_sample.index(image) + 1) # 创建一个子图 image = mpimg.imread(image_file) # 加载子图图片 ax.imshow(image) # 显示子图图片 ax.set_axis_off() # 关闭子图坐标线 fig.set_size_inches(18.5, 10.5) # 设置图片显示的大小 plt.show() plot_samples(train_folders, 20, \u0026#39;Train\u0026#39;) plot_samples(test_folders, 20, \u0026#39;Test\u0026#39;) 运行效果如下\n可以看出，部分训练数据是有问题的\n作业代码段四 这之后需要进行数据的归一化处理，就是让图像的每一个像素由0255变换到-1.01.0，并且持久化到文件中\nimage_size = 28 # Pixel width and height. pixel_depth = 255.0 # Number of levels per pixel. # 图片长宽和图片像素深度 def load_letter(folder, min_num_images): \u0026#34;\u0026#34;\u0026#34;Load the data for a single letter label.\u0026#34;\u0026#34;\u0026#34; # 处理一个属于一个字母文件夹下面的文件 image_files = os.listdir(folder) # 列出该文件夹目录下面的所有文件 dataset = np.ndarray(shape=(len(image_files), image_size, image_size), dtype=np.float32) # 创建一个长度为文件个数，宽度和高度为28的 print(folder) # 打印目录 num_images = 0 # 初始化num_images for image in image_files: # 对每一个文件处理 image_file = os.path.join(folder, image) # 获取完整文件路径 try: image_data = (ndimage.imread(image_file).astype(float) - pixel_depth / 2) / pixel_depth # 读入图像，并且归一化处理 if image_data.shape != (image_size, image_size): # 检查图像的宽高 raise Exception(\u0026#39;Unexpected image shape: %s\u0026#39; % str(image_data.shape)) dataset[num_images, :, :] = image_data # 读入到数据集合中 num_images = num_images + 1 # 图片序号加一 except IOError as e: # 如果无法读取文件的话，则忽略该文件 print(\u0026#39;Could not read:\u0026#39;, image_file, \u0026#39;:\u0026#39;, e, \u0026#39;- it\\\u0026#39;s ok, skipping.\u0026#39;) dataset = dataset[0:num_images, :, :] # 如果读进来的文件数量少于最小需要文件数量 if num_images \u0026lt; min_num_images: raise Exception(\u0026#39;Many fewer images than expected: %d \u0026lt; %d\u0026#39; % (num_images, min_num_images)) # 显示缺少的文件数量 print(\u0026#39;Full dataset tensor:\u0026#39;, dataset.shape) # 显示文件数量，图片长宽 print(\u0026#39;Mean:\u0026#39;, np.mean(dataset)) # 平均值 print(\u0026#39;Standard deviation:\u0026#39;, np.std(dataset)) # 标准差 return dataset def maybe_pickle(data_folders, min_num_images_per_class, force=False): dataset_names = [] for folder in data_folders: # 对每一个字母文件夹处理 set_filename = folder + \u0026#39;.pickle\u0026#39; # 设置输出的文件 dataset_names.append(set_filename) # 设置处理过的文件夹 if os.path.exists(set_filename) and not force: # You may override by setting force=True. # 检查是否存在已处理过的文件 print(\u0026#39;%s already present - Skipping pickling.\u0026#39; % set_filename) else: print(\u0026#39;Pickling %s.\u0026#39; % set_filename) dataset = load_letter(folder, min_num_images_per_class) # 归一化处理这个文件夹下面的所有图片 try: with open(set_filename, \u0026#39;wb\u0026#39;) as f: pickle.dump(dataset, f, pickle.HIGHEST_PROTOCOL) # 持久化数据，将数据保存在硬盘上，而不是一直放在内存中 except Exception as e: print(\u0026#39;Unable to save data to\u0026#39;, set_filename, \u0026#39;:\u0026#39;, e) return dataset_names train_datasets = maybe_pickle(train_folders, 45000) test_datasets = maybe_pickle(test_folders, 1800) 问题2 显示处理过的图片\n参考答案 def plot_samples_2(data_folders, sample_size, title=None): fig = plt.figure() # 建立空图像 if title: fig.suptitle(title, fontsize=16, fontweight=\u0026#39;bold\u0026#39;) # 加入标题 for folder in data_folders: # 遍历每个字母 with open(folder, \u0026#39;rb\u0026#39;) as pk_f: data = pickle.load(pk_f) for index, image in enumerate(data): if index \u0026lt; sample_size : # 从该字母中随机选取一定数量的图片 ax = fig.add_subplot(len(data_folders), sample_size, sample_size * data_folders.index(folder) + index + 1) # 加载子图图片 ax.imshow(image) # 显示子图图片 ax.set_axis_off() # 关闭子图坐标线 fig.set_size_inches(18.5, 10.5) # 设置图片显示的大小 plt.show() plot_samples_2(train_datasets, 20, \u0026#39;Train\u0026#39;) plot_samples_2(test_datasets, 20, \u0026#39;Test\u0026#39;) 问题3 检查每个字母下面的文件数目是否相似。\n参考答案 file_path = \u0026#39;notMNIST_large/{0}.pickle\u0026#39; for ele in \u0026#39;ABCDEFJHIJ\u0026#39;: with open(file_path.format(ele), \u0026#39;rb\u0026#39;) as pk_f: # 遍历每一个目录 dat = pickle.load(pk_f) # 加载这个目录下面的持久化文件 print(\u0026#39;number of pictures in {}.pickle = \u0026#39;.format(ele), dat.shape[0]) # 打印相关信息 结果表明数目基本一致。 代码段——数据分割 数据不可能一次性就全部加载到内存中，这里对这些数据进行分割，接下来的这份代码对数据进行了分割\ndef make_arrays(nb_rows, img_size): if nb_rows: dataset = np.ndarray((nb_rows, img_size, img_size), dtype=np.float32) # 创建一个空集合，数据类型是长rows宽img_size高img_size的矩阵，数据类型是浮点32位 labels = np.ndarray(nb_rows, dtype=np.int32) # 创建一个标签，数据类型是32位整型，长度是rows else: dataset, labels = None, None return dataset, labels # 返回创建的数据类型 def merge_datasets(pickle_files, train_size, valid_size=0): num_classes = len(pickle_files) # 需要处理的类别数量 valid_dataset, valid_labels = make_arrays(valid_size, image_size) # 建立有效数据集合，长度为有效长度 train_dataset, train_labels = make_arrays(train_size, image_size) # 建立训练数据集合，长度为训练长度 vsize_per_class = valid_size // num_classes tsize_per_class = train_size // num_classes # 计算给定训练长度和有效长度下每个类别的平均长度 start_v, start_t = 0, 0 # 初始化下标，start_v是有效数据的开始，start_t是训练数据的开始 end_v, end_t = vsize_per_class, tsize_per_class # 初始化下标，end_v是有效数据的结束，end_t是训练数据的结束 end_l = vsize_per_class + tsize_per_class # 初始化下标，end_l是字母集合的结束，等于每个类别有效数据的长度+训练数据的长度 for label, pickle_file in enumerate(pickle_files): # 遍历每一个pickle_file try: with open(pickle_file, \u0026#39;rb\u0026#39;) as f: # 打开这个持久化文件 letter_set = pickle.load(f) # 加载数据集 # let\u0026#39;s shuffle the letters to have random validation and training set np.random.shuffle(letter_set) # 打乱数据集的顺序 if valid_dataset is not None: # 如果不是测试集的话，更新测试集，否则 valid_dataset 不更新 valid_letter = letter_set[:vsize_per_class, :, :] # numpy切片 http://brieflyx.me/2015/python-module/numpy-array-split/ # 从打乱的数据中选择 每类有效数据 数量的数据进行处理，放到 valid_letter 中 valid_dataset[start_v:end_v, :, :] = valid_letter # 把这份数据放到valid_dataset中 valid_labels[start_v:end_v] = label # 标记label 应该是 0~9中的一种 start_v += vsize_per_class end_v += vsize_per_class # 更新下标 # 循环结束时， valid_dataset 应该总长度为 valid_size 的一份数据， valid_labels是对应位置的标签 train_letter = letter_set[vsize_per_class:end_l, :, :] # 除去valid部分的随机其他元素，长度为 end_l - vsize_per_class = tsize_per_class train_dataset[start_t:end_t, :, :] = train_letter # 循环结束时，train_dataset应该是总长为 train_size 的 一份数据 # train_labels[start_t:end_t] = label start_t += tsize_per_class end_t += tsize_per_class # 更新下标 except Exception as e: print(\u0026#39;Unable to process data from\u0026#39;, pickle_file, \u0026#39;:\u0026#39;, e) raise return valid_dataset, valid_labels, train_dataset, train_labels train_size = 200000 valid_size = 10000 test_size = 10000 valid_dataset, valid_labels, train_dataset, train_labels = merge_datasets( train_datasets, train_size, valid_size) _, _, test_dataset, test_labels = merge_datasets(test_datasets, test_size) print(\u0026#39;Training:\u0026#39;, train_dataset.shape, train_labels.shape) print(\u0026#39;Validation:\u0026#39;, valid_dataset.shape, valid_labels.shape) print(\u0026#39;Testing:\u0026#39;, test_dataset.shape, test_labels.shape) 代码段——打散数据 permutation函数介绍：http://www.jianshu.com/p/f0eb10acaa2d\ndef randomize(dataset, labels): # labels.shape[0] 是 labels 的长度 permutation = np.random.permutation(labels.shape[0]) # 随机取出这么多数字的打乱 print(labels.shape[0]) shuffled_dataset = dataset[permutation,:,:] # 打乱数据 shuffled_labels = labels[permutation] # 打乱标签 return shuffled_dataset, shuffled_labels train_dataset, train_labels = randomize(train_dataset, train_labels) test_dataset, test_labels = randomize(test_dataset, test_labels) valid_dataset, valid_labels = randomize(valid_dataset, valid_labels) 问题4 检验打散后的数据是否正确\n参考答案 import random def plot_sample_3(dataset, labels, title): fig = plt.figure() plt.suptitle(title, fontsize=16, fontweight=\u0026#39;bold\u0026#39;) # 设置标题样式 items = random.sample(range(len(labels)), 200) # 打散 labels 长的顺序序列 for i, item in enumerate(items): # 随机取一个 plt.subplot(10, 20, i + 1) # 画子图 plt.axis(\u0026#39;off\u0026#39;) # 关闭坐标轴 plt.title(chr(ord(\u0026#39;A\u0026#39;) + labels[item])) # 加标题 plt.imshow(dataset[item]) # 显示对应位置的子图 fig.set_size_inches(18.5, 10.5) plt.show() # 显示图片 plot_sample_3(train_dataset, train_labels, \u0026#39;train dataset suffled\u0026#39;) plot_sample_3(valid_dataset, valid_labels, \u0026#39;valid dataset suffled\u0026#39;) plot_sample_3(test_dataset, test_labels, \u0026#39;test dataset suffled\u0026#39;) 省略类似的两图\n代码段——保存数据 pickle_file = os.path.join(data_root, \u0026#39;notMNIST.pickle\u0026#39;) # 输出文件路径 try: f = open(pickle_file, \u0026#39;wb\u0026#39;) # 打开这个文件 save = { \u0026#39;train_dataset\u0026#39;: train_dataset, \u0026#39;train_labels\u0026#39;: train_labels, \u0026#39;valid_dataset\u0026#39;: valid_dataset, \u0026#39;valid_labels\u0026#39;: valid_labels, \u0026#39;test_dataset\u0026#39;: test_dataset, \u0026#39;test_labels\u0026#39;: test_labels, } # 写入一个字典 string-ndarray pickle.dump(save, f, pickle.HIGHEST_PROTOCOL) f.close() except Exception as e: print(\u0026#39;Unable to save data to\u0026#39;, pickle_file, \u0026#39;:\u0026#39;, e) raise 代码段——显示保存数据的大小 statinfo = os.stat(pickle_file) print(\u0026#39;Compressed pickle size:\u0026#39;, statinfo.st_size) 问题5 题目的Google翻译\n通过构建，此数据集可能包含大量重叠样本，包括验证和测试集中也包含的训练数据！ 训练和测试之间的重叠可能会使结果偏斜，如果您希望在没有重叠的环境中使用您的模型，但如果您希望在使用训练样本时再次看到训练样本，那么实际上是可以的。 测量培训，验证和测试样本之间的重叠程度。 可选问题： 数据集之间的重复数据怎么样？ （几乎相同的图像） 创建一个消毒验证和测试集，并比较您在随后的作业中的准确性。\n大概意思是训练数据不能和测试用的数据重合，否则导致准确度不准\n参考代码：\n仅仅查看重复的图片数量 import hashlib pickle_file = os.path.join(\u0026#39;.\u0026#39;, \u0026#39;notMNIST.pickle\u0026#39;) try: with open(pickle_file, \u0026#39;rb\u0026#39;) as f: data = pickle.load(f) except Exception as e: print(\u0026#39;Unable to open data from\u0026#39;, pickle_file, \u0026#39;:\u0026#39;, e) raise # 自从保存数据后，如果kernel挂了，就可以从本地直接读取，不用重新运行之前的代码 # 如果报错的话，可以在网上搜索报错的异常 def calcOverlap(sourceSet, targetSet, description): sourceSetMd5 = np.array([hashlib.md5(img).hexdigest() for img in sourceSet]) # 建立一个md5表格 targetSetMd5 = np.array([hashlib.md5(img).hexdigest() for img in targetSet]) # 建立一个md5表格 overlap = np.intersect1d(sourceSetMd5, targetSetMd5, assume_unique=False) # 去重 print(description) print(\u0026#34;overlap\u0026#34;,overlap.shape[0], \u0026#34;from\u0026#34;,sourceSetMd5.shape[0],\u0026#34;to\u0026#34;, targetSetMd5.shape[0]) print(\u0026#34;rate\u0026#34;,overlap.shape[0]*100.0/sourceSetMd5.shape[0],\u0026#34;% and\u0026#34;, overlap.shape[0]*100.0/targetSetMd5.shape[0],\u0026#34;%\u0026#34;) # 打印重叠数量 calcOverlap(data[\u0026#39;train_dataset\u0026#39;], data[\u0026#39;valid_dataset\u0026#39;], \u0026#34;train_dataset \u0026amp; valid_dataset\u0026#34;) calcOverlap(data[\u0026#39;train_dataset\u0026#39;], data[\u0026#39;test_dataset\u0026#39;], \u0026#34;train_dataset \u0026amp; test_dataset\u0026#34;) calcOverlap(data[\u0026#39;test_dataset\u0026#39;], data[\u0026#39;valid_dataset\u0026#39;], \u0026#34;test_dataset \u0026amp; valid_dataset\u0026#34;)``` ![运行效果](http://upload-images.jianshu.io/upload_images/4388248-2882159fe68dc672.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) - 去除重复图片资源 待更新 ## 问题6 使用逻辑回归训练模型并且进行测试 - 参考代码 import random def disp_sample_dataset(dataset, labels,trueLabels, title=None):\n展示训练的结果 fig = plt.figure() if title: fig.suptitle(title, fontsize=16, fontweight='bold') 设置标题样式 items = random.sample(range(len(labels)), 200) 随机选择一系列图片 for i, item in enumerate(items): plt.subplot(10, 20, i + 1) 设置一个子图 plt.axis('off') 关闭坐标线 lab = str(chr(ord('A') + labels[item])) trueLab = str(chr(ord('A') + trueLabels[item])) if lab == trueLab: plt.title( lab ) else: plt.title(lab + \u0026quot; but \u0026quot; + trueLab) 加上标题 plt.imshow(dataset[item]) 显示这个图片 fig.set_size_inches(18.5, 10.5) plt.show() def train_and_predict(train_dataset, train_labels, test_dataset, test_labels ,sample_size): regr = LogisticRegression()\n生成训练器 X_train = train_dataset[:sample_size].reshape(sample_size, 784) 根据sample_size选择要训练的数据量 把二维向量压缩到一维向量 y_train = train_labels[:sample_size] 取出训练数据 regr.fit(X_train, y_train) 训练数据 X_test = test_dataset.reshape(test_dataset.shape[0], 28 * 28) 将测试数据压缩到一维向量 y_test = test_labels 测试数据所对应的真实标签 pred_labels = regr.predict(X_test) 生成预测数据 print('Accuracy:', regr.score(X_test, y_test), 'when sample_size=', sample_size) disp_sample_dataset(test_dataset, pred_labels, test_labels, 'sample_size=' + str(sample_size)) train_and_predict(data[\u0026rsquo;train_dataset\u0026rsquo;],data[\u0026rsquo;train_labels\u0026rsquo;],data[\u0026rsquo;test_dataset\u0026rsquo;],data[\u0026rsquo;test_labels\u0026rsquo;], 1000)\n![image.png](http://upload-images.jianshu.io/upload_images/4388248-6b3fb8a1d1b1ce34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) ## 模型性能 小节22~27提到了模型性能的相关知识。我们通常希望模型的性能能够达到100%，显然是不可能的。并且，为了使训练集的准确性提高，模型可能会发生过拟合。这时要遵循两点。 - 不要将训练数据一次性使用，而是分块使用，每次训练一部分 - 当模型参数使30个以上的用例由错误变成正确，则这个参数的改变是有效果的。 ![模型性能](http://upload-images.jianshu.io/upload_images/4388248-033910ba1d5c09e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) ## 随机梯度下降 小节29~31讲解了什么是随机梯度下降 在训练过程中，为了让模型朝着最优的方向走，需要计算该点的导数。1.导数的计算量比较大，我们需要随机选择一部分样本来计算导数，来代替真实的导数。这就是随机梯度下降。2.为了减缓随机选择的随机性，我们使用动量的惯性来减少随机性。3.为了让后期模型能够稳定，我们减少学习的步长。 课程一结束 \u0026gt; 作业代码参考 \u0026gt; http://www.hankcs.com/ml/notmnist.html ","date":"2017-07-19T07:42:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%E4%BC%98%E8%BE%BE%E5%AD%A6%E5%9F%8E/","title":"深度学习零基础学习笔记一（优达学城）"},{"content":"前言 尽管知乎上对Cocos2dx成见很大，但是徘徊于纠结用什么游戏引擎不如都试试。况且这个软件是国人开发的，学习起来应该不算困难。\n虽然没有学过JavaScript，但是似乎也可以边查边写吧。JavaScript的教程： http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000\nCocos creator目前版本为1.5.1，官网有一份很详细的手册，网址为 http://www.cocos.com/docs/creator/ 。这篇文章是该快速上手这一章的精简版，并且对游戏性进行了提升。\n安装 windows下面的安装是没有任何问题的。mac下的安装，需要注意一下。 在官网下载安装包之后，拖动到applications中之后，打开会提示该应用是未被信任的开发者。此时，打开系统偏好设置中的安全性与隐私中的通用，会看到打开的按钮，通过此方式打开之后，不再进行提醒了。\n快速开始 从dashboard开始新建项目，或者打开项目。根据教程中关于快速上手的部分，我们从这个地址可以下载到一个初始工程项目 下载初始项目 。 或者点击这里下载 https://github.com/cocos-creator/tutorial-first-game/releases/download/v1.2/start_project.zip\n这个快速上手最终做出的游戏效果是这样的： http://fbdemos.avosapps.com/star-catcher/ 。 这个游戏有点类似于接金币这样的游戏，但是更加困难，游戏的学习曲线非常的大，由于这个小怪物的水平加速度难以驾驭以及上下蹦跳的关系，几乎很难已去接到五角星，而且也没有什么剧情。我们最好把他改的好玩一点吧。\n打开这个项目，我们先学习一下界面。左下角是资源面板，在初始项目中，已经建立了一个工程目录，这里有最基本的资源，已经目录组织。assets的意思是资产，在这个总目录下面，有三个子目录，包含有字体，音频，与图片资源。\n创建场景 场景是至关重要的，因为场景包含了游戏脚本，而场景在游戏开始的时候会自动加载。在资源面板中的assets下点击加号创建一个场景，重命名为game，双击打开。\n左上角的层级管理器显示的是当前的场景中节点之间的关系。 在这个game场景中，只有一个根节点canvas（画布），现在这个节点上是空的，意味着什么都不会加载。\n点击根结点在右侧数据面板中，我们可以设置根节点的分辨率。分辨率的高度设置为自适应，总为960x640，和iPhone第一代长宽比一致，推测这个分辨率应该是dp而不是pixel吧。\n场景图像 将资源background拖拽到canvas上，使得background成为canvas的一个子节点，注意不要将background变成另一个根节点。 使用cmd+s来保存刚刚的变动。 选中场景中的background图片，然后，在左上角找到变换工具的第四个按钮，分别是平移，旋转，缩放，矩形变换。选中矩形变换，将background变换为一个能覆盖场景的大小，如下图所示。\n上述步骤也可以直接对background的属性进行设置，设置位置为0，0，宽高为1600和800就行。\n用同样的方法添加地面。 用同样的方法插入小怪物，并且重命名为player。图片的默认锚点为中心位置，这里将锚点anchor的y设置为0。\n创建脚步 接下来出现了惊人的一幕，教程居然说不会编程也没关系，你可以交给你的程序员小伙伴来解决，果然是我现在只差一个程序员了。\n在下图中资源的player的位置建立一个js脚本文件，并打开。 在properties中插入以下内容，这部分是小怪物的物理属性\njumpHeight:0, jumpDuration:0, maxMoveSpeed:0, accel:0, 选中小怪物图片，在属性框中找到添加组件，把player脚本添加到player图片上，并且设置好相关参数。\n完善脚本 我们在脚本中继续加入其他功能。首先是跳跃的动作。\n在properties下面加入这一段\nsetJumpAction: function(){ var jumpUp = cc.moveBy(this.jumpDuration, cc.p(0,this.jumpHeight)).easing(cc.easeQuadraticActionOut()); var jumpDown = cc.moveBy(this.jumpDuration, cc.p(0,-this.jumpHeight)).easing(cc.easeQuadraticActionIn()); return cc.repeatForever(cc.sequence(jumpUp, jumpDown)); }, moveBy是官方的API，在官方API中查询一下该API的使用，第一个参数是移动的距离，第二个参数是移动的位置。很显然是向上移动了一段距离。后面的easing是生成缓动运动，生成的对象是easeQuadraticActionIn和Out，这两个是二次曲线。原来的教程中是三次曲线，这个和真实世界中的物理运动差的太多了。\n在onload方法中加入下面这段代码，启动动画。\nonLoad: function () { this.jumpAction = this.setJumpAction(); this.node.runAction(this.jumpAction); }, 现在点击播放按钮刻可以查看初始的效果。\n控制角色 为主角加上移动的控制。 在setJumpAction下面继续添加方法。\nsetInputControl: function(){ var self = this; cc.eventManager.addListener({ event: cc.EventListener.KEYBOARD, onKeyPressed: function(keyCode, event){ switch(keyCode){ case cc.KEY.a: self.accLeft = true; self.accRight = false; break; case cc.KEY.d: self.accRight = true; self.accLeft = false; } }, onKeyReleased: function(keyCode, event){ switch(keyCode){ case cc.KEY.a: self.accLeft = false; break; case cc.KEY.d: self.accRight = false; break; } } }, self.node) }, 更新onload和update代码\nonLoad: function () { this.jumpAction = this.setJumpAction(); this.node.runAction(this.jumpAction); this.accLeft = false; this.accRight = false; this.xSpeed = 0; this.setInputControl(); }, update: function(dt){ if(this.accLeft){ this.xSpeed -= this.accel * dt; } else if(this.accRight){ this.xSpeed += this.accel * dt; } if(this.xSpeed \u0026gt;0){ this.xSpeed -= this.accel/2 * dt; } else if( this.xSpeed \u0026lt;0){ this.xSpeed += this.accel/2 * dt; } if(Math.abs(this.xSpeed) \u0026gt; this.maxMoveSpeed){ this.xSpeed = this.maxMoveSpeed * this.xSpeed / Math.abs(this.xSpeed); } this.node.x += this.xSpeed * dt; }, 第一个代码添加了个监听器，按键变动的时候改变accLeft和accRight的值。启动时打开监听，然后，在每一帧需要更新的时候，计算怪物的位置。\n增加五角星 添加Game脚本到assets/scripts文件夹下，双击打开脚本，加入以下代码\ncc.Class({ extends: cc.Component, properties: { // 这个属性引用了星星预制资源 starPrefab: { default: null, type: cc.Prefab }, // 星星产生后消失时间的随机范围 maxStarDuration: 0, minStarDuration: 0, // 地面节点，用于确定星星生成的高度 ground: { default: null, type: cc.Node }, // player 节点，用于获取主角弹跳的高度，和控制主角行动开关 player: { default: null, type: cc.Node }, scoreDisplay: { default: null, type: cc.Label } }, onLoad: function () { // 获取地平面的 y 轴坐标 this.groundY = this.ground.y + this.ground.height/2; // 生成一个新的星星 this.spawnNewStar(); this.score = 0; }, gainScore: function () { this.score += 1; // 更新 scoreDisplay Label 的文字 this.scoreDisplay.string = \u0026#39;Score: \u0026#39; + this.score.toString(); }, spawnNewStar: function() { // 使用给定的模板在场景中生成一个新节点 var newStar = cc.instantiate(this.starPrefab); // 将新增的节点添加到 Canvas 节点下面 this.node.addChild(newStar); // 为星星设置一个随机位置 newStar.setPosition(this.getNewStarPosition()); newStar.getComponent(\u0026#39;star\u0026#39;).game = this; }, getNewStarPosition: function () { var randX = 0; // 根据地平面位置和主角跳跃高度，随机得到一个星星的 y 坐标 var randY = this.groundY + cc.random0To1() * this.player.getComponent(\u0026#39;Player\u0026#39;).jumpHeight + 50; // 根据屏幕宽度，随机得到一个星星 x 坐标 var maxX = this.node.width/2; randX = cc.randomMinus1To1() * maxX; // 返回星星坐标 return cc.p(randX, randY); }, // called every frame, uncomment this function to activate update callback // update: function (dt) { // }, }); 从 资源管理器 中拖拽 assets/textures/star 资源到场景中，添加名叫 Star 的JavaScript脚本到assets/scripts/中，并关联脚本。 打开star脚本，添加如下代码\ncc.Class({ extends: cc.Component, properties: { // foo: { // default: null, // The default value will be used only when the component attaching // to a node for the first time // url: cc.Texture2D, // optional, default is typeof default // serializable: true, // optional, default is true // visible: true, // optional, default is true // displayName: \u0026#39;Foo\u0026#39;, // optional // readonly: false, // optional, default is false // }, // ... pickRadius:0, }, // use this for initialization onLoad: function () { }, getPlayerDistance: function () { // 根据 player 节点位置判断距离 var playerPos = this.game.player.getPosition(); // 根据两点位置计算两点之间距离 var dist = cc.pDistance(this.node.position, playerPos); return dist; }, onPicked: function() { // 当星星被收集时，调用 Game 脚本中的接口，生成一个新的星星 this.game.spawnNewStar(); this.game.gainScore(); // 然后销毁当前星星节 this.node.destroy(); }, update: function (dt) { // 每帧判断和主角之间的距离是否小于收集距离 if (this.getPlayerDistance() \u0026lt; this.pickRadius) { // 调用收集行为 this.onPicked(); return; } }, // called every frame, uncomment this function to activate update callback // update: function (dt) { // }, }); 现在在star的属性中设置pickRadius为60。 从层级管理器中将star节点拖拽到资源管理器中的assets文件夹下，就生成了名叫star的 Prefab 资源。 从场景中删除star节点。 选中Canvas节点后，拖拽脚本到 属性检查器，从资源管理器中拖拽star Prefab 资源到Game组件的Star Prefab属性中，从层级编辑器中拖拽ground和Player 节点到组件中相同名字的属性上。\n接下来再加入计分机制，和上面的过程十分的类似，这里就略去不详细写了，此时，测试一下游戏的效果，已经可以看到游戏大致效果。\n如果你有任何问题，可以查看官方的上手的教程，也可以点击这里可以下载到此为止的工程： 链接: https://pan.baidu.com/s/1dFw3VSP 密码: 7vgu\n官方在接下来继续进行了游戏的完善，不过我不打算继续完善下去了，接下来将关注对触摸屏的支持\n","date":"2017-06-27T09:31:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/cocos-creator-%E4%BB%8E%E9%9B%B6%E5%AD%A6%E4%B9%A0-%E4%B8%80/","title":"Cocos Creator 从零学习 一"},{"content":"题目 给定一个BST二分查找树，求众数。 要求，除去递归的空间占用，其他代码空间复杂度为O(1)。\n分析 很显然，二分查找树的中序遍历就是一个有序数组。 有序数组查找最长的连续重复的数字，就是众数了。需要注意的是，题目要求返回重复的数字。另外，空间复杂度必须为O(1)。要写出这样的代码并不困难。\n运行16ms，击败62%\n/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { private: vector\u0026lt;int\u0026gt; mode; int last; int lastCount; int modeCount; public: vector\u0026lt;int\u0026gt; findMode(TreeNode* root) { last = 0; lastCount = 0; modeCount = 0; mode.clear(); runMode(root); return mode; } void runMode(TreeNode* root){ if(root != NULL){ runMode(root -\u0026gt; left); int nowValue = root-\u0026gt;val; int nowCount = nowValue != last? 1 : lastCount + 1; if(modeCount == nowCount){ mode.push_back(nowValue); } if(modeCount \u0026lt; nowCount){ modeCount = nowCount; mode.clear(); mode.push_back(nowValue); } last = nowValue; lastCount = nowCount; runMode(root -\u0026gt; right); } } }; ","date":"2017-06-26T10:54:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E7%AE%97%E6%B3%95/%E6%AF%8F%E5%91%A8%E4%B8%80%E9%81%93leetcode-501--find-mode-in-binary-search-tree/","title":"每周一道Leetcode—— 501. Find Mode in Binary Search Tree"},{"content":"题目 求一个字符串的一个满足要求的最长子字符串，该子字符串不得含有重复的字符，返回该子字符串的长度。\n思路 很容易想到一个时间复杂度为O(n^2)的算法。遍历每一个字符，从该字符开始看看以这个字符为起点的最长字符串是多长，最后输出所有字符的最长子字符串长度。\n运行时间600ms，击败0%提交\nclass Solution { public: int lengthOfLongestSubstring(string s) { int ret = 0; for(int i=0; i\u0026lt;s.size(); i++){ unordered_set\u0026lt;char\u0026gt; buff; for(int j=i; j\u0026lt;s.size(); j++){ if(buff.count(s[j]) == 0) buff.insert(s[j]); else break; } if(buff.size() \u0026gt; ret) ret = buff.size(); } return ret; } }; 改进 可以看到上面那个算法非常搞笑，是世界上速度最慢的算法。在查找字符串中，我们需要设置一个起点，这个起点是到目前为止，遍历的位置往前最长没有重复出现字符的位置。然后通过与遍历的位置相减，就可以得到最长的子字符串长度了。\n运行时间15ms，击败96%提交\nclass Solution { public: int lengthOfLongestSubstring(string s) { vector\u0026lt;int\u0026gt; lastPos(260, -1); int length = s.size(); int ret = 0; int start = 0; for(int i=0; i\u0026lt;length; i++) { char c = s[i]; if(lastPos[c]+1 \u0026gt; start) start = lastPos[c] + 1; if(i-start+1 \u0026gt; ret) ret = i-start+1; lastPos[c] = i; } return ret; } }; ","date":"2017-06-24T08:21:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E7%AE%97%E6%B3%95/%E6%AF%8F%E5%91%A8%E4%B8%80%E9%81%93leetcode-3--longest-substring-without-repeating-characters/","title":"每周一道leetcode—— 3. Longest Substring Without Repeating Characters"},{"content":"题目 给定一个数组，在这个数组中，包含了一些整形数字，除了有两个数字重复了一次，其他数字都重复了两次。找出这两个数字。空间复杂度尽可能做到O(1)。\n分析 尽管解决方案中要求空间复杂度为O(1)，这个方法确实有点复杂和难想，而且很难写出常数小的算法。 感受异或的神奇 上面这个链接中给出了这道题的标准做法。在这个方法中，首先将所有字母进行异或操作，然后，结果就是两个只出现了一次的数字的异或。这个数字的每一位1意味着这两个数字的哪几位是不同的。任取一位，在这一位上，将数组分为两类，一类是这一位上是1，另一类是这一位上是0，这样对这两个数组分别异或结果就是这两个数字了。\n这利用了异或的性质。\na ^ b ^ c = a ^ c ^ b a ^ a = 0 0 ^ a = a a ^ b = c =\u0026gt; a ^ c = b\n运行13ms，击败68%提交。\nclass Solution { public: vector\u0026lt;int\u0026gt; singleNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int axorb = 0, last = 0; vector\u0026lt;int\u0026gt; ret(2, 0); for(auto it = nums.begin(); it!=nums.end() ; it++) { axorb ^= *it; } last = axorb \u0026amp; (~(axorb - 1)); for(auto it = nums.begin(); it!=nums.end() ; it++) { if ((last \u0026amp; *it) != 0) ret[0] ^= *it; } ret[1] = axorb ^ ret[0]; return ret; } }; 其他方法 如果不要求空间复杂度为常数，其实也可以用哈希表来做。这样算法的扩展性很好，而且也不晦涩。\n运行16ms，击败%34提交\nclass Solution { public: vector\u0026lt;int\u0026gt; singleNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { unordered_set\u0026lt;int\u0026gt; buff(nums.size()); for(auto i = nums.begin(); i!=nums.end() ; i++) { auto it = buff.find(*i); if(it == buff.end()){ buff.insert(*i); } else{ buff.erase(it); } } vector\u0026lt;int\u0026gt; ret; for(const int \u0026amp; i : buff){ ret.push_back(i); } return ret; } }; ","date":"2017-06-22T03:49:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E7%AE%97%E6%B3%95/%E6%AF%8F%E5%91%A8%E4%B8%80%E9%81%93leetcode-260--single-number-iii/","title":"每周一道leetcode—— 260. Single Number III"},{"content":"题目： 给定两个字符串十进制数字，给出字符串为他们的乘积。要求如下：\n禁止使用内置大数算法。 字符串长度110 输入无前置0 字符串仅含有数字 思考 在一开始没有看到禁止使用内置函数，我直接使用python的str和int这两个函数，结果直接前10%了。。。后来我看了下题目原来是不能用内置函数的，不知道这个python语言的特性算不算内置大数算法。这是一个大数乘法问题，大数乘法有很多现成的算法。\n最开始提交的python版本，击败88%\nclass Solution(object): def multiply(self, num1, num2): return str(int(num1)*int(num2)) 最原始的算法就是模拟手算了吧，首先你得实现字符串的加法计算，多位乘法乘一位乘法，这样应该可以计算多位乘以多位了。例如计算12345*67890，就是计算12345*6 + 12345*7 + 12345 *8 + 12345 * 9 + 12345 * 0， 然后每一个计算结果后面补0，再相加就会得到结果。不过这样的速度会比较慢。\n况且，CPU本身就可以计算一些不会溢出的加法，所以，我们得好好利用这一点。首先我们得改进一下上面的算法，计算12345*67890这个数字的结果，我们可以这样算：12345*67890 = (12300 + 45)*(67800 + 90) ，显然可以拆解成为4个乘法计算，而且对于低位为0的，可以直接去掉，然后计算结果再补回来就行了，如果这四个乘法分别计算的时候不会溢出，那就没有问题了。否则，我们可以继续分解。\n使用karatsuba乘法可以继续改进上面一点。 我们注意到加法中有12300*90+45*67800，我们可以利用已经计算过的结果，也就是12300*67800和45*90，然后只需要计算(12300+45)*(67800+90) - 12300*67800 - 45*90 就可以得到 12300*90 + 45*67800。这样，乘法的计算次数就减少了一次。\nkaratsuba乘法写起来会复杂一点，先不实现。首先提交一版n^2的算法也就是普通版，看看效果怎么样，然后再改进。（结果表明，手算版的速度已经很快了）\n第一版 首先我们得写一个字符串相加的算法。我们首先观察一下输入的数据类型和输出的数据类型。是string类型的，那么按照一位一位加起来也是可以的。可以直接用两个整形数组保存一下每一位数，然后相加算出来第三个数组，这时第三个数组会有一些数字超出了10，我们按照从低位开始向高位进一位。最后将这个数组转成字符串就可以了。\n虽然本地测试还可以，但是提交后速度很慢，排名很后，只击败10%。\n改进 我觉得理论上这个算法应该是不慢的,但是实际过程是很慢，可能是由于多余的整形和字符串互相转换有关。上面的算法里面，在计算乘法的时候将字符串转成了数字但是之后又转换回字符串，可能是这里产生了多余的时间。所以，应该直接在这里将结果加在最终结果上面。\n提交后运行时间为9ms，击败50%。\n改进2 算法中相同的字符串重复转化，可能会消耗时间。 对字符串转化进行缓存，第一次转换成功就进行缓存，以后如果需要直接取出不需要进行额外的计算。\n最终代码，可直接编译运行。运行时间6ms，击败76%提交。看来字符串转化反而成了性能瓶颈。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int BINARY = 10; class Solution { private: vector\u0026lt;int\u0026gt; result; string _num1, _num2; long num1buff[120]; long num2buff[120]; public: string multiply(string num1, string num2) { result.clear(); result.resize(num1.length() + num2.length() + 1); memset(num1buff, -1 , sizeof(long)*120); memset(num2buff, -1 , sizeof(long)*120); _num1 = num1; _num2 = num2; for(auto \u0026amp;c : _num1){ c-=\u0026#39;0\u0026#39;; } for(auto \u0026amp;c : _num2){ c-=\u0026#39;0\u0026#39;; } //这个过程是递归的过程,我们先看下什么时候终止吧. //终止的时候,是两个数相乘不会溢出的时候 //我们假设int是二进制30位的,相乘要30位,原来两个数字必然是15位的, 也就是32768. //也就是说两个四位数相乘通常都不会溢出了吧. //使用递归来计算乘积 addMultiply(0,num1.length(), 0, num2.length()); string ret; int i = result.size() -1; for(; i\u0026gt;0; i--) { if(result[i] != 0) break; } for(; i\u0026gt;=0; i--) { ret.push_back(result[i] + \u0026#39;0\u0026#39;); } return ret; } void addMultiply(int a1, int a2, int b1, int b2 ) {; //判断是否可以直接计算 if (a1 == a2 || b1 == b2) return; if (a2 - a1 \u0026lt; 10 \u0026amp;\u0026amp; b2 - b1 \u0026lt; 10) { long int_num1 = getLong1(a1, a2); long int_num2 = getLong2(b1, b2); long output = int_num1 * int_num2; int pos = _num1.length() + _num2.length() - a2 - b2; while (output != 0 || result[pos] \u0026gt;= BINARY) { long a = output % BINARY; result[pos] += a; result[pos + 1] += result[pos] / BINARY; result[pos] %= BINARY; output /= BINARY; pos++; } return; } //否则,拆开较长的那个数字 if(a2 - a1 \u0026gt;= 10){ addMultiply(a1, (a2 + a1)/2, b1, b2); addMultiply((a2 + a1)/2, a2, b1, b2); } else { addMultiply(a1, a2, (b1+b2)/2, b2); addMultiply(a1, a2, b1, (b1+b2)/2); } } long getLong1(int a, int b){ long ret = 0; if(num1buff[a] != -1) return num1buff[a]; for(int i=a; i!=b;i++){ ret *= BINARY; ret += _num1[i] ; } num1buff[a] = ret; return ret; } long getLong2(int a, int b){ long ret = 0; if(num2buff[a] != -1) return num2buff[a]; for(int i=a; i!=b;i++){ ret *= BINARY; ret += _num2[i] ; } num2buff[a] = ret; return ret; } }; int main(void) { Solution s; for(int i=0;i\u0026lt;10000;i++){ cout \u0026lt;\u0026lt; s.multiply(\u0026#34;12345678901\u0026#34;, \u0026#34;100\u0026#34;) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s.multiply(\u0026#34;100\u0026#34;, \u0026#34;100\u0026#34;) \u0026lt;\u0026lt; endl; } return 0; } 最终排名击败70%\n","date":"2017-06-19T06:39:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E7%AE%97%E6%B3%95/%E6%AF%8F%E5%91%A8%E4%B8%80%E9%81%93leetcode-43--multiply-strings-/","title":"每周一道leetcode—— 43. Multiply Strings"},{"content":"前言 win10最新版本系统自带的拼音已经可以支持小鹤双拼了，妈妈再也不用担心我装全家桶啦！\n时隔4年，更新一下进阶版设置，妈妈再也不用担心我一个一个配置按键啦：\nwin + R，输入 regedit，打开注册表 找到 计算机\\HKEY_CURRENT_USER\\Software\\Microsoft\\InputMethod\\Settings\\CHS 项 新建一个名为 UserDefinedDoublePinyinScheme0 的字符串值，值为 小鹤双拼*2*^*iuvdjhcwfg^xmlnpbksqszxkrltvyovt 打开微软拼音输入法设置，把 小鹤双拼 设置为双拼的默认方案即可。 如果担心修改注册表引起系统错乱，这里还有手工配置的方案：\n第一步 打开设置 系统的拼音输入法虽然没有小鹤双拼，但是我们可以自定义。\n首先在设置中找到设置双拼的位置，如果你找不到，可以看动图： 第二步 编辑自定义双拼 双拼设置如下图所示\n除了模板那里不用设置以外，其他的按照图中的设置就可以了，一个是零声母模式，另外一个是自定义按键，自定义按键按照图中的预览设置就可以了。需要注意的是，小鹤双拼中没有er这个音节，设置成e或者r键都可以。另外，ue，ve这两个音节都设置为T。有一个小技巧，设置按键的时候，可以直接按下对应的按键，而不用找到这个键来设置。\n第三步 保存方案 如果添加按钮变为可用，说明方案设置正确。添加为方案后，把该方案设置为默认方案，就可以使用小鹤双拼啦。\n测试 进行打字测试，查看设置的对不对\n第四步 点击喜欢 点击喜欢，提高页面排名，帮助更多人用上win10小鹤双拼\n","date":"2017-06-05T06:16:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/%E5%A6%82%E4%BD%95%E5%9C%A8windows10%E7%9A%84%E5%BE%AE%E8%BD%AF%E6%8B%BC%E9%9F%B3%E4%B8%AD%E8%AE%BE%E7%BD%AE%E5%B0%8F%E9%B9%A4%E5%8F%8C%E6%8B%BC/","title":"如何在windows10的微软拼音中设置小鹤双拼"},{"content":"前言 之前一直在Linux下面尝试进行部署了RT-Thread的stm32的开发，这种方式确实是可行的，但是也会带来种种不便之处。使用VSCode + Scons + openocd 进行编辑、编译链接、烧录确实是可以进行开发，但是若要进行调试则没有这种环境的解决方案，只得在eclipse中进行调试。而将RT-Thread改成eclipse的方案虽然可行，但是这样还不如直接在windows下面采用keil 5 来进行开发。\n由于stm32f103板载flash过小，栈也十分的小，于是换成stm32f411。板子来自于微雪科技的XNUCLEO，和STM官方NUCLEO板子是兼容的。\n安装Keil 5.23 由于我首先安装了Keil 5.11，然后附带的破解器破解了，之后卸载再安装了Keil 5.23，直接显示已经破解成功。破解器仍然是多年前就流行的注册码生成器。之所以使用Keil 5.23版本，是因为RT-Thread工程只能使用这个版本进行打开。\n使用pack installer安装库 只有安装了Keil::STM32F4xx_DFP才能打开RT-Thread的bps分支下的nucleo工程。\n安装STM32CubeMX 通过STM32CubeMX，我们可以方便的通过鼠标点击生成初始化代码。但是调用函数还是得我们自己写，不如NPX的PE方便。\n安装ST-Link驱动 微雪科技售卖100块钱的板子还附带了ST-Link调试器，那我们就是用ST-Link来进行调试吧。\n下载nucleo工程 打开rt-thread-master\\bsp\\stm32f411-nucleo下的Keil 5工程，尝试编译，通过后，简单设置工程的debug，使用ST-Link来进行调试，然后将程序下载到板子里面。虽然程序下进去了，但是没有任何效果，因为主函数是空的。\n我们在main函数中加入如下代码：\nint main(void) { /* user app entry */ MX_GPIO_Init(); while(1){ rt_thread_delay(5); HAL_GPIO_WritePin (GPIOC, GPIO_PIN_5, GPIO_PIN_SET); rt_thread_delay(5); HAL_GPIO_WritePin (GPIOC, GPIO_PIN_5, GPIO_PIN_RESET); } } 并加上LED的初始化函数\nstatic void MX_GPIO_Init(void) { GPIO_InitTypeDef GPIO_InitStruct; /* GPIO Ports Clock Enable */ __HAL_RCC_GPIOC_CLK_ENABLE(); /*Configure GPIO pin Output Level */ HAL_GPIO_WritePin(GPIOC, GPIO_PIN_5, GPIO_PIN_RESET); /*Configure GPIO pin : PC5 */ GPIO_InitStruct.Pin = GPIO_PIN_5; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOC, \u0026amp;GPIO_InitStruct); } 这样我们就可以看到板载的LED4灯亮起来了，并且在闪烁。\n这些初始化代码是从哪来的呢？主函数中的代码，是从网上找的，很简单的操作GPIO的函数，而MX_GPIO_Init这段代码，则来自于STM32CubeMX自动生成的代码。下面会讲如何通过STM32CubeMX生成初始化UART代码。\n使用STM32CubeMX生成UART初始化代码 首先我们建立一个工程，并设置好芯片型号，下面是演示 然后设置串口引脚。 由于RT-Thread已经初始化了串口1，我以我们不能使用这个。我们可以使用UART6。 打开工程，将代码偷走，蓝色部分就是我们要拿走的代码 移植代码 在void HAL_UART_MspInit(UART_HandleTypeDef *huart)中，添加USART6的代码： void HAL_UART_MspInit(UART_HandleTypeDef *huart) { GPIO_InitTypeDef GPIO_InitStruct; if (huart-\u0026gt;Instance == USART2) { /*##-1- Enable peripherals and GPIO Clocks #################################*/ /* Enable GPIO TX/RX clock */ USARTx_TX_GPIO_CLK_ENABLE(); USARTx_RX_GPIO_CLK_ENABLE(); /* Enable USARTx clock */ USARTx_CLK_ENABLE(); /*##-2- Configure peripheral GPIO ##########################################*/ /* UART TX GPIO pin configuration */ GPIO_InitStruct.Pin = USARTx_TX_PIN; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FAST; GPIO_InitStruct.Alternate = USARTx_TX_AF; HAL_GPIO_Init(USARTx_TX_GPIO_PORT, \u0026amp;GPIO_InitStruct); /* UART RX GPIO pin configuration */ GPIO_InitStruct.Pin = USARTx_RX_PIN; GPIO_InitStruct.Alternate = USARTx_RX_AF; HAL_GPIO_Init(USARTx_RX_GPIO_PORT, \u0026amp;GPIO_InitStruct); HAL_NVIC_SetPriority(USART2_IRQn, 0, 1); HAL_NVIC_EnableIRQ(USART2_IRQn); } if (huart-\u0026gt;Instance == USART6) { /* USER CODE BEGIN USART6_MspInit 0 */ /* USER CODE END USART6_MspInit 0 */ /* Peripheral clock enable */ __HAL_RCC_USART6_CLK_ENABLE(); /**USART6 GPIO Configuration PC6 ------\u0026gt; USART6_TX PC7 ------\u0026gt; USART6_RX */ GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH; GPIO_InitStruct.Alternate = GPIO_AF8_USART6; HAL_GPIO_Init(GPIOC, \u0026amp;GPIO_InitStruct); /* Peripheral interrupt init */ HAL_NVIC_SetPriority(USART6_IRQn, 0, 0); HAL_NVIC_EnableIRQ(USART6_IRQn); /* USER CODE BEGIN USART6_MspInit 1 */ /* USER CODE END USART6_MspInit 1 */ } } 在main.c文件中，添加MX_USART6_UART_Init();函数内容，并在主函数中，调用MX_USART6_UART_Init();进行初始化。\n之后，在main()函数中进行测试：\nuint8_t TxData[10]= \u0026#34;01234abcde\u0026#34;; HAL_UART_Transmit(\u0026amp;huart6,TxData,10,0xf); 我们将微雪的板子上的JP4跳帽接在右侧，这样，USB TO UART就能使用PC6、PC7作为串口接口了。然后，接上USB接口到PC机，我们可以在XSHELL之类的串口终端查看PC接受到的字符串。\n","date":"2017-04-06T10:22:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%9C%A8rt-thread%E4%B8%AD%E4%BD%BF%E7%94%A8stm32%E7%9A%84hal%E5%BA%93%E9%A9%B1%E5%8A%A8%E4%B8%B2%E5%8F%A3uart/","title":"在RT-Thread中使用stm32的hal库驱动串口UART"},{"content":"RT-Thread采用了类似于linux的函数调用方法，这里说明一下如何简单的使用设备。\n硬件环境 ：STM32F103RBT6 用户程序位置 用户程序在bsp文件夹下面的applications中的applications.c中书写和调用，如果程序比较多，再新建一个c文件分离出去。\nSPI 驱动文件 stm32f10x下面的drivers并没有spi驱动，我们需要将stm32f107对应的spi驱动移植过来。将rt_stm32f10x_spi.c，rt_stm32f10x_spi.h，以及platform.c文件复制过去，然后在rt_init_thread_entry函数中添加rt_platform_init();的调用，在对应文件中加入头文件。然后修改SConscript添加对platform.c，rt_stm32f10x_spi.c的编译，并在config中添加RT_USING_SPI和RT_USING_SPI1的宏定义\n在platform.c中spi初始化加入如下代码，配置频率\n/* config spi */ { struct rt_spi_configuration cfg; cfg.data_width = 8; cfg.mode = RT_SPI_MODE_3 | RT_SPI_MSB; /* SPI Compatible Modes 3 and SPI_FirstBit_MSB in lis302dl datasheet */ //APB2=168M/2=84M, SPI1 = 84/2,4,8,16,32 = 42M, 21M, 10.5M, 5.25M, 2.625M ... cfg.max_hz = 2625000; /* SPI_BaudRatePrescaler_16=84000000/16=5.25MHz. The max_hz of lis302dl is 10MHz in datasheet */ rt_spi_configure(\u0026amp;spi_device, \u0026amp;cfg); } /* config spi */ 硬件配置 硬件管脚被配置在platform.c文件中, 我们不修改默认的配置,也就是 PA4567这几个管脚为默认的spi输入输出管脚\n/* * SPI1_MOSI: PA7 * SPI1_MISO: PA6 * SPI1_SCK : PA5 * * CS0: PA4 SD card. 这里可以改成自己的spi设备的cs管脚 */ SPI调用 SPI调用不用使用open函数，只需执行\nrt_spi_transfer(spi_device, \u0026amp;ReadAddr, \u0026amp;pBuffer, 1); 或者rt_spi_send_then_recv也可以实现不同的效果。\nUART调用 UART调用需要使用open函数，这里给出一个简单的例子使用串口设备。\nvoid device_thread_entry(void* parameter) { rt_device_t device; device = rt_device_find(\u0026#34;uart2\u0026#34;); rt_device_open(device, RT_DEVICE_OFLAG_RDWR|RT_DEVICE_FLAG_INT_RX); char test[10] = \u0026#34;abc\u0026#34;; while(1){ rt_size_t reclen = rt_device_read(device, 0, test, 10); if(reclen \u0026gt; 0) rt_device_write(device, 0, test, reclen); rt_thread_delay(500); } } 可以开启这个线程，我们在uart2中输入10个以内的字符，在5秒后就会回显。如果超过10个字符，应该会在下一次5秒显示。 在官方markdown文档中，使用了消息机制来处理UART通信，也可以参考。\n","date":"2017-03-07T09:41:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%9C%A8rt-thread%E4%B8%AD%E4%BD%BF%E7%94%A8spi%E5%92%8Cuart%E8%AE%BE%E5%A4%87/","title":"在RT-Thread中使用SPI和UART设备"},{"content":"RT-Thread是一个中国开源嵌入式系统，目前版本为2.2，已经支持许多微控制器，例如STM32系列，甚至可以在蓝牙BLE芯片中运行。尽管微控制器中资源紧张，但是部署一个易用的微操作系统对项目开发和代码管理是很有益的。\n准备工具 STM32开发版一个，支持USB下载功能 Ubuntu系统 USB转串口线 这里我使用了古老的ALIENTEK STM32 MINI V2.0 开发板，芯片型号为STM32F103RBT6，Ubuntu系统版本为16.04\n1.下载交叉编译工具链 下载gcc-arm-none-eabi交叉编译工具链，对于16.04系统，直接使用apt install gcc-arm-none-eabi 进行安装 2.下载RT-Thread编译工具 该系统使用scons编译，对于16.04系统，使用 apt install scons 进行安装 3.下载系统源码 下载RT-Thread系统，地址为：https://github.com/RT-Thread 解压目录 4.修改编译工程 进入目录bsp/stm32f10x 编辑文件rtconfig.py 修改 CROSS_TOOL 为 gcc 5.针对板子进行配置 stm32f10x.h 中对晶振进行配置 HSE_VALUE，例如800000 board.h 中对RAM进行配置 STM32_SRAM_SIZE，例如20 led.c 中对 led进行配置 6.编译源码 在bsp/stm32f10x目录下运行 scons，输入rtthread.bin文件 7.烧录代码 你可以使用Jlink进行下载，须在Jlink官网下载Linux执行文件，由于我是debian系统，可以直接打开JLink_Linux_V614a_x86_64.deb文件进行安装。然后在系统文件下lib/目录下执行JlinkExe文件，即可以通过Jlink进行下载烧录程序。 这里我采用了更为方便的串口烧录。首先将开发板的B0接高电平，B1接低电平，然后使用STM32flash-5.0这个软件进行烧录。 下载地址https://sourceforge.net/projects/stm32flash/ 解压目录，在该目录下运行make，得到stm32flash 将rtthread.bin复制到该目录下，接入USB转串口线，然后输入sudo ./stm32flash -w rtthread.bin -v -g 0x0 /dev/ttyUSB0，其中ttyUSB0是串口设备 8.检查是否成功 若能看到LED灯闪烁，则成功 ","date":"2017-03-02T07:59:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E5%B5%8C%E5%85%A5%E5%BC%8F/ubuntu%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%9C%A8stm32%E4%B8%8A%E9%83%A8%E7%BD%B2rt-thread%E7%B3%BB%E7%BB%9F/","title":"Ubuntu环境下在STM32上部署RT-thread系统"},{"content":"##0.前言\n由于cubieboard2官方稳定版内核linux-3.4未添加原生spi驱动支持，我们需要为修改内核源码，编译并放入nand中，替换掉原来的uImage镜像，并放入新内核的模块文件。除此之外，还需要修改系统文件，使其完整支持全双工通信。\n##1.刷入debian系统到nand。（windows下）\n首先下载为cubieboard2定制的debian系统，地址为：http://dl.cubieboard.org/software/a20-cubieboard/debian/nand/debian-nand.img.gz\n下载Phoenixsuit，通过Phoenixsuit打开下载的镜像。在cubieboard2未接电源的状态下按住FEL按钮的同时通过OTG线接入电脑，在设备管理器将这个未识别的设备安装驱动，指定驱动安装目录为Phoenixsuit的安装目录，确认安装。\n然后格式化并刷入镜像。\n##2.登陆系统\n将cubieboard2接入网线，该debian系统默认设为静态ip地址192.168.1.124，你可以通过ssh进入该系统。你也可以通过TTL线从UART进行登陆，修改为DHCP方式，然后从路由器查看IP地址，再登陆。路由器账户名密码为root/cubieboard。\n##3.修改内核（ubuntu下）\n目前linux内核不支持cubieboard2的spi驱动。首先下载内核源码linux-3.4分支：https://github.com/linux-sunxi/linux-sunxi 。然后为内核增加spi支持（不建议），详情请查看 http://blog.csdn.net/u010352603/article/details/51657265# 。这里直接下载已经修改好的spi支持，地址 https://github.com/linanwx/cubieboard2-spi-support 。下载后，将内核目录drivers/spi删除，将下载的spi文件夹放在删除的位置。\n##4.编译内核（ubuntu下）\n准备好arm-linux-gnueabihf-gcc编译器，版本不高于5.0\n在内核目录中，使用终端，输入\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- sun7i_defconfig 输入\ngedit .config 找到以下选项，并将其改为\nCONFIG_SPI=y CONFIG_SUNXI_NAND_PARTITION=y CONFIG_SUNXI_NAND=y 输入以下命令开始编译内核\nmake -j4ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- uImage modules 由于开启了CONFIG_SPI支持和CONFIG_SUNXI_NAND支持，需要进行一系列的设置。当遇到spi support，CONFIG_SPI_SUN7I，CONFIG_SUN7I_SPI_NDMA时，输入y，其他情况输入回车。\n检查路径arch/arm/boot下是否有uImage文件\n输入以下命令生成内核模块\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- INSTALL_MOD_PATH=output modules_install 检查路径output/lib/modules/3.4.104目录是否产生\n##5.替换内核（cubieboard2下）\n在cubieboard2 中，打开终端，输入\nmkdir /media/nanda mount /dev/nanda /media/nanda 将uImage拷贝至cubieboard2 debian系统的/media/nanda目录覆盖原来内核\n使用tar命令打包output/lib/modules/3.4.104 目录，将该文件传入cubieboard2 的 /lib/modules 目录，然后解压\n##6.检查编译成功\n重启，如果系统正常进入，则成功\n##7.修改系统文件打开SPI，并使其支持全双工SPI（cubieboard2下） 重新挂载/dev/nanda到/media/nanda/ 目录并进入\n输入如下命令\nbin2fex script.bin script.fex nano script.fex 找到[spi0_para]，将其下面的used改为1，并额外增加如下代码\n[spi_devices] spi_dev_num =1 [spi_board0] modalias =\u0026#34;spidev\u0026#34; max_speed_hz =100000 bus_num =0 chip_select =0 mode =0 full_duplex =1 manual_cs =0 输入如下命令\nfex2bin script.fex script.bin nano /usr/include/linux/spi/spidev.h 在__u16 delay_usecs;上面一行添加\n__u16 interbyte_usecs; ##8.测试spi 重启cubieboard2。检查路径/dev下是否存在spidev设备。短接46，48pin脚，管脚图http://docs.cubieboard.org/products/a10_cubieboard/expansion_ports。 新建文本输入如下代码\n/* * SPI testing utility (using spidev driver) * * Copyright (c) 2007 MontaVista Software, Inc. * Copyright (c) 2007 Anton Vorontsov \u0026lt;avorontsov@ru.mvista.com\u0026gt; * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; either version 2 of the License. * * Cross-compile with cross-gcc -I/path/to/cross-kernel/include */ #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;getopt.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;linux/types.h\u0026gt; #include \u0026lt;linux/spi/spidev.h\u0026gt; #define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0])) static void pabort(const char *s) { perror(s); abort(); } static const char *device = \u0026#34;/dev/spidev0.0\u0026#34;; static uint8_t mode; static uint8_t bits = 8; static uint32_t speed = 500000; static uint16_t delay; static void transfer(int fd) { int ret; uint8_t tx[] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x40, 0x00, 0x00, 0x00, 0x00, 0x95, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDE, 0xAD, 0xBE, 0xEF, 0xBA, 0xAD, 0xF0, 0x0D, }; uint8_t rx[ARRAY_SIZE(tx)] = { 0, }; struct spi_ioc_transfer tr = { .tx_buf = (unsigned long)tx, .rx_buf = (unsigned long)rx, .len = ARRAY_SIZE(tx), .delay_usecs = delay, .speed_hz = speed, .bits_per_word = bits, }; ret = ioctl(fd, SPI_IOC_MESSAGE(1), \u0026amp;tr); if (ret == 1) pabort(\u0026#34;can\u0026#39;t send spi message\u0026#34;); for (ret = 0; ret \u0026lt; ARRAY_SIZE(tx); ret++) { if (!(ret % 6)) puts(\u0026#34;\u0026#34;); printf(\u0026#34;%.2X \u0026#34;, rx[ret]); } puts(\u0026#34;\u0026#34;); } static void print_usage(const char *prog) { printf(\u0026#34;Usage: %s [-DsbdlHOLC3]\\n\u0026#34;, prog); puts(\u0026#34; -D --device device to use (default /dev/spidev0.0)\\n\u0026#34; \u0026#34; -s --speed max speed (Hz)\\n\u0026#34; \u0026#34; -d --delay delay (usec)\\n\u0026#34; \u0026#34; -b --bpw bits per word \\n\u0026#34; \u0026#34; -l --loop loopback\\n\u0026#34; \u0026#34; -H --cpha clock phase\\n\u0026#34; \u0026#34; -O --cpol clock polarity\\n\u0026#34; \u0026#34; -L --lsb least significant bit first\\n\u0026#34; \u0026#34; -C --cs-high chip select active high\\n\u0026#34; \u0026#34; -3 --3wire SI/SO signals shared\\n\u0026#34;); exit(1); } static void parse_opts(int argc, char *argv[]) { while (1) { static const struct option lopts[] = { {\u0026#34;device\u0026#34;, 1, 0, \u0026#39;D\u0026#39;}, {\u0026#34;speed\u0026#34;, 1, 0, \u0026#39;s\u0026#39;}, {\u0026#34;delay\u0026#34;, 1, 0, \u0026#39;d\u0026#39;}, {\u0026#34;bpw\u0026#34;, 1, 0, \u0026#39;b\u0026#39;}, {\u0026#34;loop\u0026#34;, 0, 0, \u0026#39;l\u0026#39;}, {\u0026#34;cpha\u0026#34;, 0, 0, \u0026#39;H\u0026#39;}, {\u0026#34;cpol\u0026#34;, 0, 0, \u0026#39;O\u0026#39;}, {\u0026#34;lsb\u0026#34;, 0, 0, \u0026#39;L\u0026#39;}, {\u0026#34;cs-high\u0026#34;, 0, 0, \u0026#39;C\u0026#39;}, {\u0026#34;3wire\u0026#34;, 0, 0, \u0026#39;3\u0026#39;}, {\u0026#34;no-cs\u0026#34;, 0, 0, \u0026#39;N\u0026#39;}, {\u0026#34;ready\u0026#34;, 0, 0, \u0026#39;R\u0026#39;}, {NULL, 0, 0, 0}, }; int c; c = getopt_long(argc, argv, \u0026#34;D:s:d:b:lHOLC3NR\u0026#34;, lopts, NULL); if (c == -1) break; switch (c) { case \u0026#39;D\u0026#39;: device = optarg; break; case \u0026#39;s\u0026#39;: speed = atoi(optarg); break; case \u0026#39;d\u0026#39;: delay = atoi(optarg); break; case \u0026#39;b\u0026#39;: bits = atoi(optarg); break; case \u0026#39;l\u0026#39;: mode |= SPI_LOOP; break; case \u0026#39;H\u0026#39;: mode |= SPI_CPHA; break; case \u0026#39;O\u0026#39;: mode |= SPI_CPOL; break; case \u0026#39;L\u0026#39;: mode |= SPI_LSB_FIRST; break; case \u0026#39;C\u0026#39;: mode |= SPI_CS_HIGH; break; case \u0026#39;3\u0026#39;: mode |= SPI_3WIRE; break; case \u0026#39;N\u0026#39;: mode |= SPI_NO_CS; break; case \u0026#39;R\u0026#39;: mode |= SPI_READY; break; default: print_usage(argv[0]); break; } } } int main(int argc, char *argv[]) { int ret = 0; int fd; parse_opts(argc, argv); fd = open(device, O_RDWR); if (fd \u0026lt; 0) pabort(\u0026#34;can\u0026#39;t open device\u0026#34;); /* * spi mode */ ret = ioctl(fd, SPI_IOC_WR_MODE, \u0026amp;mode); if (ret == -1) pabort(\u0026#34;can\u0026#39;t set spi mode\u0026#34;); ret = ioctl(fd, SPI_IOC_RD_MODE, \u0026amp;mode); if (ret == -1) pabort(\u0026#34;can\u0026#39;t get spi mode\u0026#34;); /* * bits per word */ ret = ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, \u0026amp;bits); if (ret == -1) pabort(\u0026#34;can\u0026#39;t set bits per word\u0026#34;); ret = ioctl(fd, SPI_IOC_RD_BITS_PER_WORD, \u0026amp;bits); if (ret == -1) pabort(\u0026#34;can\u0026#39;t get bits per word\u0026#34;); /* * max speed hz */ ret = ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, \u0026amp;speed); if (ret == -1) pabort(\u0026#34;can\u0026#39;t set max speed hz\u0026#34;); ret = ioctl(fd, SPI_IOC_RD_MAX_SPEED_HZ, \u0026amp;speed); if (ret == -1) pabort(\u0026#34;can\u0026#39;t get max speed hz\u0026#34;); printf(\u0026#34;spi mode: %d\\n\u0026#34;, mode); printf(\u0026#34;bits per word: %d\\n\u0026#34;, bits); printf(\u0026#34;max speed: %d Hz (%d KHz)\\n\u0026#34;, speed, speed / 1000); transfer(fd); close(fd); return ret; } 编译该文件运行，若输出结果如下则修改成功\nspi mode: 0 bits per word: 8 max speed: 500000 Hz (500 KHz) FF FF FF FF FF FF 40 00 00 00 00 95 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF DE AD BE EF BA AD F0 0D ","date":"2017-02-28T12:14:00Z","permalink":"https://nansenli.com/zh-cn/post/jianshu/%E5%B5%8C%E5%85%A5%E5%BC%8F/cubieboard2-%E6%B7%BB%E5%8A%A0spi-%E9%A9%B1%E5%8A%A8%E6%94%AF%E6%8C%81/","title":"Cubieboard2 添加SPI 驱动支持"},{"content":"1.简介 GIC-400是用于控制中断的。在cubieboard2 上 的A20芯片采用了这款控制器。\ncubieboard2 的GIC控制器 的地址是0x01C80000\u0026mdash;0x01C87FFF ，长度等于GIC-400寄存器的长度。\n具体的内容如下所示。\n以0x01C80000为起始地址，下面给出的是偏移：\n偏移地址 说明 0x0000-0x0FFF Reserved 未使用，无用 0x1000-0x1FFF Distributor 配置器 有用 0x2000-0x3FFF CPU interfaces CPU接口 有用 0x4000-0x4FFF Virtual interface control block, for the processor that is performing the access虚拟化相关，无用 0x5000-0x5FFF Virtual interface control block, for the processor selected by address bits [11:9]虚拟化相关，无用 0x5000-0x51FF0x5200-0x53FF\u0026hellip;0x5E00-0x5FFF Alias for Processor 0Alias for Processor 1\u0026hellip;Alias for Processor 7 0x6000-0x7FFF Virtual CPU interfaces虚拟化相关，无用 常用的是图中第二块和第三块，0x1000~0x3fff这部分的配置。\n2.Distributor 配置器 distributor这块寄存器的地址 = GIC控制器 的地址 + 0x1000 ，使用的时候别忘记了偏移。然后从这里开始，有如下的寄存器\n偏移 名称 可读写 复位后 作用 0x000 GICD_CTLR RW 0x00000000[c] Distributor Control Register写入1使能控制器，必备 0x004 GICD_TYPER RO Configuration-dependent[d] Interrupt Controller Type Register其中可以查看中断线的总数 0x008 GICD_IIDR RO 0x0200143B Distributor Implementer Identification Register, GICD_IIDR存了一些版本信息，没用 0x080-0x0BC GICD_IGROUPRn RW 0x00000000 Interrupt Group Registers[e]一个位图，控制中断属于A组还是B组 0x100 GICD_ISENABLERn RW[f] SGIs and PPIs:0x0000FFFF[g] Interrupt Set-Enable Registers一个位图，用于使能各个中断，写入1使能。有用 0x104-0x13C SPIs: 0x00000000 0x180 GICD_ICENABLERn RW[f] 0x0000FFFF[g] Interrupt Clear-Enable Registers和上一个寄存器类似，作用相反，写入1禁止。 0x184-0x1BC 0x00000000 0x200-0x23C GICD_ISPENDRn RW 0x00000000 Interrupt Set-Pending Registerspend位图，写入1可以进入pend状态 0x280-0x2BC GICD_ICPENDRn RW 0x00000000 Interrupt Clear-Pending Registers同上，写入1效果相反，阻止pend状态 0x300-0x33C GICD_ISACTIVERn RW 0x00000000 Interrupt Set-Active Registers位图，写入1可以激活中断 0x380-0x3BC GICD_ICACTIVERn RW 0x00000000 Interrupt Clear-Active Registers写入1反激活中断 0x400-0x5FC GICD_IPRIORITYRn RW 0x00000000 Interrupt Priority Registers存着各个中断的优先级，每8位算一个 0x800-0x81C GICD_ITARGETSRn RO[h] - Interrupt Processor Targets Registers[i]某个中断应该发往哪个处理器进行处理 0x820-0x9FC RW 0x00000000 0xC00 GICD_ICFGRn RO SGIs: 0xAAAAAAAA Interrupt Configuration Registers, GICD_ICFGRn配置中断是低电平触发还是下降沿触发 0xC04 RO PPIs: 0x55540000 0xC08-0xC7C RW[j] SPIs: 0x55555555 0xD00 GICD_PPISR RO 0x00000000 Private Peripheral Interrupt Status Register, GICD_PPISR一般没用 0xD04-0xD3C GICD_SPISRn RO 0x00000000 Shared Peripheral Interrupt Status Registers, GICD_SPISRn没用 0xF00 GICD_SGIR WO - Software Generated Interrupt Register控制软中断 0xF10-0xF1C GICD_CPENDSGIRn RW 0x00000000 SGI Clear-Pending Registers软中断的pend位 0xF20-0xF2C GICD_SPENDSGIRn RW 0x00000000 SGI Set-Pending Registers同上，不过写入1时停止pend 0xFD0 GICD_PIDR4 RO 0x00000004 Peripheral ID 4 Register 0xFD4 GICD_PIDR5 RO 0x00000000 Peripheral ID 5 Register 0xFD8 GICD_PIDR6 RO 0x00000000 Peripheral ID 6 Register 0xFDC GICD_PIDR7 RO 0x00000000 Peripheral ID 7 Register 0xFE0 GICD_PIDR0 RO 0x00000090 Peripheral ID 0 Register 0xFE4 GICD_PIDR1 RO 0x000000B4 Peripheral ID 1 Register 0xFE8 GICD_PIDR2 RO 0x0000002B Peripheral ID 2 Register 0xFEC GICD_PIDR3 RO 0x00000000 Peripheral ID 3 Register 0xFF0 GICD_CIDR0 RO 0x0000000D Component ID 0 Register 0xFF4 GICD_CIDR1 RO 0x000000F0 Component ID 1 Register 0xFF8 GICD_CIDR2 RO 0x00000005 Component ID 2 Register 0xFFC GICD_CIDR3 RO 0x000000B1 Component ID 3 Register 3.CPU接口 开始地址的偏移量为0x2000\nOffset Name Type Reset Description[a] 0x0000 GICC_CTLR RW 0x00000000 CPU Interface Control Register使能位。写入1使能 0x0004 GICC_PMR RW 0x00000000 Interrupt Priority Mask Register限制中断最低优先级，高于此值无法中断，最好写大一点 0x0008 GICC_BPR RW 0x00000002[b] Binary Point RegisterThe minimum value of the Binary Point Register depends on which security-banked copy is considered:0x2 Secure copy0x3 Non-secure copy优先级分组 0x000C GICC_IAR RO 0x000003FF Interrupt Acknowledge Register只读，中断id 0x0010 GICC_EOIR WO - End of Interrupt Register写入以告知cpu已经处理完中断 0x0014 GICC_RPR RO 0x000000FF Running Priority Register当前中断优先级 0x0018 GICC_HPPIR RO 0x000003FF Highest Priority Pending Interrupt Register [c]最高优先级中断号及其pend值 0x001C GICC_ABPR RW 0x00000003 Aliased Binary Point Register[d]The minimum value of the Aliased Binary Point Register is 0x3.别名寄存器 0x0020 GICC_AIAR RO 0x000003FF Aliased Interrupt Acknowledge Register[d]别名寄存器 0x0024 GICC_AEOIR WO - Aliased End of Interrupt Register[d]别名寄存器 0x0028 GICC_AHPPIR RO 0x000003FF Aliased Highest Priority Pending Interrupt Register[c][d]别名寄存器 0x00D0 GICC_APR0 RW 0x00000000 Active Priority Register用于保存和恢复 0x00E0 GICC_NSAPR0 RW 0x00000000 Non-Secure Active Priority Register[d]用于保存和恢复 0x00FC GICC_IIDR RO 0x0202143B CPU Interface Identification Register, GICC_IIDR存着版本信息 0x1000 GICC_DIR WO - Deactivate Interrupt Register ","date":"2016-06-30T20:00:00Z","permalink":"https://nansenli.com/zh-cn/post/kokeyuan/arm-gic-400-registers/","title":"ARM GIC-400 寄存器"},{"content":"本代码适用于 NRF24L01 STC15F204EA(STC15L204EA) 组合成的小型无线收发模块,也可以适用于一般51单片机于NRF24L01通信\n前几天在网上购买的一个小型的无线收发模块,卖家发的源代码很简单,没有什么实用的地方,于是移植了原子的STM3224l01程序过来,该程序更完备,更实用\n由于几乎没有管脚用来显示收发的内容,所以使用串口通信来完成显示的内容\n适用模块图片:\n主要接线图:\n首先为了串口显示,在网上搜集了如下代码,之所以这样复杂,是因为这块芯片没有串口功能\n首先是H文件:\n#ifndef _UART_H #define _UART_H #define MCU_FREQ 11059200 // 设置晶振频率 #define UART_BUAD 38400 #define ON 1 #define OFF 0 #define UART_TX_PIN P31 #define UART_TX_SET(n) UART_TX_PIN = n #define UART_TX_HIGH() UART_TX_SET(1) #define UART_TX_LOW() UART_TX_SET(0) #define UART_TX_FLIP() UART_TX_PIN = !UART_TX_PIN #define UART_RX_PIN P30 #define UART_RX_SET(n) UART_RX_PIN = n #define UART_RX_HIGH() UART_RX_SET(1) #define UART_RX_LOW() UART_RX_SET(0) #define UART_RX_FLIP() UART_RX_PIN = !UART_RX_PIN void uartInit(void); void uartSendString(char *pS); void uartSendNum(int num); #endif 文件中要设定好晶振的频率和串号的频率,分别为MCU_FREQ和UART_BUAD,设定好以后才能正确收发\n接下来是C文件:\n#include \u0026#34;stdio.h\u0026#34; #include \u0026#34;uart.h\u0026#34; #include \u0026#34;15f204ea.h\u0026#34; //由宏晶官网提供的头文件 typedef unsigned char u8; typedef unsigned short u16; typedef unsigned int u32; typedef unsigned char uchar; typedef unsigned int uint; typedef unsigned char BYTE; static bit bUartFlag; /******************************************************************************/ // 函数名称：uartInit // 输入参数：无 // 输出参数：无 // 函数功能：设置好定时器0的工作模式 /******************************************************************************/ void uartInit(void) { /* * 设置定时器0为16位自动重载定时器 */ AUXR |= 0x80; //定时器0为1T模式 TMOD \u0026amp;= 0xF0; //设置定时器为模式0(16位自动重装载) TL0 = (0xFFFF - MCU_FREQ / UART_BUAD) \u0026amp; 0xFF; //设置定时初值 TH0 = ((0xFFFF - MCU_FREQ / UART_BUAD) \u0026gt;\u0026gt; 8) \u0026amp; 0xFF; //设置定时初值 TR0 = 0; //定时器0开始计时 ET0 = 0; //使能定时器0中断 EA = 1; } /******************************************************************************/ // 函数名称：uartSendData // 输入参数：ucData: 发送字节 // 输出参数：无 // 函数功能：使用串口发送一个字节数据 /******************************************************************************/ void uartSendData(u8 ucData) { u8 ucCnt; UART_TX_LOW(); //串口起始位开始 TR0 = 1; //定时器0开始计时 ET0 = 1; //使能定时器0中断 bUartFlag = ON; while(bUartFlag == ON); /* * 由低位开始，将数据通过串口输出 */ for (ucCnt = 0; ucCnt \u0026lt; 8; ucCnt++) { UART_TX_SET(ucData \u0026amp; 0x01); ucData \u0026gt;\u0026gt;= 1; bUartFlag = ON; while(bUartFlag == ON); } UART_TX_HIGH(); // 发送串口停止位 bUartFlag = ON; while(bUartFlag == ON); TR0 = 0; //定时器0结束计时 ET0 = 0; //禁能定时器0中断 } /******************************************************************************/ // 函数名称：uartSendString // 输入参数：pS: 字符串首地址 // 输出参数：无 // 函数功能：发送字符串通过串口输出 /******************************************************************************/ void uartSendString(char *pS) { while (*pS) //检测字符串结束标志 { uartSendData(*pS++); //发送当前字符 } uartSendData(\u0026#39;\\r\u0026#39;); uartSendData(\u0026#39;\\n\u0026#39;); } void uartSendNum(int num){ //使用sprintf函数打印整数(也可打印小数) char temp[14]; sprintf(temp,\u0026#34;%d\u0026#34;,num); uartSendString(temp); } /******************************************************************************/ // 函数名称：time0ISR // 输入参数：无 // 输出参数：无 // 函数功能：串口0服务函数 /******************************************************************************/ void time0ISR(void) interrupt 1 using 1 { EA = 0; bUartFlag = OFF; EA = 1; } 这个代码里面调用了15f204ea.h，这是我在宏晶网站下载的头文件,便于大家查找直接列出来了。由于文件太长，这里不再全部列出。\n至此串口显示搞定了\n然后是24l01的程序代码\n先是H文件:\n#ifndef __24L01_H #define __24L01_H #include \u0026#34;15f204ea.h\u0026#34; #define u8 unsigned char #define u16 unsigned int typedef unsigned char uchar; typedef unsigned char uint; /*nRF24L01引脚定义*/ sbit CE = P1^4; sbit CSN = P1^5; sbit SCK = P1^2; sbit MOSI = P1^3; sbit MISO = P1^0; sbit IRQ = P1^1; //NRF24L01寄存器操作命令 #define READ_NRF_REG 0x00 //读配置寄存器,低5位为寄存器地址 #define WRITE_NRF_REG 0x20 //写配置寄存器,低5位为寄存器地址 #define RD_RX_PLOAD 0x61 //读RX有效数据,1~32字节 #define WR_TX_PLOAD 0xA0 //写TX有效数据,1~32字节 #define FLUSH_TX 0xE1 //清除TX FIFO寄存器.发射模式下用 #define FLUSH_RX 0xE2 //清除RX FIFO寄存器.接收模式下用 #define REUSE_TX_PL 0xE3 //重新使用上一包数据,CE为高,数据包被不断发送. #define NOP 0xFF //空操作,可以用来读状态寄存器 //SPI(NRF24L01)寄存器地址 #define CONFIG 0x00 //配置寄存器地址;bit0:1接收模式,0发射模式;bit1:电选择;bit2:CRC模式;bit3:CRC使能; //bit4:中断MAX_RT(达到最大重发次数中断)使能;bit5:中断TX_DS使能;bit6:中断RX_DR使能 #define EN_AA 0x01 //使能自动应答功能 bit0~5,对应通道0~5 #define EN_RXADDR 0x02 //接收地址允许,bit0~5,对应通道0~5 #define SETUP_AW 0x03 //设置地址宽度(所有数据通道):bit1,0:00,3字节;01,4字节;02,5字节; #define SETUP_RETR 0x04 //建立自动重发;bit3:0,自动重发计数器;bit7:4,自动重发延时 250*x+86us #define RF_CH 0x05 //RF通道,bit6:0,工作通道频率; #define RF_SETUP 0x06 //RF寄存器;bit3:传输速率(0:1Mbps,1:2Mbps);bit2:1,发射功率;bit0:低噪声放大器增益 #define STATUS 0x07 //状态寄存器;bit0:TX FIFO满标志;bit3:1,接收数据通道号(最大:6);bit4,达到最多次重发 //bit5:数据发送完成中断;bit6:接收数据中断; #define MAX_TX 0x10 //达到最大发送次数中断 #define TX_OK 0x20 //TX发送完成中断 #define RX_OK 0x40 //接收到数据中断 #define OBSERVE_TX 0x08 //发送检测寄存器,bit7:4,数据包丢失计数器;bit3:0,重发计数器 #define CD 0x09 //载波检测寄存器,bit0,载波检测; #define RX_ADDR_P0 0x0A //数据通道0接收地址,最大长度5个字节,低字节在前 #define RX_ADDR_P1 0x0B //数据通道1接收地址,最大长度5个字节,低字节在前 #define RX_ADDR_P2 0x0C //数据通道2接收地址,最低字节可设置,高字节,必须同RX_ADDR_P1[39:8]相等; #define RX_ADDR_P3 0x0D //数据通道3接收地址,最低字节可设置,高字节,必须同RX_ADDR_P1[39:8]相等; #define RX_ADDR_P4 0x0E //数据通道4接收地址,最低字节可设置,高字节,必须同RX_ADDR_P1[39:8]相等; #define RX_ADDR_P5 0x0F //数据通道5接收地址,最低字节可设置,高字节,必须同RX_ADDR_P1[39:8]相等; #define TX_ADDR 0x10 //发送地址(低字节在前),ShockBurstTM模式下,RX_ADDR_P0与此地址相等 #define RX_PW_P0 0x11 //接收数据通道0有效数据宽度(1~32字节),设置为0则非法 #define RX_PW_P1 0x12 //接收数据通道1有效数据宽度(1~32字节),设置为0则非法 #define RX_PW_P2 0x13 //接收数据通道2有效数据宽度(1~32字节),设置为0则非法 #define RX_PW_P3 0x14 //接收数据通道3有效数据宽度(1~32字节),设置为0则非法 #define RX_PW_P4 0x15 //接收数据通道4有效数据宽度(1~32字节),设置为0则非法 #define RX_PW_P5 0x16 //接收数据通道5有效数据宽度(1~32字节),设置为0则非法 #define FIFO_STATUS 0x17 //FIFO状态寄存器;bit0,RX FIFO寄存器空标志;bit1,RX FIFO满标志;bit2,3,保留 //bit4,TX FIFO空标志;bit5,TX FIFO满标志;bit6,1,循环发送上一数据包.0,不循环; ////////////////////////////////////////////////////////////////////////////// //24L01操作线 #define NRF24L01_CE CE //24L01片选信号 #define NRF24L01_CSN CSN //SPI片选信号 #define NRF24L01_IRQ IRQ //IRQ主机数据输入 //24L01发送接收数据宽度定义 #define TX_ADR_WIDTH 5 //5字节的地址宽度 #define RX_ADR_WIDTH 5 //5字节的地址宽度 #define TX_PLOAD_WIDTH 32 //20字节的用户数据宽度 #define RX_PLOAD_WIDTH 32 //20字节的用户数据宽度 void NRF24L01_Init(void);//初始化 void RX_Mode(void);//配置为接收模式 void TX_Mode(void);//配置为发送模式 u8 NRF24L01_Check(void);//检查24L01是否存在 u8 NRF24L01_TxPacket(u8 *txbuf);//发送一个包的数据 u8 NRF24L01_RxPacket(u8 *rxbuf);//接收一个包的数据 #endif 然后是C文件:\n#include \u0026#34;15f204ea.h\u0026#34; #include \u0026#34;24l01.h\u0026#34; #include \u0026#34;intrins.h\u0026#34; const u8 TX_ADDRESS[TX_ADR_WIDTH]={0x34,0x43,0x10,0x10,0x03}; //发送地址 const u8 RX_ADDRESS[RX_ADR_WIDTH]={0x34,0x43,0x10,0x10,0x03}; //发送地址 /****************************************************************************************** /*延时函数 /******************************************************************************************/ void inerDelay_us(unsigned char n) { for(;n\u0026gt;0;n--) _nop_(); } //**************************************************************************************** /*NRF24L01初始化 //***************************************************************************************/ void NRF24L01_Init(void) { inerDelay_us(100); CE=0; // chip enable CSN=1; // Spi disable SCK=0; // } /**************************************************************************************************** /*函数：uint SPI_RW(uint uchar) /*功能：NRF24L01的SPI写时序 /****************************************************************************************************/ uint SPI_RW(uint uchar) { uint bit_ctr; for(bit_ctr=0;bit_ctr\u0026lt;8;bit_ctr++) // output 8-bit { MOSI = (uchar \u0026amp; 0x80); // output \u0026#39;uchar\u0026#39;, MSB to MOSI uchar = (uchar \u0026lt;\u0026lt; 1); // shift next bit into MSB.. SCK = 1; // Set SCK high.. uchar |= MISO; // capture current MISO bit SCK = 0; // ..then set SCK low again } return(uchar); // return read uchar } /**************************************************************************************************** /*函数：uchar SPI_Read(uchar reg) /*功能：NRF24L01的SPI时序 /****************************************************************************************************/ uchar NRF24L01_Read_Reg(uchar reg) { uchar reg_val; CSN = 0; // CSN low, initialize SPI communication... SPI_RW(reg); // Select register to read from.. reg_val = SPI_RW(0); // ..then read registervalue CSN = 1; // CSN high, terminate SPI communication return(reg_val); // return register value } /****************************************************************************************************/ /*功能：NRF24L01读写寄存器函数 /****************************************************************************************************/ uint NRF24L01_Write_Reg(uchar reg, uchar value) { uint status; CSN = 0; // CSN low, init SPI transaction status = SPI_RW(reg); // select register SPI_RW(value); // ..and write value to it.. CSN = 1; // CSN high again return(status); // return nRF24L01 status uchar } /****************************************************************************************************/ /*函数：uint SPI_Read_Buf(uchar reg, uchar *pBuf, uchar uchars) /*功能: 用于读数据，reg：为寄存器地址，pBuf：为待读出数据地址，uchars：读出数据的个数 /****************************************************************************************************/ uint NRF24L01_Read_Buf(uchar reg, uchar *pBuf, uchar uchars) { uint status,uchar_ctr; CSN = 0; // Set CSN low, init SPI tranaction status = SPI_RW(reg); // Select register to write to and read status uchar for(uchar_ctr=0;uchar_ctr\u0026lt;uchars;uchar_ctr++) pBuf[uchar_ctr] = SPI_RW(0); // CSN = 1; return(status); // return nRF24L01 status uchar } /********************************************************************************************************* /*函数：uint SPI_Write_Buf(uchar reg, uchar *pBuf, uchar uchars) /*功能: 用于写数据：为寄存器地址，pBuf：为待写入数据地址，uchars：写入数据的个数 /*********************************************************************************************************/ uint NRF24L01_Write_Buf(uchar reg, uchar *pBuf, uchar uchars) { uint status,uchar_ctr; CSN = 0; //SPI使能 status = SPI_RW(reg); for(uchar_ctr=0; uchar_ctr\u0026lt;uchars; uchar_ctr++) // SPI_RW(*pBuf++); CSN = 1; //关闭SPI return(status); // } //检测24L01是否存在 //返回值:0，成功;1，失败 u8 NRF24L01_Check(void) { u8 buf[5]={0XA5,0XA5,0XA5,0XA5,0XA5}; u8 i; NRF24L01_Write_Buf(WRITE_NRF_REG+TX_ADDR,buf,5);//写入5个字节的地址. NRF24L01_Read_Buf(TX_ADDR,buf,5); //读出写入的地址 for(i=0;i\u0026lt;5;i++) if(buf[i]!=0XA5)break; if(i!=5)return 1;//检测24L01错误 return 0; //检测到24L01 } u8 NRF24L01_TxPacket(u8 *txbuf) { u8 sta; NRF24L01_CE=0; NRF24L01_Write_Buf(WR_TX_PLOAD,txbuf,TX_PLOAD_WIDTH);//写数据到TX BUF 32个字节 NRF24L01_CE=1;//启动发送 while(NRF24L01_IRQ!=0);//等待发送完成 sta=NRF24L01_Read_Reg(STATUS); //读取状态寄存器的值 NRF24L01_Write_Reg(WRITE_NRF_REG+STATUS,sta); //清除TX_DS或MAX_RT中断标志 if(sta\u0026amp;MAX_TX)//达到最大重发次数 { NRF24L01_Write_Reg(FLUSH_TX,0xff);//清除TX FIFO寄存器 return MAX_TX; } if(sta\u0026amp;TX_OK)//发送完成 { return TX_OK; } return 0xff;//其他原因发送失败 } //启动NRF24L01发送一次数据 //txbuf:待发送数据首地址 //返回值:0，接收完成；其他，错误代码 u8 NRF24L01_RxPacket(u8 *rxbuf) { u8 sta; sta=NRF24L01_Read_Reg(STATUS); //读取状态寄存器的值 NRF24L01_Write_Reg(WRITE_NRF_REG+STATUS,sta); //清除TX_DS或MAX_RT中断标志 if(sta\u0026amp;RX_OK)//接收到数据 { NRF24L01_Read_Buf(RD_RX_PLOAD,rxbuf,RX_PLOAD_WIDTH);//读取数据 NRF24L01_Write_Reg(FLUSH_RX,0xff);//清除RX FIFO寄存器 return 0; } return 1;//没收到任何数据 } //该函数初始化NRF24L01到RX模式 //设置RX地址,写RX数据宽度,选择RF频道,波特率和LNA HCURR //当CE变高后,即进入RX模式,并可以接收数据了 void RX_Mode(void) { NRF24L01_CE=0; NRF24L01_Write_Buf(WRITE_NRF_REG+RX_ADDR_P0,(u8*)RX_ADDRESS,RX_ADR_WIDTH);//写RX节点地址 NRF24L01_Write_Reg(WRITE_NRF_REG+EN_AA,0x01); //使能通道0的自动应答 NRF24L01_Write_Reg(WRITE_NRF_REG+EN_RXADDR,0x01);//使能通道0的接收地址 NRF24L01_Write_Reg(WRITE_NRF_REG+RF_CH,40); //设置RF通信频率 NRF24L01_Write_Reg(WRITE_NRF_REG+RX_PW_P0,RX_PLOAD_WIDTH);//选择通道0的有效数据宽度 NRF24L01_Write_Reg(WRITE_NRF_REG+RF_SETUP,0x0f);//设置TX发射参数,0db增益,2Mbps,低噪声增益开启 NRF24L01_Write_Reg(WRITE_NRF_REG+CONFIG, 0x0f);//配置基本工作模式的参数;PWR_UP,EN_CRC,16BIT_CRC,接收模式 NRF24L01_CE = 1; //CE为高,进入接收模式 } //该函数初始化NRF24L01到TX模式 //设置TX地址,写TX数据宽度,设置RX自动应答的地址,填充TX发送数据,选择RF频道,波特率和LNA HCURR //PWR_UP,CRC使能 //当CE变高后,即进入RX模式,并可以接收数据了 //CE为高大于10us,则启动发送. void TX_Mode(void) { NRF24L01_CE=0; NRF24L01_Write_Buf(WRITE_NRF_REG+TX_ADDR,(u8*)TX_ADDRESS,TX_ADR_WIDTH);//写TX节点地址 NRF24L01_Write_Buf(WRITE_NRF_REG+RX_ADDR_P0,(u8*)RX_ADDRESS,RX_ADR_WIDTH); //设置TX节点地址,主要为了使能ACK NRF24L01_Write_Reg(WRITE_NRF_REG+EN_AA,0x01); //使能通道0的自动应答 NRF24L01_Write_Reg(WRITE_NRF_REG+EN_RXADDR,0x01); //使能通道0的接收地址 NRF24L01_Write_Reg(WRITE_NRF_REG+SETUP_RETR,0x1a);//设置自动重发间隔时间:500us + 86us;最大自动重发次数:10次 NRF24L01_Write_Reg(WRITE_NRF_REG+RF_CH,40); //设置RF通道为40 NRF24L01_Write_Reg(WRITE_NRF_REG+RF_SETUP,0x0f); //设置TX发射参数,0db增益,2Mbps,低噪声增益开启 NRF24L01_Write_Reg(WRITE_NRF_REG+CONFIG,0x0e); //配置基本工作模式的参数;PWR_UP,EN_CRC,16BIT_CRC,接收模式,开启所有中断 NRF24L01_CE=1;//CE为高,10us后启动发送 inerDelay_us(20); } 接下来是主程序调试部分:\n#include \u0026#34;15f204ea.h\u0026#34; #include \u0026#34;24l01.h\u0026#34; #include \u0026#34;uart.h\u0026#34; #include \u0026#34;intrins.h\u0026#34; void delay500ms(void) //误差 -0.000000000063us { unsigned char a,b,c; for(c=212;c\u0026gt;0;c--) for(b=160;b\u0026gt;0;b--) for(a=80;a\u0026gt;0;a--); _nop_(); //if Keil,require use intrins.h } void delay100us(void) //误差 -0.083188657407us { unsigned char a,b; for(b=58;b\u0026gt;0;b--) for(a=8;a\u0026gt;0;a--); } void main(){ u8 tmp_buf[33]; u8 key,mode; u16 t=0; delay500ms(); uartInit(); uartSendString(\u0026#34;测试\u0026#34;); uartSendNum(1234); NRF24L01_Init(); while(NRF24L01_Check())//检测不到24L01 { uartSendString(\u0026#34;初始化失败\u0026#34;); delay500ms(); uartSendString(\u0026#34;请检查\u0026#34;); delay500ms(); } uartSendString(\u0026#34;启动\u0026#34;); if(0){ RX_Mode(); uartSendString(\u0026#34;接收模式\u0026#34;); while(1){ if(NRF24L01_RxPacket(tmp_buf)==0){ tmp_buf[32]=0;//加入字符串结束符 uartSendString(tmp_buf); } else delay100us(); } } else{ TX_Mode(); uartSendString(\u0026#34;发送模式\u0026#34;); mode=\u0026#39; \u0026#39;;//从空格键开始 while(1){ if(NRF24L01_TxPacket(tmp_buf)==TX_OK) { uartSendString(tmp_buf); key=mode; for(t=0;t\u0026lt;32;t++) { key++; if(key\u0026gt;(\u0026#39;~\u0026#39;))key=\u0026#39; \u0026#39;; tmp_buf[t]=key; } mode++; if(mode\u0026gt;\u0026#39;~\u0026#39;)mode=\u0026#39; \u0026#39;; tmp_buf[32]=0;//加入结束符 } else{ uartSendString(\u0026#34;发送失败\u0026#34;); }; delay500ms(); } } } 设定晶振为11.0594MHZ,写入程序以后\n首先连接好串口,然后上电,经过半秒以后,程序会发送串口数据给电脑\u0026quot;测试\u0026quot;和数字\u0026quot;1234\u0026quot;,注意串口工作频率是38400,\n如果确认无误以后应该是可以收到串口数据的,否则就是各个环节的频率没有设定对,要么就是数据线的问题\n然后程序会进行检查,成功返回\u0026quot;启动\u0026quot;,失败则显示\u0026quot;初始化失败\u0026quot;,\u0026ldquo;请检查\u0026rdquo;.失败的这种情况是因为nrf24l01烧坏了,或者是管脚接的不正确\n根据if后面括号里是1还是0,会选择进入接收模式或者发送模式.\n如果是接收模式的话,程序会通过串口发送\u0026quot;接收模式\u0026quot;,如果接收到数据则会返回数据内容;\n如果是发送模式,则程序会发送一段代码(一些不断变化的字符)给指定地址,如果发送成功,则返回发送的长度,并返回发送的数据,发送失败的时候,会显示发送失败;\n如果发送失败,可能是因为接收端不存在,此时NRF24L01_TxPacket返回的数据是10(发送重试最大次数),而不是32(发送的数据位数),所以会报错\n也可能是因为其他原因,则NRF24L01返回0xff,说明是其他原因失败,这时问题就不清楚了,需要仔细查找\n将两个芯片一块写入发程序,一块写入收程序,就可以查看效果了^_^\n至此NRF24L01 与 STC15F204EA (STC15L204EA) 收发搞定\n","date":"2013-09-01T00:55:00Z","permalink":"https://nansenli.com/zh-cn/post/kokeyuan/nrf24l01-stc15f204ea-wireless-communication/","title":"NRF24L01 + STC15F204EA 无线通信 源代码"}]