<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>è®¾è®¡æ¨¡å¼ on Nansen Li&#39;s Blog
ææ¥ æ£®çš„åšå®¢
</title>
        <link>https://nansenli.com/zh-cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
        <description>Recent content in è®¾è®¡æ¨¡å¼ on Nansen Li&#39;s Blog
ææ¥ æ£®çš„åšå®¢
</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>Nansen Li ğŸŒˆ ï¼ˆææ¥ æ£®ï¼‰</copyright>
        <lastBuildDate>Mon, 07 May 2018 06:15:00 +0000</lastBuildDate><atom:link href="https://nansenli.com/zh-cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>C&#43;&#43;å®Œç¾å•ä¾‹æ¨¡å¼</title>
        <link>https://nansenli.com/zh-cn/post/jianshu/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/c&#43;&#43;%E5%AE%8C%E7%BE%8E%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
        <pubDate>Mon, 07 May 2018 06:15:00 +0000</pubDate>
        
        <guid>https://nansenli.com/zh-cn/post/jianshu/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/c&#43;&#43;%E5%AE%8C%E7%BE%8E%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
        <description>&lt;h2 id=&#34;åŸå§‹çš„å•ä¾‹æ¨¡å¼&#34;&gt;åŸå§‹çš„å•ä¾‹æ¨¡å¼
&lt;/h2&gt;&lt;p&gt;å•ä¾‹æ¨¡å¼è¦åšå¦‚ä¸‹äº‹æƒ…ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ä¸èƒ½é€šè¿‡æ„é€ å‡½æ•°æ„é€ ï¼Œå¦åˆ™å°±èƒ½å¤Ÿå®ä¾‹åŒ–å¤šä¸ªã€‚æ„é€ å‡½æ•°éœ€è¦ç§æœ‰å£°æ˜&lt;/li&gt;
&lt;li&gt;ä¿è¯åªèƒ½äº§ç”Ÿä¸€ä¸ªå®ä¾‹&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„å®ç°ï¼š&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class Singleton
{
  private:
    static Singleton *local_instance;
    Singleton(){};

  public:
    static Singleton *getInstance()
    {
        if (local_instance == nullptr)
        {
            local_instance = new Singleton();
        }
        return local_instance;
    }
};

Singleton * Singleton::local_instance = nullptr;

int main()
{
    Singleton * s = Singleton::getInstance();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;ä½¿ç”¨å±€éƒ¨é™æ€å¯¹è±¡æ¥è§£å†³å­˜åœ¨çš„ä¸¤ä¸ªé—®é¢˜&#34;&gt;ä½¿ç”¨å±€éƒ¨é™æ€å¯¹è±¡æ¥è§£å†³å­˜åœ¨çš„ä¸¤ä¸ªé—®é¢˜
&lt;/h2&gt;&lt;p&gt;åˆšåˆšçš„ä»£ç ä¸­æœ‰ä¸¤ä¸ªé—®é¢˜ï¼Œä¸€ä¸ªæ˜¯å¤šçº¿ç¨‹çš„æƒ…å†µä¸‹å¯èƒ½ä¼šå‡ºç°newä¸¤æ¬¡çš„æƒ…å†µã€‚å¦å¤–ä¸€ä¸ªæ˜¯ç¨‹åºé€€å‡ºåæ²¡æœ‰è¿è¡Œææ„å‡½æ•°ã€‚
ä¸‹é¢é‡‡ç”¨äº†é™æ€å¯¹è±¡æ¥è§£å†³ã€‚&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class Singleton
{
  private:
    static Singleton *local_instance;
    Singleton(){
        cout &amp;lt;&amp;lt; &amp;#34;æ„é€ &amp;#34; &amp;lt;&amp;lt; endl;
    };
    ~Singleton(){
        cout &amp;lt;&amp;lt; &amp;#34;ææ„&amp;#34; &amp;lt;&amp;lt; endl;
    }

  public:
    static Singleton *getInstance()
    {
        static Singleton locla_s;
        return &amp;amp;locla_s;
    }
};


int main()
{
    cout &amp;lt;&amp;lt; &amp;#34;å•ä¾‹æ¨¡å¼è®¿é—®ç¬¬ä¸€æ¬¡å‰&amp;#34; &amp;lt;&amp;lt; endl;
    Singleton * s = Singleton::getInstance();
    cout &amp;lt;&amp;lt; &amp;#34;å•ä¾‹æ¨¡å¼è®¿é—®ç¬¬ä¸€æ¬¡å&amp;#34; &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; &amp;#34;å•ä¾‹æ¨¡å¼è®¿é—®ç¬¬äºŒæ¬¡å‰&amp;#34; &amp;lt;&amp;lt; endl;
    Singleton * s2 = Singleton::getInstance();
    cout &amp;lt;&amp;lt; &amp;#34;å•ä¾‹æ¨¡å¼è®¿é—®ç¬¬äºŒæ¬¡å&amp;#34; &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/4388248-dc4641f02558d6b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;è¾“å‡ºç»“æœ&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;è¯¥ä»£ç å¯èƒ½åœ¨c++11ä¹‹å‰çš„ç‰ˆæœ¬å¯¼è‡´å¤šæ¬¡æ„é€ å‡½æ•°çš„è°ƒç”¨ï¼Œæ‰€ä»¥åªèƒ½åœ¨è¾ƒæ–°çš„ç¼–è¯‘å™¨ä¸Šä½¿ç”¨ã€‚&lt;/p&gt;
&lt;h2 id=&#34;å¦‚æœæ˜¯c11ä¹‹å‰çš„ç‰ˆæœ¬é™æ€å¯¹è±¡çº¿ç¨‹ä¼šä¸å®‰å…¨&#34;&gt;å¦‚æœæ˜¯c++11ä¹‹å‰çš„ç‰ˆæœ¬ï¼Œé™æ€å¯¹è±¡çº¿ç¨‹ä¼šä¸å®‰å…¨
&lt;/h2&gt;&lt;p&gt;ä¸‹é¢è¿™ä¸ªç‰ˆæœ¬ä½¿ç”¨äº†mutexä»¥åŠé™æ€æˆå‘˜æ¥ææ„å•ä¾‹ã€‚è¯¥æ–¹æ¡ˆçš„åŠ£å¤„åœ¨äºé”å¯¼è‡´é€Ÿåº¦æ…¢ï¼Œæ•ˆç‡ä½ã€‚ä½†æ˜¯è‡³å°‘æ˜¯æ­£ç¡®çš„ï¼Œä¹Ÿèƒ½åœ¨c++11ä¹‹å‰çš„ç‰ˆæœ¬ä½¿ç”¨ï¼Œä»£ç çš„ç¤ºä¾‹å¦‚ä¸‹ï¼š&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class Singleton
{
  private:
    static Singleton *local_instance;
    static pthread_mutex_t mutex;
    Singleton(){
        cout &amp;lt;&amp;lt; &amp;#34;æ„é€ &amp;#34; &amp;lt;&amp;lt; endl;
    };
    ~Singleton(){
        cout &amp;lt;&amp;lt; &amp;#34;ææ„&amp;#34; &amp;lt;&amp;lt; endl;
    }
    class rememberFree{
        public:
        rememberFree(){
            cout &amp;lt;&amp;lt; &amp;#34;æˆå‘˜æ„é€ &amp;#34; &amp;lt;&amp;lt; endl;
        }
        ~rememberFree(){
            if(Singleton::local_instance != nullptr){
                delete Singleton::local_instance;
            }
        }
    };
    static rememberFree remember;

  public:
    static Singleton *getInstance()
    {
        pthread_mutex_lock(&amp;amp;mutex);
        if (local_instance == nullptr)
        {
            local_instance = new Singleton();
        }
        pthread_mutex_unlock(&amp;amp;mutex);
        return local_instance;
    }
};

Singleton * Singleton::local_instance = nullptr;
pthread_mutex_t Singleton::mutex = PTHREAD_MUTEX_INITIALIZER;
Singleton::rememberFree Singleton::remember;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;ä½¿ç”¨åŒé”æ£€æŸ¥å¯¼è‡´æœªåˆå§‹åŒ–çš„å†…å­˜è®¿é—®&#34;&gt;ä½¿ç”¨åŒé”æ£€æŸ¥å¯¼è‡´æœªåˆå§‹åŒ–çš„å†…å­˜è®¿é—®
&lt;/h2&gt;&lt;p&gt;ä½¿ç”¨å¦‚ä¸‹çš„ä»£ç æ¥å®ç°å·²ç»åˆå§‹åŒ–çš„å¯¹è±¡çš„ç›´æ¥è¿”å›ã€‚å¯ä»¥ä½¿ä¸Šè¿°ä»£ç æ€§èƒ½ä¼šå¤§å¤§åŠ å¿«ã€‚ä½†æ˜¯ç›¸åŒçš„ä»£ç åœ¨Javaä¸‹é¢æœ‰å¾ˆæ˜æ˜¾çš„é—®é¢˜ï¼Œç”±äºCPUä¹±åºæ‰§è¡Œï¼Œå¯èƒ½å¯¼è‡´è®¿é—®åˆ°æœªç»åˆå§‹åŒ–çš„å¯¹è±¡çš„å¼•ç”¨ã€‚
C++æ˜¯å¦æœ‰åŒæ ·çš„é—®é¢˜å‘¢ï¼Ÿçœ‹ä¸‹æ–‡: &lt;a class=&#34;link&#34; href=&#34;http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf&lt;/a&gt;
ç»“è®ºæ˜¯ä¸€æ ·çš„ï¼Œc++ä¹Ÿå­˜åœ¨ç›¸åŒçš„é—®é¢˜ï¼Œå¯èƒ½å¯¼è‡´æœªå®šä¹‰è¡Œä¸ºå¯¼è‡´æ®µé”™è¯¯ã€‚åŒé”æ£€æŸ¥ä»£ç çš„ä¾‹å­å¦‚ä¸‹ï¼š&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;static Singleton *getInstance()
    {
        if(local_instance == nullptr){
            pthread_mutex_lock(&amp;amp;mutex);
            if (local_instance == nullptr)
            {
                local_instance = new Singleton();
            }
            pthread_mutex_unlock(&amp;amp;mutex);
        }
        return local_instance;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;å‡å¦‚çº¿ç¨‹Aè¿›å…¥é”å†…å¹¶åˆ†é…å¯¹è±¡çš„ç©ºé—´ï¼Œä½†æ˜¯ç”±äºæŒ‡ä»¤å¯èƒ½ä¹±åºï¼Œå®é™…ä¸Šå¯¼è‡´local_instanceè¢«å…ˆæŒ‡å‘ä¸€å—æœªè¢«åˆ†é…çš„å†…å­˜ï¼Œç„¶åå†åœ¨è¿™å—å†…å­˜ä¸Šè¿›ç¨‹åˆå§‹åŒ–ã€‚ä½†æ˜¯åœ¨æŒ‡å‘åï¼Œæœªåˆå§‹åŒ–å‰ï¼Œå¦ä¸€çº¿ç¨‹Bå¯èƒ½é€šè¿‡getInstanceè·å–åˆ°è¿™ä¸ªæŒ‡é’ˆã€‚&lt;/p&gt;
&lt;h2 id=&#34;å°è¯•ä½¿ç”¨å±€éƒ¨å˜é‡å¹¶ä¸èƒ½ä¿è¯æŒ‡ä»¤æ‰§è¡Œé¡ºåº&#34;&gt;å°è¯•ä½¿ç”¨å±€éƒ¨å˜é‡å¹¶ä¸èƒ½ä¿è¯æŒ‡ä»¤æ‰§è¡Œé¡ºåº
&lt;/h2&gt;&lt;p&gt;å°è¯•ä½¿ç”¨ä¸´æ—¶å˜é‡å¼ºåˆ¶æŒ‡å®šæŒ‡ä»¤è¿è¡Œé¡ºåºæ—¶ï¼Œä»ç„¶ä¼šè¢«ç¼–è¯‘å™¨è®¤ä¸ºæ˜¯æ— ç”¨çš„å˜é‡ï¼Œç„¶åè¢«ä¼˜åŒ–æ‰ã€‚ä¸‹è¿°ä»£ç æ˜¯ä¸€ä¸ªæƒ³æ³•å¾ˆå¥½ä½†æ˜¯æ— æ³•å®ç°ç›®çš„ä»£ç ï¼š&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;        if(local_instance == nullptr){
            static mutex mtx;
            lock_guard&amp;lt;mutex&amp;gt; lock(mtx);
            if (local_instance == nullptr)
            {
                auto tmp = new Singleton()
                local_instance = tmp;            }
        }
        return local_instance;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;ä¸ä¼˜é›…çš„ä½¿ç”¨volatileæ¥è§£å†³æŒ‡ä»¤ä¹±åºåœ¨åŒæ£€æŸ¥é”ä¸­å‡ºç°çš„é—®é¢˜&#34;&gt;ä¸ä¼˜é›…çš„ä½¿ç”¨volatileæ¥è§£å†³æŒ‡ä»¤ä¹±åºåœ¨åŒæ£€æŸ¥é”ä¸­å‡ºç°çš„é—®é¢˜
&lt;/h2&gt;&lt;p&gt;å°è¯•ä½¿ç”¨volatileå£°æ˜å†…éƒ¨çš„æŒ‡é’ˆï¼Œä»£ç å¦‚ä¸‹ï¼š&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class Singleton
{
  private:
    static Singleton * volatile local_instance;
    Singleton(){
        cout &amp;lt;&amp;lt; &amp;#34;æ„é€ &amp;#34; &amp;lt;&amp;lt; endl;
    };
    ~Singleton(){
        cout &amp;lt;&amp;lt; &amp;#34;ææ„&amp;#34; &amp;lt;&amp;lt; endl;
    }
    class rememberFree{
        public:
        rememberFree(){
            cout &amp;lt;&amp;lt; &amp;#34;æˆå‘˜æ„é€ &amp;#34; &amp;lt;&amp;lt; endl;
        }
        ~rememberFree(){
            if(Singleton::local_instance != nullptr){
                delete Singleton::local_instance;
            }
        }
    };
    static rememberFree remember;
    

  public:
    static Singleton *getInstance()
    {
        if(local_instance == nullptr){
            static mutex mtx;
            lock_guard&amp;lt;mutex&amp;gt; lock(mtx);
            if (local_instance == nullptr)
            {
                auto tmp = new Singleton();
                local_instance = tmp;
            }
        }
        return local_instance;
    }
};

Singleton * volatile Singleton::local_instance = nullptr;
Singleton::rememberFree Singleton::remember;

int main()
{
    cout &amp;lt;&amp;lt; &amp;#34;å•ä¾‹æ¨¡å¼è®¿é—®ç¬¬ä¸€æ¬¡å‰&amp;#34; &amp;lt;&amp;lt; endl;
    Singleton * s = Singleton::getInstance();
    cout &amp;lt;&amp;lt; &amp;#34;å•ä¾‹æ¨¡å¼è®¿é—®ç¬¬ä¸€æ¬¡å&amp;#34; &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; &amp;#34;å•ä¾‹æ¨¡å¼è®¿é—®ç¬¬äºŒæ¬¡å‰&amp;#34; &amp;lt;&amp;lt; endl;
    Singleton * s2 = Singleton::getInstance();
    cout &amp;lt;&amp;lt; &amp;#34;å•ä¾‹æ¨¡å¼è®¿é—®ç¬¬äºŒæ¬¡å&amp;#34; &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;åœ¨è¿™ä»½ä»£ç ä¸­ï¼Œè™½ç„¶tempæ˜¯volatileï¼Œä½†æ˜¯*tempä¸æ˜¯ï¼Œå…¶æˆå‘˜ä¹Ÿä¸æ˜¯ã€‚æ‰€ä»¥ä»ç„¶å¯èƒ½è¢«ä¼˜åŒ–ã€‚å°è¯•å°†å…¶*tempä¹Ÿå£°æ˜ä¸ºvolatileï¼Œä½ ä¼šå‘ç°çš„çš„ä»£ç å……æ»¡äº†volatileã€‚ä½†æ˜¯è‡³å°‘æ˜¯æ­£ç¡®çš„ï¼š&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class Singleton
{
  private:
    static volatile Singleton * volatile local_instance;
    Singleton(){
        cout &amp;lt;&amp;lt; &amp;#34;æ„é€ &amp;#34; &amp;lt;&amp;lt; endl;
    };
    ~Singleton(){
        cout &amp;lt;&amp;lt; &amp;#34;ææ„&amp;#34; &amp;lt;&amp;lt; endl;
    }
    class rememberFree{
        public:
        rememberFree(){
            cout &amp;lt;&amp;lt; &amp;#34;æˆå‘˜æ„é€ &amp;#34; &amp;lt;&amp;lt; endl;
        }
        ~rememberFree(){
            if(Singleton::local_instance != nullptr){
                delete Singleton::local_instance;
            }
        }
    };
    static rememberFree remember;
    

  public:
    static volatile Singleton *getInstance()
    {
        if(local_instance == nullptr){
            static mutex mtx;
            lock_guard&amp;lt;mutex&amp;gt; lock(mtx);
            if (local_instance == nullptr)
            {
                auto tmp = new Singleton();
                local_instance = tmp;
            }
        }
        return local_instance;
    }
};

volatile Singleton * volatile Singleton::local_instance = nullptr;
Singleton::rememberFree Singleton::remember;

int main()
{
    cout &amp;lt;&amp;lt; &amp;#34;å•ä¾‹æ¨¡å¼è®¿é—®ç¬¬ä¸€æ¬¡å‰&amp;#34; &amp;lt;&amp;lt; endl;
    volatile Singleton * s = Singleton::getInstance();
    cout &amp;lt;&amp;lt; &amp;#34;å•ä¾‹æ¨¡å¼è®¿é—®ç¬¬ä¸€æ¬¡å&amp;#34; &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; &amp;#34;å•ä¾‹æ¨¡å¼è®¿é—®ç¬¬äºŒæ¬¡å‰&amp;#34; &amp;lt;&amp;lt; endl;
    volatile Singleton * s2 = Singleton::getInstance();
    cout &amp;lt;&amp;lt; &amp;#34;å•ä¾‹æ¨¡å¼è®¿é—®ç¬¬äºŒæ¬¡å&amp;#34; &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;å¤§æ€å™¨å†…å­˜æ …æ &#34;&gt;å¤§æ€å™¨â€”â€”å†…å­˜æ …æ 
&lt;/h2&gt;&lt;p&gt;åœ¨æ–°çš„æ ‡å‡†ä¸­ï¼Œatomicç±»å®ç°äº†å†…å­˜æ …æ ï¼Œä½¿å¾—å¤šä¸ªæ ¸å¿ƒè®¿é—®å†…å­˜æ—¶å¯æ§ã€‚è¿™åˆ©ç”¨äº†c++11çš„å†…å­˜è®¿é—®é¡ºåºå¯æ§ã€‚ä¸‹é¢æ˜¯ä»£ç å®ç°ï¼š&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class Singleton
{
  private:
    // static volatile Singleton * volatile local_instance;
    static atomic&amp;lt;Singleton*&amp;gt; instance;
    Singleton(){
        cout &amp;lt;&amp;lt; &amp;#34;æ„é€ &amp;#34; &amp;lt;&amp;lt; endl;
    };
    ~Singleton(){
        cout &amp;lt;&amp;lt; &amp;#34;ææ„&amp;#34; &amp;lt;&amp;lt; endl;
    }
    class rememberFree{
        public:
        rememberFree(){
            cout &amp;lt;&amp;lt; &amp;#34;æˆå‘˜æ„é€ &amp;#34; &amp;lt;&amp;lt; endl;
        }
        ~rememberFree(){
            Singleton* local_instance = instance.load(std::memory_order_relaxed);
            if(local_instance != nullptr){
                delete local_instance;
            }
        }
    };
    static rememberFree remember;
    

  public:
    static Singleton *getInstance()
    {
        Singleton* tmp = instance.load(std::memory_order_relaxed);
        atomic_thread_fence(memory_order_acquire);
        if(tmp == nullptr){
            static mutex mtx;
            lock_guard&amp;lt;mutex&amp;gt; lock(mtx);
            tmp = instance.load(memory_order_relaxed);
            if (tmp == nullptr)
            {
                tmp = new Singleton();
                atomic_thread_fence(memory_order_release);
                instance.store(tmp, memory_order_relaxed);
            }
        }
        return tmp;
    }
};

atomic&amp;lt;Singleton*&amp;gt; Singleton::instance;
Singleton::rememberFree Singleton::remember;

int main()
{
    cout &amp;lt;&amp;lt; &amp;#34;å•ä¾‹æ¨¡å¼è®¿é—®ç¬¬ä¸€æ¬¡å‰&amp;#34; &amp;lt;&amp;lt; endl;
    Singleton * s = Singleton::getInstance();
    cout &amp;lt;&amp;lt; &amp;#34;å•ä¾‹æ¨¡å¼è®¿é—®ç¬¬ä¸€æ¬¡å&amp;#34; &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; &amp;#34;å•ä¾‹æ¨¡å¼è®¿é—®ç¬¬äºŒæ¬¡å‰&amp;#34; &amp;lt;&amp;lt; endl;
    Singleton * s2 = Singleton::getInstance();
    cout &amp;lt;&amp;lt; &amp;#34;å•ä¾‹æ¨¡å¼è®¿é—®ç¬¬äºŒæ¬¡å&amp;#34; &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ä¸Šè¿°ä»£ç å¯èƒ½éš¾ä»¥é˜…è¯»ï¼Œinstanceçš„ä¸¤æ¬¡åŠ è½½å¯ä»¥è¢«ä¹±åºæ‰§è¡Œã€‚ä½†æ˜¯åœ¨æ­¤æœŸé—´å†…çš„æ”¹åŠ¨è¢«å…¶ä»–CPUæ ¸å¿ƒè§‚å¯Ÿä¸åˆ°ã€‚åœ¨muduoä¸€ä¹¦ä¸Šï¼Œå†…å­˜æ …æ ä¹Ÿè¢«è¯„ä»·ä¸ºå¤§æ€å™¨ã€‚&lt;/p&gt;
&lt;h2 id=&#34;ä½¿ç”¨åŸå­æ“ä½œçš„å†…å­˜é¡ºåº&#34;&gt;ä½¿ç”¨åŸå­æ“ä½œçš„å†…å­˜é¡ºåº
&lt;/h2&gt;&lt;p&gt;è¿™é‡Œæœ‰å…­ä¸ªå†…å­˜åºåˆ—é€‰é¡¹å¯åº”ç”¨äºå¯¹åŸå­ç±»å‹çš„æ“ä½œï¼šmemory_order_relaxed, memory_order_consume, memory_order_acquire, memory_order_release, memory_order_acq_rel, ä»¥åŠmemory_order_seq_cstã€‚é™¤éä½ ä¸ºç‰¹å®šçš„æ“ä½œæŒ‡å®šä¸€ä¸ªåºåˆ—é€‰é¡¹ï¼Œè¦ä¸å†…å­˜åºåˆ—é€‰é¡¹å¯¹äºæ‰€æœ‰åŸå­ç±»å‹é»˜è®¤éƒ½æ˜¯memory_order_seq_cstã€‚è™½ç„¶æœ‰å…­ä¸ªé€‰é¡¹ï¼Œä½†æ˜¯å®ƒä»¬ä»…ä»£è¡¨ä¸‰ç§å†…å­˜æ¨¡å‹ï¼šæ’åºä¸€è‡´åºåˆ—(sequentially consistent)ï¼Œè·å–-é‡Šæ”¾åºåˆ—(memory_order_consume, memory_order_acquire, memory_order_releaseå’Œmemory_order_acq_rel)ï¼Œå’Œè‡ªç”±åºåˆ—(memory_order_relaxed)ã€‚&lt;/p&gt;
&lt;p&gt;è¿™é‡Œå¯ä»¥é‡‡ç”¨çš„æ¨¡å‹æœ‰ï¼šé»˜è®¤çš„memory_order_seq_cstå³é¡ºåºä¸€è‡´ä¸memory_order_acquireã€memory_order_releaseå³è·å–é‡Šæ”¾åºåˆ—ã€‚åè€…æ€§èƒ½å¯èƒ½æ›´å¥½ã€‚&lt;/p&gt;
&lt;p&gt;å¾…å®Œå–„&lt;/p&gt;
&lt;h2 id=&#34;ä½¿ç”¨pthread_once-æˆ–è€…call_once&#34;&gt;ä½¿ç”¨pthread_once æˆ–è€…call_once
&lt;/h2&gt;&lt;p&gt;å‰è€…æ¥è‡ªpthreadåº“ã€‚åè€…æ¥è‡ªstd::atomicã€‚&lt;/p&gt;
&lt;p&gt;å¾…å®Œå–„&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
