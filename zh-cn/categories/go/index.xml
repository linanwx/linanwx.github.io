<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Go on Nansen Li&#39;s Blog
ææ¥ æ£®çš„åšå®¢
</title>
        <link>https://nansenli.com/zh-cn/categories/go/</link>
        <description>Recent content in Go on Nansen Li&#39;s Blog
ææ¥ æ£®çš„åšå®¢
</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>Nansen Li ğŸŒˆ ï¼ˆææ¥ æ£®ï¼‰</copyright>
        <lastBuildDate>Wed, 14 Nov 2018 08:14:00 +0000</lastBuildDate><atom:link href="https://nansenli.com/zh-cn/categories/go/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Goç±»å‹å®˜æ–¹å‚è€ƒ ä¸­è‹±æ–‡å¯¹ç…§</title>
        <link>https://nansenli.com/zh-cn/post/jianshu/go/go%E7%B1%BB%E5%9E%8B%E5%AE%98%E6%96%B9%E5%8F%82%E8%80%83-%E4%B8%AD%E8%8B%B1%E6%96%87%E5%AF%B9%E7%85%A7/</link>
        <pubDate>Wed, 14 Nov 2018 08:14:00 +0000</pubDate>
        
        <guid>https://nansenli.com/zh-cn/post/jianshu/go/go%E7%B1%BB%E5%9E%8B%E5%AE%98%E6%96%B9%E5%8F%82%E8%80%83-%E4%B8%AD%E8%8B%B1%E6%96%87%E5%AF%B9%E7%85%A7/</guid>
        <description>&lt;h2 id=&#34;å®˜æ–¹å‚è€ƒ&#34;&gt;å®˜æ–¹å‚è€ƒ
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Types&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://golang.org/ref/spec#Types&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;å…¶ä¸­ç±»å‹æœ‰ï¼š&lt;/p&gt;
&lt;p&gt;Method sets æ–¹æ³•é›†åˆ
Boolean types å¸ƒå°”ç±»å‹
Numeric types æ•°å­—ç±»å‹
String types å­—ç¬¦ä¸²ç±»å‹
Array types æ•°ç»„ç±»å‹
Slice types åˆ‡ç‰‡ç±»å‹
Struct types ç»“æ„ä½“ç±»å‹
Pointer types æŒ‡é’ˆç±»å‹
Function types å‡½æ•°ç±»å‹
Interface types æ¥å£ç±»å‹
Map types å­—å…¸ç±»å‹
Channel types é€šé“ç±»å‹&lt;/p&gt;
&lt;h2 id=&#34;method-sets-æ–¹æ³•é›†åˆ&#34;&gt;Method sets æ–¹æ³•é›†åˆ
&lt;/h2&gt;&lt;p&gt;A type may have aÂ &lt;em&gt;method set&lt;/em&gt;Â associated with it. The method set of anÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Interface_types&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;interface type&lt;/a&gt;Â is its interface. The method set of any other typeÂ &lt;code&gt;T&lt;/code&gt;Â consists of allÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Method_declarations&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;methods&lt;/a&gt;Â declared with receiver typeÂ &lt;code&gt;T&lt;/code&gt;. The method set of the correspondingÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Pointer_types&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;pointer type&lt;/a&gt;Â &lt;code&gt;*T&lt;/code&gt;Â is the set of all methods declared with receiverÂ &lt;code&gt;*T&lt;/code&gt;Â orÂ &lt;code&gt;T&lt;/code&gt;Â (that is, it also contains the method set ofÂ &lt;code&gt;T&lt;/code&gt;). Further rules apply to structs containing embedded fields, as described in the section onÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Struct_types&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;struct types&lt;/a&gt;. Any other type has an empty method set. In a method set, each method must have aÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Uniqueness_of_identifiers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;unique&lt;/a&gt;Â non-&lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Blank_identifier&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;blank&lt;/a&gt;&lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#MethodName&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;method name&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The method set of a type determines the interfaces that the typeÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Interface_types&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;implements&lt;/a&gt;Â and the methods that can beÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Calls&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;called&lt;/a&gt;using a receiver of that type.&lt;/p&gt;
&lt;p&gt;æ¥å£ç±»å‹Interface typesçš„æ¥å£å°±æ˜¯æ–¹æ³•é›†åˆã€‚è‹¥ä¸€ç»„æ–¹æ³•çš„æ¥å—å‚æ•°éƒ½ä¸ºå‚æ•°Tï¼ŒæŠŠè¿™ç»„æ–¹æ³•å«Tç±»å‹çš„æ–¹æ³•é›†åˆã€‚TæŒ‡é’ˆçš„å¯¹åº”æ–¹æ³•é›†åˆï¼Œå…¶æ¥å—å‚æ•°ä¸ºTæˆ–è€…*Tã€‚è¿™æ„å‘³ç€TæŒ‡é’ˆçš„æ–¹æ³•é›†åˆåŒ…å«Tç±»å‹çš„æ–¹æ³•é›†åˆã€‚å¯¹ç»“æ„ä½“æ¥è¯´ï¼Œè¯¥è§„åˆ™åŒæ ·é€‚ç”¨ã€‚ä»»ä½•ç±»å‹éƒ½æœ‰ä¸€ä¸ªç©ºçš„æ–¹æ³•é›†åˆã€‚åœ¨æ–¹æ³•é›†åˆä¸­ï¼Œæ¯ä¸ªæ–¹æ³•éƒ½æœ‰ä¸€ä¸ªéç©ºçš„æ–¹æ³•åç§°ã€‚&lt;/p&gt;
&lt;p&gt;ç±»å‹çš„æ–¹æ³•é›†åˆç¡®å®šäº†è¯¥ç±»å‹å®ç°çš„æ¥å£ï¼Œä»¥åŠå¯ä»¥å¯ä»¥è¢«è¯¥ç±»å‹çš„æ¥æ”¶å™¨è°ƒç”¨çš„æ–¹æ³•ã€‚&lt;/p&gt;
&lt;h2 id=&#34;boolean-types-å¸ƒå°”ç±»å‹&#34;&gt;Boolean types å¸ƒå°”ç±»å‹
&lt;/h2&gt;&lt;p&gt;AÂ &lt;em&gt;boolean type&lt;/em&gt;Â represents the set of Boolean truth values denoted by the predeclared constantsÂ &lt;code&gt;true&lt;/code&gt;Â andÂ &lt;code&gt;false&lt;/code&gt;. The predeclared boolean type isÂ &lt;code&gt;bool&lt;/code&gt;; it is aÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Type_definitions&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;defined type&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;å¸ƒå°”ç±»å‹å®šä¹‰äº†å¸ƒå°”å˜é‡ï¼Œå¯è¢«èµ‹å€¼ä¸ºå¸¸é‡trueå’Œfalseã€‚è¯¥ç±»å‹æ˜¯å·²å®šä¹‰ç±»å‹ã€‚ä¾‹å¦‚å¯ä»¥ä½¿ç”¨charç±»å‹æ¥å®šä¹‰ã€‚&lt;/p&gt;
&lt;h2 id=&#34;numeric-types-æ•°å­—ç±»å‹&#34;&gt;Numeric types æ•°å­—ç±»å‹
&lt;/h2&gt;&lt;p&gt;A numeric type represents sets of integer or floating-point values. The predeclared architecture-independent numeric types are:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;uint8       the set of all unsigned  8-bit integers (0 to 255)
uint16      the set of all unsigned 16-bit integers (0 to 65535)
uint32      the set of all unsigned 32-bit integers (0 to 4294967295)
uint64      the set of all unsigned 64-bit integers (0 to 18446744073709551615)

int8        the set of all signed  8-bit integers (-128 to 127)
int16       the set of all signed 16-bit integers (-32768 to 32767)
int32       the set of all signed 32-bit integers (-2147483648 to 2147483647)
int64       the set of all signed 64-bit integers (-9223372036854775808 to 9223372036854775807)

float32     the set of all IEEE-754 32-bit floating-point numbers
float64     the set of all IEEE-754 64-bit floating-point numbers

complex64   the set of all complex numbers with float32 real and imaginary parts
complex128  the set of all complex numbers with float64 real and imaginary parts

byte        alias for uint8
rune        alias for int32
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The value of anÂ &lt;em&gt;n&lt;/em&gt;-bit integer isÂ &lt;em&gt;n&lt;/em&gt;Â bits wide and represented usingÂ &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Two%27s_complement&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;two&amp;rsquo;s complement arithmetic&lt;/a&gt;.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;uint     either 32 or 64 bits
int      same size as uint
uintptr  an unsigned integer large enough to store the uninterpreted bits of a pointer value
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is also a set of predeclared numeric types with implementation-specific sizes:&lt;/p&gt;
&lt;p&gt;To avoid portability issues all numeric types areÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Type_definitions&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;defined types&lt;/a&gt;Â and thus distinct exceptÂ &lt;code&gt;byte&lt;/code&gt;, which is anÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Alias_declarations&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;alias&lt;/a&gt;Â forÂ &lt;code&gt;uint8&lt;/code&gt;, andÂ &lt;code&gt;rune&lt;/code&gt;, which is an alias forÂ &lt;code&gt;int32&lt;/code&gt;. Conversions are required when different numeric types are mixed in an expression or assignment. For instance,Â &lt;code&gt;int32&lt;/code&gt;Â andÂ &lt;code&gt;int&lt;/code&gt;Â are not the same type even though they may have the same size on a particular architecture.&lt;/p&gt;
&lt;p&gt;æ•°å­—ç±»å‹åŒ…æ‹¬æ•´å‹å’Œæµ®ç‚¹ã€‚å†…ç½®å£°æ˜åŒ…æ‹¬uint8 uint16 uint32 uint64ä»¥åŠint8 int16 int32 int64 float32 float64 complex64 complex128 byte runeã€‚&lt;/p&gt;
&lt;p&gt;Nä½æ•´æ•°æ˜¯Nä½å®½åº¦ï¼Œä½¿ç”¨äºŒè¿›åˆ¶è¡¥ç è®¡ç®—ã€‚&lt;/p&gt;
&lt;p&gt;ä¸å¹³å°æ— å…³çš„å£°æ˜åŒ…å—uint int uintptrã€‚&lt;/p&gt;
&lt;p&gt;é™¤äº†byteå’Œruneå¤–ï¼Œå…¶ä»–æ•°å­—ç±»å‹ä¸ºå·²å®šä¹‰ç±»å‹ï¼Œè€Œbyteæ˜¯uint8çš„åˆ«åï¼Œruneæ˜¯int32çš„åˆ«åã€‚åœ¨æ•°å­—ç±»å‹ä¹‹é—´çš„è½¬æ¢éœ€è¦è¿›è¡Œæ˜¾ç¤ºè½¬æ¢ã€‚&lt;/p&gt;
&lt;h2 id=&#34;string-types-å­—ç¬¦ä¸²ç±»å‹&#34;&gt;String types å­—ç¬¦ä¸²ç±»å‹
&lt;/h2&gt;&lt;p&gt;AÂ &lt;em&gt;string type&lt;/em&gt;Â represents the set of string values. A string value is a (possibly empty) sequence of bytes. Strings are immutable: once created, it is impossible to change the contents of a string. The predeclared string type isÂ &lt;code&gt;string&lt;/code&gt;; it is aÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Type_definitions&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;defined type&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The length of a stringÂ &lt;code&gt;s&lt;/code&gt;Â (its size in bytes) can be discovered using the built-in functionÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Length_and_capacity&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt;. The length is a compile-time constant if the string is a constant. A string&amp;rsquo;s bytes can be accessed by integerÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Index_expressions&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;indices&lt;/a&gt;Â 0 throughÂ &lt;code&gt;len(s)-1&lt;/code&gt;. It is illegal to take the address of such an element; ifÂ &lt;code&gt;s[i]&lt;/code&gt;Â is theÂ &lt;code&gt;i&lt;/code&gt;&amp;lsquo;th byte of a string,Â &lt;code&gt;&amp;amp;s[i]&lt;/code&gt;Â is invalid.&lt;/p&gt;
&lt;p&gt;å­—ç¬¦ä¸²ç±»å‹å¯ä»¥è¡¨ç¤ºæ‰€æœ‰å­—ç¬¦ä¸²çš„å€¼ã€‚ä¸€ä¸ªå­—ç¬¦ä¸²çš„å€¼æ˜¯ä¸€ç³»åˆ—ç©ºæˆ–ä¸ç©ºçš„å­—èŠ‚åºåˆ—ã€‚ä»–çš„å€¼ä¸èƒ½è¢«ä¿®æ”¹ã€‚å­—ç¬¦ä¸²è¢«åˆ›å»ºåå°±ä¸èƒ½ä¿®æ”¹å†…å®¹ã€‚æˆ‘ä»¬ä½¿ç”¨stringæ¥å£°æ˜ä¸€ä¸ªstringç±»å‹ã€‚stringç±»å‹æ˜¯å·²å®šä¹‰ç±»å‹ã€‚&lt;/p&gt;
&lt;p&gt;ä¸€ä¸ªå­—ç¬¦ä¸²çš„é•¿åº¦ï¼ˆå…¶åŒ…å«å¤šå°‘ä¸ªå­—èŠ‚ï¼‰å¯ä»¥ä½¿ç”¨å†…å»ºå‡½æ•°lenæ¥è®¡ç®—ã€‚åœ¨ç¼–è¯‘å™¨å¯ä»¥è®¡ç®—ä¸€ä¸ªå¸¸é‡stringçš„é•¿åº¦ã€‚stringç±»å‹çš„å˜é‡å¯ä»¥è®¿é—®å…¶ä½ç½®0åˆ°ä½ç½®len-1çš„å€¼ã€‚å¯¹è¿™äº›ä½ç½®çš„å…ƒç´ ï¼Œè·å–å…¶åœ°å€æ˜¯éæ³•çš„ã€‚ä½¿ç”¨s[i]è¡¨ç¤ºså­—ç¬¦ä¸²ç¬¬iä¸ªä½ç½®çš„å…ƒç´ ï¼Œè€Œ&amp;amp;s[i]æ˜¯éæ³•çš„ã€‚&lt;/p&gt;
&lt;h2 id=&#34;array-types-æ•°ç»„ç±»å‹&#34;&gt;Array types æ•°ç»„ç±»å‹
&lt;/h2&gt;&lt;p&gt;An array is a numbered sequence of elements of a single type, called the element type. The number of elements is called the length and is never negative.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ArrayType   = &amp;#34;[&amp;#34; ArrayLength &amp;#34;]&amp;#34; ElementType .
ArrayLength = Expression .
ElementType = Type .
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The length is part of the array&amp;rsquo;s type; it must evaluate to a non-negativeÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Constants&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;constant&lt;/a&gt;Â &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Representability&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;representable&lt;/a&gt;Â by a value of typeÂ &lt;code&gt;int&lt;/code&gt;. The length of arrayÂ &lt;code&gt;a&lt;/code&gt;Â can be discovered using the built-in functionÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Length_and_capacity&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt;. The elements can be addressed by integerÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Index_expressions&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;indices&lt;/a&gt;Â 0 throughÂ &lt;code&gt;len(a)-1&lt;/code&gt;. Array types are always one-dimensional but may be composed to form multi-dimensional types.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[32]byte
[2*N] struct { x, y int32 }
[1000]*float64
[3][5]int
[2][2][2]float64  // same as [2]([2]([2]float64))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;æ•°ç»„ç±»å‹æ˜¯å¤šä¸ªåŒç±»å‹çš„å…ƒç´ æ„æˆçš„å¯æ•°åºåˆ—ã€‚å…ƒç´ çš„æ•°é‡æ˜¯æ•°ç»„çš„é•¿åº¦ã€‚é•¿åº¦ä¸èƒ½ä¸ºè´Ÿæ•°ã€‚&lt;/p&gt;
&lt;p&gt;æ•°ç»„çš„é•¿åº¦ä¹Ÿæ˜¯æ•°ç»„çš„ä¸€éƒ¨åˆ†ã€‚ä»–çš„å€¼éè´Ÿï¼Œå¯ä»¥ç”¨intè¡¨ç¤ºã€‚æ•°ç»„çš„é•¿åº¦ä½¿ç”¨lenæ±‚å‡ºã€‚æ•°ç»„çš„æ‰€æœ‰å…ƒç´ å¯ä»¥ä»ä½ç½®0åˆ°len-1è¿›è¡Œè®¿é—®ã€‚æ•°ç»„ç±»å‹æ°¸è¿œæ˜¯ä¸€ç»´çš„ï¼Œè¿›è¡Œç»„åˆå¯ä»¥è¡¨ç¤ºå¤šä½ç±»å‹ã€‚&lt;/p&gt;
&lt;h2 id=&#34;slice-types-åˆ‡ç‰‡&#34;&gt;Slice types åˆ‡ç‰‡
&lt;/h2&gt;&lt;p&gt;A slice is a descriptor for a contiguous segment of anÂ &lt;em&gt;underlying array&lt;/em&gt;Â and provides access to a numbered sequence of elements from that array. A slice type denotes the set of all slices of arrays of its element type. The value of an uninitialized slice isÂ &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SliceType = &amp;#34;[&amp;#34; &amp;#34;]&amp;#34; ElementType .
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Like arrays, slices are indexable and have a length. The length of a sliceÂ &lt;code&gt;s&lt;/code&gt;Â can be discovered by the built-in functionÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Length_and_capacity&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt;; unlike with arrays it may change during execution. The elements can be addressed by integerÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Index_expressions&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;indices&lt;/a&gt;Â 0 throughÂ &lt;code&gt;len(s)-1&lt;/code&gt;. The slice index of a given element may be less than the index of the same element in the underlying array.&lt;/p&gt;
&lt;p&gt;A slice, once initialized, is always associated with an underlying array that holds its elements. A slice therefore shares storage with its array and with other slices of the same array; by contrast, distinct arrays always represent distinct storage.&lt;/p&gt;
&lt;p&gt;The array underlying a slice may extend past the end of the slice. TheÂ &lt;em&gt;capacity&lt;/em&gt;Â is a measure of that extent: it is the sum of the length of the slice and the length of the array beyond the slice; a slice of length up to that capacity can be created byÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Slice_expressions&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;em&gt;slicing&lt;/em&gt;&lt;/a&gt;Â a new one from the original slice. The capacity of a sliceÂ &lt;code&gt;a&lt;/code&gt;Â can be discovered using the built-in functionÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Length_and_capacity&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;cap(a)&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A new, initialized slice value for a given element typeÂ &lt;code&gt;T&lt;/code&gt;Â is made using the built-in functionÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Making_slices_maps_and_channels&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;make&lt;/code&gt;&lt;/a&gt;, which takes a slice type and parameters specifying the length and optionally the capacity. A slice created withÂ &lt;code&gt;make&lt;/code&gt;Â always allocates a new, hidden array to which the returned slice value refers. That is, executing&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;make([]T, length, capacity)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;produces the same slice as allocating an array andÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Slice_expressions&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;slicing&lt;/a&gt;Â it, so these two expressions are equivalent:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;make([]int, 50, 100)
new([100]int)[0:50]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Like arrays, slices are always one-dimensional but may be composed to construct higher-dimensional objects. With arrays of arrays, the inner arrays are, by construction, always the same length; however with slices of slices (or arrays of slices), the inner lengths may vary dynamically. Moreover, the inner slices must be initialized individually.&lt;/p&gt;
&lt;p&gt;åˆ‡ç‰‡è¡¨ç¤ºåº•å±‚æ•°ç»„çš„è¿ç»­æ®µï¼Œæä¾›å¯¹è¯¥æ®µä½ç½®çš„å…ƒç´ è®¿é—®ã€‚åˆ‡ç‰‡çš„ç±»å‹è¡¨ç¤ºå…¶å…ƒç´ çš„ç±»å‹ã€‚æœªåˆå§‹åŒ–çš„åˆ‡ç‰‡çš„å€¼ä¸ºnilã€‚&lt;/p&gt;
&lt;p&gt;ä¸æ•°ç»„ç›¸åŒï¼Œåˆ‡ç‰‡çš„é•¿åº¦å¯ä»¥ä½¿ç”¨lenæ¥æ±‚å‡ºã€‚é•¿åº¦é€šå¸¸å°äºåŸæ¥çš„æ•°ç»„ã€‚&lt;/p&gt;
&lt;p&gt;åˆ‡ç‰‡è‡ªåˆå§‹åŒ–ä¹‹åä¸ä½å±‚æ•°ç»„å…±äº«å­˜å‚¨ç©ºé—´ï¼Œå¤šä¸ªåˆ‡ç‰‡å¯ä»¥å…±äº«åŒä¸€ä¸ªå­˜å‚¨ç©ºé—´ã€‚æ•°ç»„é€šå¸¸ä»£è¡¨äº†ä¸åŒçš„å­˜å‚¨ç©ºé—´ã€‚&lt;/p&gt;
&lt;p&gt;åˆ‡ç‰‡çš„ä½å±‚æ•°ç»„é•¿åº¦å¯ä»¥è¶…è¿‡åˆ‡ç‰‡çš„æœ«ç«¯ï¼Œä½¿ç”¨capå¯ä»¥è®¡ç®—åˆ‡ç‰‡çš„å®¹é‡ï¼Œå®¹é‡æ˜¯æ•°ç»„è¶…å‡ºåˆ‡ç‰‡çš„å€¼åŠ ä¸Šåˆ‡ç‰‡æœ¬èº«çš„å€¼ã€‚å¯ä»¥é€šè¿‡å¯¹åˆ‡ç‰‡é‡æ–°åˆ‡åˆ†å¾—åˆ°æ–°çš„è¶…è¿‡åŸé•¿åº¦çš„åˆ‡ç‰‡ã€‚&lt;/p&gt;
&lt;p&gt;ä½¿ç”¨å†…å»ºå‡½æ•°makeåˆ›å»ºæŒ‡å®šç±»å‹çš„åˆ‡ç‰‡ã€‚makeæ¥å—åˆ‡ç‰‡ç±»å‹å’Œåˆ‡ç‰‡çš„é•¿åº¦ï¼Œå®¹é‡ä½œä¸ºå¯é€‰å‚æ•°ã€‚ä½¿ç”¨makeåˆ›å»ºå‡ºæ¥çš„åˆ‡ç‰‡æ€»æ˜¯è¢«åˆ†é…ä¸€ä¸ªåˆ‡ç‰‡æ‰€å¼•ç”¨çš„éšè—æ•°ç»„ï¼Œè¿™æ„å‘³ç€é€šè¿‡makeåˆ›å»ºé•¿åº¦50å®¹é‡100çš„åˆ‡ç‰‡make([]int, 50, 100)ä¸é€šè¿‡newåˆ›å»ºä¸€ä¸ªé•¿åº¦100çš„æ•°ç»„å¹¶å¯¹å…¶åˆ‡ç‰‡50çš„é•¿åº¦new([100]int)[0:50]ä¸¤è€…çš„ç»“æœç›¸åŒã€‚&lt;/p&gt;
&lt;p&gt;ä¸æ•°ç»„ç›¸åŒï¼Œåˆ‡ç‰‡çš„é•¿åº¦æ˜¯ä¸€ç»´çš„ï¼Œä½†æ˜¯å¯ä»¥è¡¨ç¤ºæ›´é«˜çš„ç»´åº¦ã€‚å¯¹äºæ•°ç»„æ¥è¯´ï¼Œå†…éƒ¨çš„æ•°ç»„ç”±äºæ„é€ çš„é•¿åº¦ç›¸åŒï¼Œæ˜¯ä¸èƒ½æ”¹å˜çš„ã€‚å¤åˆåˆ‡ç‰‡çš„å†…éƒ¨é•¿åº¦ä¼šå˜æˆåŠ¨æ€çš„ï¼Œå¤åˆåˆ‡ç‰‡çš„å†…éƒ¨ä¹Ÿéœ€è¦å•ç‹¬åˆå§‹åŒ–ã€‚&lt;/p&gt;
&lt;h2 id=&#34;struct-types-ç»“æ„ä½“&#34;&gt;Struct types ç»“æ„ä½“
&lt;/h2&gt;&lt;p&gt;A struct is a sequence of named elements, called fields, each of which has a name and a type. Field names may be specified explicitly (IdentifierList) or implicitly (EmbeddedField). Within a struct, non-&lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Blank_identifier&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;blank&lt;/a&gt;Â field names must beÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Uniqueness_of_identifiers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;unique&lt;/a&gt;.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;StructType    = &amp;#34;struct&amp;#34; &amp;#34;{&amp;#34; { FieldDecl &amp;#34;;&amp;#34; } &amp;#34;}&amp;#34; .
FieldDecl     = (IdentifierList Type | EmbeddedField) [ Tag ] .
EmbeddedField = [ &amp;#34;*&amp;#34; ] TypeName .
Tag           = string_lit .
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// An empty struct.
struct {}

// A struct with 6 fields.
struct {
	x, y int
	u float32
	_ float32  // padding
	A *[]int
	F func()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A field declared with a type but no explicit field name is called an embedded field. An embedded field must be specified as a type name T or as a pointer to a non-interface type name *T, and T itself may not be a pointer type. The unqualified type name acts as the field name.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// A struct with four embedded fields of types T1, *T2, P.T3 and *P.T4
struct {
	T1        // field name is T1
	*T2       // field name is T2
	P.T3      // field name is T3
	*P.T4     // field name is T4
	x, y int  // field names are x and y
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The following declaration is illegal because field names must be unique in a struct type:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct {
	T     // conflicts with embedded field *T and *P.T
	*T    // conflicts with embedded field T and *P.T
	*P.T  // conflicts with embedded field T and *T
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A field orÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Method_declarations&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;method&lt;/a&gt;Â &lt;code&gt;f&lt;/code&gt;Â of an embedded field in a structÂ &lt;code&gt;x&lt;/code&gt;Â is calledÂ &lt;em&gt;promoted&lt;/em&gt;Â ifÂ &lt;code&gt;x.f&lt;/code&gt;Â is a legalÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Selectors&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;selector&lt;/a&gt;Â that denotes that field or methodÂ &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Promoted fields act like ordinary fields of a struct except that they cannot be used as field names inÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Composite_literals&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;composite literals&lt;/a&gt;Â of the struct.&lt;/p&gt;
&lt;p&gt;Given a struct typeÂ &lt;code&gt;S&lt;/code&gt;Â and aÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Type_definitions&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;defined type&lt;/a&gt;Â &lt;code&gt;T&lt;/code&gt;, promoted methods are included in the method set of the struct as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IfÂ &lt;code&gt;S&lt;/code&gt;Â contains an embedded fieldÂ &lt;code&gt;T&lt;/code&gt;, theÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Method_sets&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;method sets&lt;/a&gt;Â ofÂ &lt;code&gt;S&lt;/code&gt;Â andÂ &lt;code&gt;*S&lt;/code&gt;Â both include promoted methods with receiverÂ &lt;code&gt;T&lt;/code&gt;. The method set ofÂ &lt;code&gt;*S&lt;/code&gt;Â also includes promoted methods with receiverÂ &lt;code&gt;*T&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;IfÂ &lt;code&gt;S&lt;/code&gt;Â contains an embedded fieldÂ &lt;code&gt;*T&lt;/code&gt;, the method sets ofÂ &lt;code&gt;S&lt;/code&gt;Â andÂ &lt;code&gt;*S&lt;/code&gt;Â both include promoted methods with receiverÂ &lt;code&gt;T&lt;/code&gt;Â or&lt;code&gt;*T&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A field declaration may be followed by an optional string literalÂ &lt;em&gt;tag&lt;/em&gt;, which becomes an attribute for all the fields in the corresponding field declaration. An empty tag string is equivalent to an absent tag. The tags are made visible through aÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/pkg/reflect/#StructTag&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;reflection interface&lt;/a&gt;Â and take part inÂ &lt;a class=&#34;link&#34; href=&#34;https://golang.org/ref/spec#Type_identity&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;type identity&lt;/a&gt;Â for structs but are otherwise ignored.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct {
	x, y float64 &amp;#34;&amp;#34;  // an empty tag string is like an absent tag
	name string  &amp;#34;any string is permitted as a tag&amp;#34;
	_    [4]byte &amp;#34;ceci n&amp;#39;est pas un champ de structure&amp;#34;
}

// A struct corresponding to a TimeStamp protocol buffer.
// The tag strings define the protocol buffer field numbers;
// they follow the convention outlined by the reflect package.
struct {
	microsec  uint64 `protobuf:&amp;#34;1&amp;#34;`
	serverIP6 uint64 `protobuf:&amp;#34;2&amp;#34;`
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ç»“æ„ä½“æ˜¯ä¸€ç³»åˆ—å­—æ®µçš„é›†åˆï¼Œæ¯ä¸ªå­—æ®µæœ‰è‡ªå·±çš„åç§°å’Œç±»å‹ã€‚ç±»å‹å¯ä»¥éšå¼æŒ‡å®šã€‚åœ¨ç»“æ„ä¸­éç©ºå­—æ®µåç§°å¿…é¡»æ˜¯å”¯ä¸€çš„ã€‚&lt;/p&gt;
&lt;p&gt;ç»“æ„ä½“å¯ä»¥ä¸ºç©ºã€‚ä¹Ÿå¯ä»¥åŒ…å«int floatç­‰ç±»å‹ã€‚å¦‚æœä½¿ç”¨_è¡¨ç¤ºpaddingå ä½ã€‚&lt;/p&gt;
&lt;p&gt;å¦‚æœç»“æ„ä½“çš„å­—æ®µåªæœ‰ç±»å‹è€Œæ²¡æœ‰åå­—ï¼Œæˆ‘ä»¬è¡¨ç¤ºè¿™ä¸ªå­—æ®µæ˜¯åµŒå…¥å­—æ®µã€‚åµŒå…¥å­—æ®µçš„ç±»å‹å¿…é¡»æ˜¯ç±»å‹Tï¼Œæˆ–è€…æ˜¯ä¸€ä¸ªéæ¥å£ç±»å‹çš„æŒ‡é’ˆã€‚&lt;/p&gt;
&lt;p&gt;ç»“æ„ä½“xä¸­çš„åµŒå…¥å­—æ®µçš„å­—æ®µæˆ–æ–¹æ³•å«åšç»“æ„ä½“xçš„æå‡ã€‚å¯¹ç»“æ„ä½“xï¼Œè°ƒç”¨å…¶ä¸å­˜åœ¨çš„æˆå‘˜æˆ–è€…æ–¹æ³•ï¼Œä¼šä½¿ç”¨åµŒå…¥å­—æ®µçš„å­—æ®µæˆ–æ–¹æ³•æ¥ä»£æ›¿ã€‚&lt;/p&gt;
&lt;p&gt;è¢«æå‡çš„å­—æ®µè¡¨ç°çš„å°±åƒåŸå§‹å­—æ®µï¼Œé™¤äº†ä»–ä»¬ä¸èƒ½ç”¨åœ¨ç‰¹æ®Šåœºåˆã€‚&lt;/p&gt;
&lt;p&gt;ç»™å®šç»“æ„ä½“ç±»å‹å’Œå®šä¹‰çš„ç±»å‹Tï¼Œæå‡æ–¹æ³•åŒ…å«åœ¨ç»“æ„ä½“çš„æ–¹æ³•é›†ä¸­ã€‚&lt;/p&gt;
&lt;p&gt;å¦‚æœSåŒ…å«åµŒå…¥å­—æ®µTï¼Œä½¿ç”¨Tä¸ºæ¥å—ç€çš„è¯ï¼Œæå‡æ–¹æ³•è¢«åŒ…å«åœ¨Så’Œ&lt;em&gt;Sçš„æ–¹æ³•é›†åˆã€‚ä½¿ç”¨&lt;/em&gt;Tä¸ºæ¥å—è€…çš„è¯ï¼Œæå‡æ–¹æ³•è¢«åŒ…å«åœ¨*Sçš„æ–¹æ³•é›†åˆã€‚&lt;/p&gt;
&lt;p&gt;ç»“æ„ä½“çš„å­—æ®µåé¢ï¼Œå¯ä»¥è·Ÿä¸Šä¸€ä¸ªå­—ç¬¦ä¸²ã€‚è¿™ä¸ªå­—ç¬¦ä¸²å¯ä»¥é€šè¿‡åå°„çš„æ–¹å¼è·å–ã€‚å¯ä»¥ç”¨äºç‰¹æ®Šçš„åœºåˆã€‚ä¾‹å¦‚jsonè½¬æ¢ï¼Œprotobufè½¬æ¢ã€‚&lt;/p&gt;
&lt;h2 id=&#34;pointer-types-æŒ‡é’ˆç±»å‹&#34;&gt;Pointer types æŒ‡é’ˆç±»å‹
&lt;/h2&gt;&lt;p&gt;A pointer type denotes the set of all pointers to variables of a given type, called the base type of the pointer. The value of an uninitialized pointer is nil.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;PointerType = &amp;#34;*&amp;#34; BaseType .
BaseType    = Type .

*Point
*[4]int
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ä¸€ä¸ªæŒ‡é’ˆç±»å‹è¡¨ç¤ºæŒ‡å‘ç»™å®šç±»å‹æ‰€æœ‰å˜é‡çš„æŒ‡é’ˆçš„ç±»å‹ï¼Œæ˜¯æŒ‡é’ˆçš„åŸºç¡€ç±»å‹ã€‚æŒ‡é’ˆåœ¨æœªè¢«åˆå§‹åŒ–çš„æ—¶å€™ä½¿ç”¨nilä½œä¸ºåˆå€¼ã€‚&lt;/p&gt;
&lt;h2 id=&#34;function-types-å‡½æ•°ç±»å‹&#34;&gt;Function types å‡½æ•°ç±»å‹
&lt;/h2&gt;&lt;p&gt;A function type denotes the set of all functions with the same parameter and result types. The value of an uninitialized variable of function type is nil.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;FunctionType   = &amp;#34;func&amp;#34; Signature .
Signature      = Parameters [ Result ] .
Result         = Parameters | Type .
Parameters     = &amp;#34;(&amp;#34; [ ParameterList [ &amp;#34;,&amp;#34; ] ] &amp;#34;)&amp;#34; .
ParameterList  = ParameterDecl { &amp;#34;,&amp;#34; ParameterDecl } .
ParameterDecl  = [ IdentifierList ] [ &amp;#34;...&amp;#34; ] Type .
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Within a list of parameters or results, the names (IdentifierList) must either all be present or all be absent. If present, each name stands for one item (parameter or result) of the specified type and all non-blank names in the signature must be unique. If absent, each type stands for one item of that type. Parameter and result lists are always parenthesized except that if there is exactly one unnamed result it may be written as an unparenthesized type.&lt;/p&gt;
&lt;p&gt;The final incoming parameter in a function signature may have a type prefixed with &amp;hellip;. A function with such a parameter is called variadic and may be invoked with zero or more arguments for that parameter.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func()
func(x int) int
func(a, _ int, z float32) bool
func(a, b int, z float32) (bool)
func(prefix string, values ...int)
func(a, b int, z float64, opt ...interface{}) (success bool)
func(int, int, float64) (float64, *[]int)
func(n int) func(p *T)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ä¸€ä¸ªå‡½æ•°ç±»å‹è¡¨ç¤ºæ‰€æœ‰æ‹¥æœ‰ç›¸åŒå‚æ•°å’Œè¿”å›å€¼çš„å‡½æ•°çš„ç±»å‹ã€‚æœªè¢«åˆå§‹åŒ–çš„å‡½æ•°ç±»å‹å˜é‡çš„å€¼æ˜¯nilã€‚&lt;/p&gt;
&lt;p&gt;åœ¨å‚æ•°åˆ—è¡¨æˆ–è€…è¿”å›åˆ—è¡¨ä¸­ï¼Œåç§°å¿…é¡»éƒ½è¢«æ˜¾ç¤ºçš„å£°æ˜å‡ºæ¥ï¼Œæˆ–è€…éƒ½æ²¡æœ‰å£°æ˜ï¼Œåªå†™ç±»å‹ã€‚å¦‚æœå†™äº†åç§°ï¼Œæ¯ä¸ªåç§°éƒ½æœ‰ç±»å‹å’Œéç©ºçš„åå­—ï¼Œè€Œåå­—å¿…é¡»å”¯ä¸€ã€‚å¦‚æœæ²¡æœ‰å£°æ˜åå­—ï¼Œé‚£å°±åªå†™ç±»å‹ã€‚å‚æ•°å’Œè¿”å›åˆ—è¡¨éœ€è¦ä½¿ç”¨æ‹¬å·åŒ…è£¹ã€‚è¿”å›åˆ—è¡¨åœ¨åªæœ‰ä¸€ä¸ªç±»å‹ä¸”æ²¡æœ‰åå­—æ—¶å¯ä»¥ä¸åŠ æ‹¬å·ã€‚&lt;/p&gt;
&lt;p&gt;æœ€åä¼ å…¥çš„å‚æ•°çš„å‰é¢å¯ä»¥ä½¿ç”¨å¯å˜å‚æ•°ï¼Œå‰ç¼€å¯ä»¥ä½¿ç”¨ä¸‰ä¸ªç‚¹ã€‚è°ƒç”¨æ—¶ï¼Œéœ€è¦ä¼ å…¥0ä¸ªæˆ–ä»¥ä¸Šçš„å‚æ•°ã€‚&lt;/p&gt;
&lt;h2 id=&#34;interface-types-æ¥å£ç±»å‹&#34;&gt;Interface types æ¥å£ç±»å‹
&lt;/h2&gt;&lt;p&gt;An interface type specifies a method set called its interface. A variable of interface type can store a value of any type with a method set that is any superset of the interface. Such a type is said to implement the interface. The value of an uninitialized variable of interface type is nil.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;InterfaceType      = &amp;#34;interface&amp;#34; &amp;#34;{&amp;#34; { MethodSpec &amp;#34;;&amp;#34; } &amp;#34;}&amp;#34; .
MethodSpec         = MethodName Signature | InterfaceTypeName .
MethodName         = identifier .
InterfaceTypeName  = TypeName .
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As with all method sets, in an interface type, each method must have a unique non-blank name.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// A simple File interface
interface {
	Read(b Buffer) bool
	Write(b Buffer) bool
	Close()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;More than one type may implement an interface. For instance, if two types S1 and S2 have the method set&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (p T) Read(b Buffer) bool { return â€¦ }
func (p T) Write(b Buffer) bool { return â€¦ }
func (p T) Close() { â€¦ }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(where T stands for either S1 or S2) then the File interface is implemented by both S1 and S2, regardless of what other methods S1 and S2 may have or share.&lt;/p&gt;
&lt;p&gt;A type implements any interface comprising any subset of its methods and may therefore implement several distinct interfaces. For instance, all types implement the empty interface:&lt;/p&gt;
&lt;p&gt;interface{}
Similarly, consider this interface specification, which appears within a type declaration to define an interface called Locker:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Locker interface {
	Lock()
	Unlock()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If S1 and S2 also implement&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (p T) Lock() { â€¦ }
func (p T) Unlock() { â€¦ }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;they implement the Locker interface as well as the File interface.&lt;/p&gt;
&lt;p&gt;An interface T may use a (possibly qualified) interface type name E in place of a method specification. This is called embedding interface E in T; it adds all (exported and non-exported) methods of E to the interface T.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type ReadWriter interface {
	Read(b Buffer) bool
	Write(b Buffer) bool
}

type File interface {
	ReadWriter  // same as adding the methods of ReadWriter
	Locker      // same as adding the methods of Locker
	Close()
}

type LockedFile interface {
	Locker
	File        // illegal: Lock, Unlock not unique
	Lock()      // illegal: Lock not unique
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;An interface type T may not embed itself or any interface type that embeds T, recursively.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// illegal: Bad cannot embed itself
type Bad interface {
	Bad
}

// illegal: Bad1 cannot embed itself using Bad2
type Bad1 interface {
	Bad2
}
type Bad2 interface {
	Bad1
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;æ¥å£ç±»å‹è¡¨ç¤ºä¸€ä¸ªæ–¹æ³•é›†åˆï¼Œè¯¥æ–¹æ³•é›†åˆå«åšè¯¥ç±»å‹çš„æ¥å£ã€‚æ¥å£ç±»å‹å¯ä»¥å­˜å‚¨ä¸€ä¸ªå˜é‡ï¼Œä»¥åŠè¯¥å˜é‡çš„æ–¹æ³•é›†åˆçš„ä»»ä½•è¶…é›†ã€‚ä¼ å…¥çš„ç±»å‹ä¸å¯¹åº”çš„æ¥å£å«åšè¯¥ç±»å‹çš„å®ç°ã€‚æœªè¢«åˆå§‹åŒ–çš„æ¥å£ç±»å‹å˜é‡çš„å€¼æ˜¯nilã€‚&lt;/p&gt;
&lt;p&gt;å’Œæ–¹æ³•é›†åˆä¸€æ ·ï¼Œæ¥å£ç±»å‹çš„å†…éƒ¨ï¼Œæ¯ä¸ªæ–¹æ³•å¿…é¡»æ²¹å”¯ä¸€éç©ºåå­—ã€‚&lt;/p&gt;
&lt;p&gt;å¦‚æœS1ã€S2ä¸¤ç§ç±»å‹çš„æ–¹æ³•é›†å’Œéƒ½åŒ…å«äº†åŒæ ·çš„æ¥å£å®ç°ï¼Œä¸ç®¡æ–¹æ³•é›†åˆå…¶ä»–çš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼ŒS1å’ŒS2éƒ½è¢«è®¤ä¸ºæ˜¯æ¥å£çš„å®ç°ã€‚&lt;/p&gt;
&lt;p&gt;å¦‚æœä¸€ä¸ªç±»å‹å®ç°äº†ä¸€ä¸ªæ¥å£ï¼Œè¿™ä¸ªæ¥å£çš„å­é›†åˆæ˜¯å…¶ä»–æ¥å£çš„å®ç°ï¼Œé‚£ä¹ˆè¿™ä¸ªç±»å‹ä¹Ÿä¼šå®ç°é‚£äº›æ¥å£ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œæ‰€æœ‰çš„ç±»å‹éƒ½å®ç°äº†ç©ºæ¥å£ã€‚&lt;/p&gt;
&lt;p&gt;æ¥å£ä¸­ä¹Ÿå¯ä»¥å†…åµŒå…¶ä»–æ¥å£ï¼Œä½†æ˜¯å…¶å†…åµŒçš„æ¥å£çš„æ–¹æ³•çš„åå­—ä¸èƒ½å†²çªã€‚&lt;/p&gt;
&lt;h2 id=&#34;map-types-å­—å…¸ç±»å‹&#34;&gt;Map types å­—å…¸ç±»å‹
&lt;/h2&gt;&lt;p&gt;A map is an unordered group of elements of one type, called the element type, indexed by a set of unique keys of another type, called the key type. The value of an uninitialized map is nil.&lt;/p&gt;
&lt;p&gt;MapType     = &amp;ldquo;map&amp;rdquo; &amp;ldquo;[&amp;rdquo; KeyType &amp;ldquo;]&amp;rdquo; ElementType .
KeyType     = Type .
The comparison operators == and != must be fully defined for operands of the key type; thus the key type must not be a function, map, or slice. If the key type is an interface type, these comparison operators must be defined for the dynamic key values; failure will cause a run-time panic.&lt;/p&gt;
&lt;p&gt;map[string]int
map[*T]struct{ x, y float64 }
map[string]interface{}
The number of map elements is called its length. For a map m, it can be discovered using the built-in function len and may change during execution. Elements may be added during execution using assignments and retrieved with index expressions; they may be removed with the delete built-in function.&lt;/p&gt;
&lt;p&gt;A new, empty map value is made using the built-in function make, which takes the map type and an optional capacity hint as arguments:&lt;/p&gt;
&lt;p&gt;make(map[string]int)
make(map[string]int, 100)
The initial capacity does not bound its size: maps grow to accommodate the number of items stored in them, with the exception of nil maps. A nil map is equivalent to an empty map except that no elements may be added.&lt;/p&gt;
&lt;p&gt;å­—å…¸ç±»å‹çš„å†…éƒ¨æ˜¯æ— åºå…ƒç´ æ’åºçš„ç±»å‹ï¼Œå†…éƒ¨çš„ç±»å‹å«å…ƒç´ çš„ç±»å‹ï¼Œä½¿ç”¨å”¯ä¸€é”®å€¼è¿›è¡Œç´¢å¼•ï¼Œé”®å€¼ä¹Ÿæœ‰å¦å¤–ä¸€ç§ç±»å‹ï¼Œå«é”®ç±»å‹ã€‚æœªè¢«åˆå§‹åŒ–çš„å­—å…¸ç±»å‹çš„å€¼æ˜¯nilã€‚&lt;/p&gt;
&lt;p&gt;é”®å€¼ç±»å‹å¿…é¡»å®Œå…¨å®šä¹‰äº†==è¿ç®—å’Œï¼=è¿ç®—ã€‚å› æ­¤å‡½æ•°ã€å­—å…¸ã€åˆ‡ç‰‡éƒ½æ˜¯ä¸å…è®¸ä½œä¸ºé”®å€¼çš„ã€‚å¦‚æœé”®å€¼æ˜¯ä¸€ä¸ªæ¥å£ï¼Œæ¯”è¾ƒæ“ä½œå¿…é¡»è¢«å®šä¹‰ä¸ºå¯ä»¥æ¥å—ä¸€ä¸ªåŠ¨æ€çš„é”®å€¼ã€‚å¯¹é”®å€¼çš„ç›¸å…³æ“ä½œå¤±è´¥æ—¶ä¼šå¼•å‘ç¨‹åºè¿è¡Œæ—¶æƒŠæ…Œã€‚&lt;/p&gt;
&lt;p&gt;å­—å…¸å…ƒç´ çš„æ•°é‡ç§°ä¸ºå­—å…¸çš„é•¿åº¦ã€‚å¯ä»¥é€šè¿‡lenå‡½æ•°æ£€æŸ¥ï¼Œå…¶å€¼åœ¨è¿è¡ŒæœŸé—´å¯èƒ½è¢«æ›´æ”¹ã€‚å…ƒç´ å¯èƒ½é€šè¿‡æŒ‡æ´¾æ“ä½œæ·»åŠ ï¼Œå¯ä»¥é€šè¿‡ä¸‹æ ‡å–å‡ºï¼Œå¯ä»¥é€šè¿‡deleteå‡½æ•°ç§»é™¤ã€‚&lt;/p&gt;
&lt;p&gt;ä¸€ä¸ªç©ºçš„mapçš„å€¼å¯ä»¥é€šè¿‡å†…å»ºå‡½æ•°makeæ¥åˆ›å»ºï¼Œmakeçš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯mapçš„ç±»å‹ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯å®¹é‡ã€‚&lt;/p&gt;
&lt;p&gt;å­—å…¸çš„å®¹é‡ä¸é™åˆ¶å¤§å°ï¼Œå­—å…¸çš„å®¹é‡ä¼šå¢é•¿ä»¥å®¹çº³å…¶ä¸­é¡¹ç›®çš„æ•°é‡ã€‚ä½†nilå­—å…¸ä¸æ˜¯è¿™æ ·çš„ï¼Œnilå­—å…¸åŸºæœ¬ä¸Šå’Œç©ºå­—å…¸æ˜¯ä¸€æ ·çš„ï¼Œé™¤äº†ä¸èƒ½æ·»åŠ ä»»ä½•å…ƒç´ ã€‚&lt;/p&gt;
&lt;h2 id=&#34;channel-types-é€šé“ç±»å‹&#34;&gt;Channel types é€šé“ç±»å‹
&lt;/h2&gt;&lt;p&gt;A channel provides a mechanism for concurrently executing functions to communicate by sending and receiving values of a specified element type. The value of an uninitialized channel is nil.&lt;/p&gt;
&lt;p&gt;ChannelType = ( &amp;ldquo;chan&amp;rdquo; | &amp;ldquo;chan&amp;rdquo; &amp;ldquo;&amp;lt;-&amp;rdquo; | &amp;ldquo;&amp;lt;-&amp;rdquo; &amp;ldquo;chan&amp;rdquo; ) ElementType .
The optional &amp;lt;- operator specifies the channel direction, send or receive. If no direction is given, the channel is bidirectional. A channel may be constrained only to send or only to receive by conversion or assignment.&lt;/p&gt;
&lt;p&gt;chan T          // can be used to send and receive values of type T
chan&amp;lt;- float64  // can only be used to send float64s
&amp;lt;-chan int      // can only be used to receive ints
The &amp;lt;- operator associates with the leftmost chan possible:&lt;/p&gt;
&lt;p&gt;chan&amp;lt;- chan int    // same as chan&amp;lt;- (chan int)
chan&amp;lt;- &amp;lt;-chan int  // same as chan&amp;lt;- (&amp;lt;-chan int)
&amp;lt;-chan &amp;lt;-chan int  // same as &amp;lt;-chan (&amp;lt;-chan int)
chan (&amp;lt;-chan int)
A new, initialized channel value can be made using the built-in function make, which takes the channel type and an optional capacity as arguments:&lt;/p&gt;
&lt;p&gt;make(chan int, 100)
The capacity, in number of elements, sets the size of the buffer in the channel. If the capacity is zero or absent, the channel is unbuffered and communication succeeds only when both a sender and receiver are ready. Otherwise, the channel is buffered and communication succeeds without blocking if the buffer is not full (sends) or not empty (receives). A nil channel is never ready for communication.&lt;/p&gt;
&lt;p&gt;A channel may be closed with the built-in function close. The multi-valued assignment form of the receive operator reports whether a received value was sent before the channel was closed.&lt;/p&gt;
&lt;p&gt;A single channel may be used in send statements, receive operations, and calls to the built-in functions cap and len by any number of goroutines without further synchronization. Channels act as first-in-first-out queues. For example, if one goroutine sends values on a channel and a second goroutine receives them, the values are received in the order sent.&lt;/p&gt;
&lt;p&gt;é€šé“æä¾›äº†å¹¶è¡Œæ‰§è¡Œç¨‹åºä¹‹é—´çš„é€šä¿¡æ–¹å¼ï¼Œè¯¥æ–¹å¼ä½¿ç”¨å‘é€å’Œæ¥å—ç‰¹å®šç±»å‹çš„å€¼æ¥å®ç°ã€‚æœªè¢«åˆå§‹åŒ–çš„é€šé“çš„å€¼æ˜¯nilã€‚&lt;/p&gt;
&lt;p&gt;æ ‡è®°&amp;lt;-ç”¨æ¥æŒ‡ç¤ºé€šé“çš„æ–¹å‘ï¼Œä¾‹å¦‚æ˜¯æ¥å—è¿˜æ˜¯å‘é€ã€‚å¦‚æœä¸æŒ‡å®šæ–¹å‘ï¼Œåˆ™é€šé“ä»æ˜¯åŒå‘çš„ã€‚&lt;/p&gt;
&lt;p&gt;é€šé“çš„&amp;lt;-æ ‡è®°ï¼Œè½¬æ¢æˆ–æŒ‡æ´¾é€šé“çš„æ–¹å‘ï¼Œæˆä¸ºå‘é€æˆ–æ¥æ”¶ã€‚&lt;/p&gt;
&lt;p&gt;é€šé“æ‰€ä¼ é€’çš„å†…å®¹ä¹Ÿå¯ä»¥æ˜¯é€šé“ã€‚&lt;/p&gt;
&lt;p&gt;ä½¿ç”¨makeä¹Ÿå¯ä»¥åˆ›å»ºåˆå§‹åŒ–çš„é€šé“ï¼Œmakeçš„ç¬¬äºŒä¸ªå‚æ•°å¯ä»¥è®¾ç½®é€šé“çš„å®¹é‡ã€‚&lt;/p&gt;
&lt;p&gt;é€šé“çš„å®¹é‡æ˜¯é€šé“ä¸­å…ƒç´ çš„ç¼“å­˜æ•°é‡ã€‚å¦‚æœå®¹é‡æ˜¯0æˆ–è€…ä¸è®¾ç½®ï¼Œé€šé“æ˜¯æ²¡æœ‰ç¼“å­˜çš„ï¼Œåªæœ‰æ¥æ”¶è€…å’Œå‘é€è€…éƒ½å‡†å¤‡å¥½æ—¶æ‰è¿›è¡Œé€šä¿¡ã€‚å¦åˆ™ï¼Œé€šé“åœ¨ç¼“å­˜æ²¡æœ‰æ»¡æ—¶ï¼Œæ˜¯ä¸é˜»å¡çš„ã€‚å¦‚æœé€šé“çš„å€¼æ˜¯0ï¼Œåˆ™æ°¸è¿œæ— æ³•é€šä¿¡ã€‚&lt;/p&gt;
&lt;p&gt;é€šé“ä½¿ç”¨ç³»ç»Ÿè°ƒç”¨closeæ¥å…³é—­ã€‚ä½¿ç”¨å¤šå€¼æ¥å—çš„ç¬¬äºŒä¸ªå‚æ•°æ¥åˆ¤æ–­é€šé“æ˜¯å¦å…³é—­ã€‚&lt;/p&gt;
&lt;p&gt;å•å‘é€šé“ç”¨äºå‘é€è¡¨è¾¾å¼ï¼Œæ¥æ”¶æ“ä½œã€‚capä¸lenä¹Ÿå¯ä»¥è°ƒç”¨ï¼Œå¹¶ä¸”æ— é¡»æ‹…å¿ƒå¤šä¸ªåŒæ­¥çš„åç¨‹åŒæ—¶è¿è¡Œã€‚é€šé“æ˜¯å…ˆå…¥å…ˆå‡ºçš„ï¼Œå¦‚æœç¬¬ä¸€ä¸ªåæˆæ”¾å…¥äº†ä¸€ä¸ªå€¼ï¼Œç¬¬äºŒä¸ªåæˆå–å‡ºçš„ä¸€å®šæ˜¯å…ˆæ”¾å…¥çš„å€¼ã€‚&lt;/p&gt;
</description>
        </item>
        <item>
        <title>2018-09-20 Goå­¦ä¹ æ‹¾è´</title>
        <link>https://nansenli.com/zh-cn/post/jianshu/go/2018-09-20-go%E5%AD%A6%E4%B9%A0%E6%8B%BE%E8%B4%9D/</link>
        <pubDate>Wed, 07 Nov 2018 06:54:00 +0000</pubDate>
        
        <guid>https://nansenli.com/zh-cn/post/jianshu/go/2018-09-20-go%E5%AD%A6%E4%B9%A0%E6%8B%BE%E8%B4%9D/</guid>
        <description>&lt;h2 id=&#34;goçš„æŒ‡é’ˆä¸å€¼åœ¨ä½œä¸ºæ¥å—è€…å’Œå‚æ•°æ—¶çš„è¡¨ç°ä¸åŒ&#34;&gt;Goçš„æŒ‡é’ˆä¸å€¼åœ¨ä½œä¸ºæ¥å—è€…å’Œå‚æ•°æ—¶çš„è¡¨ç°ä¸åŒ
&lt;/h2&gt;&lt;p&gt;æ–¹æ³•ä¸æŒ‡é’ˆé‡å®šå‘
æ¯”è¾ƒå‰ä¸¤ä¸ªç¨‹åºï¼Œä½ å¤§æ¦‚ä¼šæ³¨æ„åˆ°å¸¦æŒ‡é’ˆå‚æ•°çš„å‡½æ•°å¿…é¡»æ¥å—ä¸€ä¸ªæŒ‡é’ˆï¼š&lt;/p&gt;
&lt;p&gt;var v Vertex
ScaleFunc(v, 5)  // ç¼–è¯‘é”™è¯¯ï¼
ScaleFunc(&amp;amp;v, 5) // OK
è€Œä»¥æŒ‡é’ˆä¸ºæ¥æ”¶è€…çš„æ–¹æ³•è¢«è°ƒç”¨æ—¶ï¼Œæ¥æ”¶è€…æ—¢èƒ½ä¸ºå€¼åˆèƒ½ä¸ºæŒ‡é’ˆï¼š&lt;/p&gt;
&lt;p&gt;var v Vertex
v.Scale(5)  // OK
p := &amp;amp;v
p.Scale(10) // OK
å¯¹äºè¯­å¥ v.Scale(5)ï¼Œå³ä¾¿ v æ˜¯ä¸ªå€¼è€ŒéæŒ‡é’ˆï¼Œå¸¦æŒ‡é’ˆæ¥æ”¶è€…çš„æ–¹æ³•ä¹Ÿèƒ½è¢«ç›´æ¥è°ƒç”¨ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œç”±äº Scale æ–¹æ³•æœ‰ä¸€ä¸ªæŒ‡é’ˆæ¥æ”¶è€…ï¼Œä¸ºæ–¹ä¾¿èµ·è§ï¼ŒGo ä¼šå°†è¯­å¥ v.Scale(5) è§£é‡Šä¸º (&amp;amp;v).Scale(5)ã€‚&lt;/p&gt;
&lt;p&gt;å¦å¤–ï¼ŒGoä¼šå°†æŒ‡é’ˆçš„.è¿ç®—è‡ªåŠ¨è§£é‡Šä¸º(*).&lt;/p&gt;
</description>
        </item>
        <item>
        <title>2018-08-30 Goå­¦ä¹ æ‹¾è´</title>
        <link>https://nansenli.com/zh-cn/post/jianshu/go/2018-08-30-go%E5%AD%A6%E4%B9%A0%E6%8B%BE%E8%B4%9D/</link>
        <pubDate>Sat, 01 Sep 2018 13:40:00 +0000</pubDate>
        
        <guid>https://nansenli.com/zh-cn/post/jianshu/go/2018-08-30-go%E5%AD%A6%E4%B9%A0%E6%8B%BE%E8%B4%9D/</guid>
        <description>&lt;ul&gt;
&lt;li&gt;åœ¨å‡½æ•°ä¸­ï¼Œç®€æ´èµ‹å€¼è¯­å¥ := å¯åœ¨ç±»å‹æ˜ç¡®çš„åœ°æ–¹ä»£æ›¿ var å£°æ˜ã€‚ä½†æ˜¯å¸¸é‡å¿…é¡»ä½¿ç”¨constæ¥å£°æ˜&lt;/li&gt;
&lt;li&gt;å‡½æ•°å¤–çš„æ¯ä¸ªè¯­å¥éƒ½å¿…é¡»ä»¥å…³é”®å­—å¼€å§‹ï¼ˆvar, func ç­‰ç­‰ï¼‰ï¼Œå› æ­¤ := ç»“æ„ä¸èƒ½åœ¨å‡½æ•°å¤–ä½¿ç”¨ã€‚&lt;/li&gt;
&lt;li&gt;ä¸ºä»€ä¹ˆGoä½¿ç”¨åç½®ç±»å‹ç”Ÿå‘½ &lt;a class=&#34;link&#34; href=&#34;https://blog.go-zh.org/gos-declaration-syntax&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.go-zh.org/gos-declaration-syntax&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Goçš„ç±»å‹æœ‰å¦‚ä¸‹ï¼š&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // uint8 çš„åˆ«å

rune // int32 çš„åˆ«å
    // è¡¨ç¤ºä¸€ä¸ª Unicode ç ç‚¹

float32 float64

complex64 complex128
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;å½“ä½ éœ€è¦ä¸€ä¸ªæ•´æ•°å€¼æ—¶åº”ä½¿ç”¨ int ç±»å‹ï¼Œé™¤éä½ æœ‰ç‰¹æ®Šçš„ç†ç”±ä½¿ç”¨å›ºå®šå¤§å°æˆ–æ— ç¬¦å·çš„æ•´æ•°ç±»å‹ã€‚&lt;/li&gt;
&lt;li&gt;Goä¸å­˜åœ¨éšå¼è½¬æ¢&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
