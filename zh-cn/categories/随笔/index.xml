<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>随笔 on Nansen Li&#39;s Blog
李楠森的博客
</title>
        <link>https://nansenli.com/zh-cn/categories/%E9%9A%8F%E7%AC%94/</link>
        <description>Recent content in 随笔 on Nansen Li&#39;s Blog
李楠森的博客
</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>Nansen Li 🌈 （李楠森）</copyright>
        <lastBuildDate>Wed, 24 Oct 2018 11:47:00 +0000</lastBuildDate><atom:link href="https://nansenli.com/zh-cn/categories/%E9%9A%8F%E7%AC%94/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>关于 Windows 10 使用 SSD 每隔一段时间卡顿问题的探究与解决</title>
        <link>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/%E5%85%B3%E4%BA%8E-windows-10-%E4%BD%BF%E7%94%A8-ssd-%E6%AF%8F%E9%9A%94%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98%E7%9A%84%E6%8E%A2%E7%A9%B6%E4%B8%8E%E8%A7%A3%E5%86%B3/</link>
        <pubDate>Wed, 24 Oct 2018 11:47:00 +0000</pubDate>
        
        <guid>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/%E5%85%B3%E4%BA%8E-windows-10-%E4%BD%BF%E7%94%A8-ssd-%E6%AF%8F%E9%9A%94%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98%E7%9A%84%E6%8E%A2%E7%A9%B6%E4%B8%8E%E8%A7%A3%E5%86%B3/</guid>
        <description>&lt;h2 id=&#34;前言&#34;&gt;前言
&lt;/h2&gt;&lt;p&gt;本来是使用 Intel 的 i5-6500 CPU，在更换为 AMD 的 Ryzen 2700 后，频繁出现卡机现象。&lt;/p&gt;
&lt;h2 id=&#34;现象&#34;&gt;现象
&lt;/h2&gt;&lt;p&gt;在卡机时，观测到任务管理器的硬盘占用率为100%，同时写入与写出量为0。硬盘位光威 悍将 512 GB杂牌。在事件管理器中有大量编号为129的事件。&lt;/p&gt;
&lt;h2 id=&#34;怀疑硬件问题&#34;&gt;怀疑硬件问题
&lt;/h2&gt;&lt;p&gt;在重复更换了SATA接口，重复拔插了电源，尝试无效，仍然卡机&lt;/p&gt;
&lt;h2 id=&#34;网上搜索相关问题&#34;&gt;网上搜索相关问题
&lt;/h2&gt;&lt;p&gt;在网上搜索到，大部分都指向了问题的根源，是WIN10的AHCI驱动问题，以及SSD固件的问题。&lt;/p&gt;
&lt;h2 id=&#34;解决途径一-更换ahci驱动-无效&#34;&gt;解决途径一 更换AHCI驱动 无效
&lt;/h2&gt;&lt;p&gt;为了更换AHCI驱动，尝试在AMD官网，在华硕官网下载了芯片组驱动，并手动在设备管理器中更换了驱动，使得显示为AMD SATA驱动。后又反复试过各种主板驱动，最终，测试无效，不能解决问题&lt;/p&gt;
&lt;h2 id=&#34;解决途径二-更换硬盘为raid格式-无效&#34;&gt;解决途径二 更换硬盘为raid格式 无效
&lt;/h2&gt;&lt;p&gt;为了更换raid格式，重新安装Windows，但是在安装过程中，Windows无法识别ssd。根据amd官方英文手册，以及官方raid驱动，手动载入raid驱动，仍然在Windows安装过程中无法看到ssd。重复多次无法看到。可能是因为只有一块硬盘，使用volume模式的raid不被支持吧。放弃该方式&lt;/p&gt;
&lt;h2 id=&#34;解决途径三-更改注册表关闭msi-无效&#34;&gt;解决途径三 更改注册表，关闭MSI 无效
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.pconline.com.cn/win10/739/7395324.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.pconline.com.cn/win10/739/7395324.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;大意就是在某些AHCI模式下使用StorAHCI.sys驱动时，可能导致个别SSD无法在“信息信号中断”（MSI）模式下完成正确的输入/输出操作，最终表现就是系统停滞，同时任务管理器中磁盘占用率显示为100%。当然解决的方法也简单，直接在regedit里关闭它（MSI Mode）就成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;　　4. 点击Contana，输入“regedit”启动注册表编辑器，导航到“HKEY_LOCAL_MACHINE\System\CurrentControlSet\Enum\PCI\xxxxx \Device Parameters\Interrupt Management\MessageSignaledInterruptProperties”（”xxxxx”是你刚刚记录的“设备实例路径”）；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;　　5. 最后更改右窗格中的“MSISupported”键值，由1改为0；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过测试无效&lt;/p&gt;
&lt;h2 id=&#34;解决途径四--更改电源设置-无效&#34;&gt;解决途径四  更改电源设置 无效
&lt;/h2&gt;&lt;p&gt;PCIE-Express中的设置置为关闭，测试无效&lt;/p&gt;
&lt;h2 id=&#34;解决途径五-更改lpm-有用&#34;&gt;解决途径五 更改LPM 有用
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.sohu.com/a/204645459_493865&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.sohu.com/a/204645459_493865&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://answers.microsoft.com/en-us/windows/forum/windows_10-hardware-winpc/event-id-129-storahci-resetting-raidport0/7b30c512-6597-438b-80cb-22fb2f85d62e&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://answers.microsoft.com/en-us/windows/forum/windows_10-hardware-winpc/event-id-129-storahci-resetting-raidport0/7b30c512-6597-438b-80cb-22fb2f85d62e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其内容如下：&lt;/p&gt;
&lt;p&gt;我们现在用的大多数SSD都支持一些省电的功能，DIPM/HIPM/Device Sleep。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/4388248-c66b7d6caad481df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;由主机 （Host）发出改变形态请求的我们叫做HIPM(Host-Initiated LPM, HIPM)，而直接由设备(Device)发出形态请求的叫(Device-Initiated LPM,DIPM)。请求什么，请求变慢，请求节能，请求Device Sleep。&lt;/p&gt;
&lt;p&gt;而HIPM，DIPM都离不开电脑LPM技术的支持。LPM，Link Power Management (LPM)，链接电源管理。LPM是SATA接口物理层上的一个功能，它能够将主机（Host）和存储设备（Device）的链接分成3种形态：Active形态，Partial形态和Slumber形态，目的是降低物理层总线传输速度，这样达到省电效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/4388248-e27d2b1539c83ea5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;LPM一般是默认打开的。&lt;/p&gt;
&lt;p&gt;那么打开这个LPM对于SSD好么？&lt;/p&gt;
&lt;p&gt;1. 主机发送HIPM形态改变指令，而SSD设备标准不同，不能很好的支持，出现兼容问题导致卡顿，或者掉盘；&lt;/p&gt;
&lt;p&gt;2. 主机发送HIPM形态改变指令太频繁，导致SSD设备不能及时反应，出现卡顿。&lt;/p&gt;
&lt;p&gt;3. LPM开启后造成SATA总线传输延迟增加，导致高速SSD的传输受到阻塞而卡顿；&lt;/p&gt;
&lt;p&gt;4. SSD内部的DIPM和主机请求的HIPM发生冲突导致卡顿。&lt;/p&gt;
&lt;p&gt;很多时候，SSD导致电脑出现卡顿，突然掉盘，都是LPM引起的。&lt;/p&gt;
&lt;p&gt;LPM是能够让SATA设备到达节能的效果。但是，也同样对SSD性能产生了影响。&lt;/p&gt;
&lt;p&gt;那么为了节能，你愿意付出损失SSD性能的代价吗？&lt;/p&gt;
&lt;p&gt;HDD的功耗大概在10-25W。也许LPM曾经仅仅是为HDD而来的。&lt;/p&gt;
&lt;p&gt;SSD启动功耗：0.1W&lt;del&gt;1W（2W），最高功耗：5&lt;/del&gt;10W，平均功耗：4~5W左右。&lt;/p&gt;
&lt;p&gt;我们的电源缺SSD这几W么？我们在乎这点电费么？好意思在乎么！&lt;/p&gt;
&lt;p&gt;既然SSD用不着LPM，这样损害SSD性能的节能功能，那么我们可不可以给它关掉呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/4388248-203ee8f11de7a542.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;保存为“.reg”格式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/4388248-c01d0e2b7805b56d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;点击运行。自动写入注册表，更改LPM电源设置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/4388248-d3bd755ea853343f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/4388248-e7f9dba012dfc070.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;如果你的SSD出现严重卡顿，掉盘等现象，你可以试试这个方法。&lt;/p&gt;
&lt;p&gt;SSD卡顿、掉盘的主要原因还是，SSD太差劲。确实，在SSD价格不断上涨的今天，要想花较少的钱买到好的SSD是非常难的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经过测试，有效&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;解决途径六-更改bios设置开启sata热拔插功能-推荐&#34;&gt;解决途径六 更改BIOS设置，开启sata热拔插功能 推荐
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.aiweibk.com/5795.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.aiweibk.com/5795.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在主板BIOS设置中开启Hot Plug热插拔属性之后还会带来一个副作用，那就是固态硬盘的LPM节能将会随热插拔的开启而关闭，从而避免热插拔时数据丢失或重新连接时失去响应。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你的固态硬盘与主板搭配存在兼容性问题而有间歇性的卡顿现象，不妨在主板BIOS设置当中开启Hot Plug选项来禁用LPM节能，或许就能解决故障。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;经测试，有效&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结
&lt;/h2&gt;&lt;p&gt;为什么之前用Intel就没问题用了AMD就有问题，我猜测是因为原来的Intel主板比较差，不支持SATA LPM，然后win10默认是开启了LPM，但是SSD因为杂牌，所以支持不好，虽然固件支持LPM，但是会出现严重问题。由于主板不支持LPM，就算Windows开启了LPM，问题也显现不出来。&lt;/p&gt;
&lt;p&gt;现在换了新的主板，支持LPM，在默认情况下，与SSD出现兼容问题。需要手动关闭LPM功能。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>2018-09-15 网易互娱面试</title>
        <link>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/2018-09-15-%E7%BD%91%E6%98%93%E4%BA%92%E5%A8%B1%E9%9D%A2%E8%AF%95/</link>
        <pubDate>Sat, 15 Sep 2018 15:59:00 +0000</pubDate>
        
        <guid>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/2018-09-15-%E7%BD%91%E6%98%93%E4%BA%92%E5%A8%B1%E9%9D%A2%E8%AF%95/</guid>
        <description>&lt;p&gt;于成都一酒店面试
有想到的再更新&lt;/p&gt;
&lt;h2 id=&#34;笔试&#34;&gt;笔试
&lt;/h2&gt;&lt;p&gt;使用开放地址法实现hashmap，key是int，value是string，时间30分钟&lt;/p&gt;
&lt;h2 id=&#34;一面&#34;&gt;一面
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;volatile 作用 原理&lt;/li&gt;
&lt;li&gt;dynamic_cast static_cast 区别&lt;/li&gt;
&lt;li&gt;dynamic_cast父子类转换合法问题&lt;/li&gt;
&lt;li&gt;虚析构函数 虚表&lt;/li&gt;
&lt;li&gt;RTTI type_info&lt;/li&gt;
&lt;li&gt;结构体 sizeof&lt;/li&gt;
&lt;li&gt;红黑树特点；大约12个数字，求该序列一个可能的红黑树结果，画出来&lt;/li&gt;
&lt;li&gt;服务器建立listen的api调用过程，非阻塞epoll如何实现&lt;/li&gt;
&lt;li&gt;epoll原理，边缘触发水平触发业务代码的逻辑区别在哪&lt;/li&gt;
&lt;li&gt;tcp粘包&lt;/li&gt;
&lt;li&gt;扔两个鸡蛋，100层楼，求鸡蛋硬度，动态规划求解方法&lt;/li&gt;
&lt;li&gt;10亿个玩家，每个人都有个分数，分数范围是0~10w，求一个人的排名是多少&lt;/li&gt;
&lt;li&gt;redis跳跃表&lt;/li&gt;
&lt;li&gt;内存栅栏在汇编中是如何实现的&lt;/li&gt;
&lt;li&gt;void func()函数对应的汇编程序刚开始都要做两件事，是什么&lt;/li&gt;
&lt;li&gt;如果程序出现了内存泄漏，如何判断内存是如何泄露&lt;/li&gt;
&lt;li&gt;如何在main函数之前打印一些东西。main函数之前还会执行哪些程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二面&#34;&gt;二面
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;python is == 区别 id函数&lt;/li&gt;
&lt;li&gt;python xrange range 区别&lt;/li&gt;
&lt;li&gt;Python iterator&lt;/li&gt;
&lt;li&gt;redis ziplist&lt;/li&gt;
&lt;li&gt;redis ttl过期实现&lt;/li&gt;
&lt;li&gt;stl deque实现（我回答list，不对。遂问你如果要实现一个deque，你怎么实现）&lt;/li&gt;
&lt;li&gt;shell中运行一个程序，到程序输出hello world，中间发生了什么，细节&lt;/li&gt;
&lt;li&gt;Linux程序典型内存布局画出来&lt;/li&gt;
&lt;li&gt;不同线程之间可以访问对方的栈空间吗&lt;/li&gt;
&lt;li&gt;一个长为x，宽为y的矩阵，四个角有洞，一个台球从某点出发，不考虑摩擦力无限运动下去，求他会进入到哪个洞里面&lt;/li&gt;
&lt;li&gt;lambda表达式[]可以填什么，你觉得编译器是如何实现lambda表达式的&lt;/li&gt;
&lt;li&gt;什么是右值（这里我把右值和右值引用搞混了）&lt;/li&gt;
&lt;li&gt;malloc实现过程，malloc一定会调用brk调整堆边界吗。介绍buddy&lt;/li&gt;
&lt;li&gt;https 客户端和服务器是如何实现协议选择的，现在常用的协议是什么&lt;/li&gt;
&lt;li&gt;https 客户端鉴定服务器的过程&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>2018-08-29 腾讯天美电话面试</title>
        <link>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/2018-08-29-%E8%85%BE%E8%AE%AF%E5%A4%A9%E7%BE%8E%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95/</link>
        <pubDate>Wed, 29 Aug 2018 04:32:00 +0000</pubDate>
        
        <guid>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/2018-08-29-%E8%85%BE%E8%AE%AF%E5%A4%A9%E7%BE%8E%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95/</guid>
        <description>&lt;ul&gt;
&lt;li&gt;三次握手四次挥手&lt;/li&gt;
&lt;li&gt;nagle算法&lt;/li&gt;
&lt;li&gt;tcp断开链接一方会进入到哪几个状态&lt;/li&gt;
&lt;li&gt;多进程多线程如何选择，考虑业务&lt;/li&gt;
&lt;li&gt;mysql master slave 集群 了解多少&lt;/li&gt;
&lt;li&gt;多进程下gdb调试流程&lt;/li&gt;
&lt;li&gt;网络框架libevent等介绍&lt;/li&gt;
&lt;li&gt;select 和epoll区别。java为什么connect用select不用epoll&lt;/li&gt;
&lt;li&gt;进程间通信方式&lt;/li&gt;
&lt;li&gt;锁的了解。无锁数据结构实现&lt;/li&gt;
&lt;li&gt;共享内存互斥如何设计&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>SVN学习笔记</title>
        <link>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/svn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Sun, 01 Jul 2018 15:01:00 +0000</pubDate>
        
        <guid>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/svn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;h2 id=&#34;前言&#34;&gt;前言
&lt;/h2&gt;&lt;p&gt;为了工作内容学习SVN。SVN是一个C/S类型的版本管理，对服务器依赖很大，大部分操作是和SVN服务器有关的。&lt;/p&gt;
&lt;h2 id=&#34;最常见的操作流程&#34;&gt;最常见的操作流程
&lt;/h2&gt;&lt;p&gt;这里假设服务器项目的地址是svn://192.168.1.1/shop&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过checkout检出项目&lt;/li&gt;
&lt;li&gt;update 更新服务器的项目到本地&lt;/li&gt;
&lt;li&gt;commit 提交本地的更改&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;如何部署一个svn服务器&#34;&gt;如何部署一个svn服务器
&lt;/h2&gt;&lt;p&gt;因为这个svn是一个c/s类型的软件，得部署服务器才能够使用。所以得先弄个服务器出来供我们测试。
为了尽可能简单，这里在Windows下面安装一个visualsvn的软件来当作我们的服务器。注意一般服务器是运行在Linux的，这里只是为了上手方便才使用Windows的服务器软件。在官网很容易就能下载到visualsvn server的软件。我下了个3.9的版本。用就用最新稳定版。中间有一步选标准版，其他的按照默认来就可以了。其中有一个端口号的选择，注意一下不要和本机的端口冲突了。默认端口是443，你可以改成8443。&lt;/p&gt;
&lt;h2 id=&#34;在服务器端创建一个测试项目&#34;&gt;在服务器端创建一个测试项目
&lt;/h2&gt;&lt;p&gt;因为svn项目就是仓库，就是一个文件夹。我们需要建立一个文件夹。打开D:\Repositories文件夹，在该目录下面运行命令svnadmin create test1，这样就建立了一个项目。为了其他用户能够访问该目录，需要使用svnserve命令启动服务器，这个稍后再说。这里还需要配置权限设置。打开test1目录下面的conf目录svnserve.conf，将其中的anon-access 的注释去掉，将值改为write。此时允许匿名访问，并可写&lt;/p&gt;
&lt;p&gt;然后在D:\Repositories目录下运行命令：
&lt;code&gt;svnserve -d -r ./test1&lt;/code&gt;
这一步是打开svn服务器的监听状态。&lt;/p&gt;
&lt;h2 id=&#34;svn客户端常用操作&#34;&gt;svn客户端常用操作
&lt;/h2&gt;&lt;p&gt;下载TortoiseSVN进行安装。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;checkout 检出
然后，在需要同步的目录下面单机右键，选择tortoise中的rebo-bowser，并输入svn://127.0.0.1确认。在文件夹图标上右键选择checkout并确认，此时检出成功。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;commit
添加一个txt文件，随便写点东西。然后右键commit。即可commit到服务器端。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;update
A开发者将提交的数据提交后，服务器发生了变化，B开发者需要同步。右键update即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ignore
不需要提交文件时，在文件上面右键然后选择add to ignore list中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;svn版本&#34;&gt;SVN版本
&lt;/h2&gt;&lt;p&gt;svn版本从1开始递增。svn可以会退版本。svn可以进行分支和合并操作，但是和git中的分支操作区别很大。似乎是重新创建了一个项目这样的。最后合并也是只是把冲突合并了。和git基于diff进行分支不同。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>GoogleProtocolBuffer了解</title>
        <link>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/google-protocol-buffer-%E4%BA%86%E8%A7%A3/</link>
        <pubDate>Fri, 18 May 2018 11:10:00 +0000</pubDate>
        
        <guid>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/google-protocol-buffer-%E4%BA%86%E8%A7%A3/</guid>
        <description>&lt;h2 id=&#34;前言&#34;&gt;前言
&lt;/h2&gt;&lt;p&gt;睡前学习一下Google protocol buffer&lt;/p&gt;
&lt;h2 id=&#34;安装protobuf编译器&#34;&gt;安装protobuf编译器
&lt;/h2&gt;&lt;p&gt;启动最新版的ubuntu docker镜像，运行apt install protobuf-compiler&lt;/p&gt;
&lt;h2 id=&#34;书写-proto-文件&#34;&gt;书写 .proto 文件
&lt;/h2&gt;&lt;p&gt;nano lm.helloworld.proto&lt;/p&gt;
&lt;p&gt;然后输入&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; lm; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;helloworld&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;{ &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;required&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int32&lt;/span&gt;     id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;// ID 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;required&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;    str &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;// str 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int32&lt;/span&gt;     opt &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;//optional field 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在上例中，package 名字叫做 lm，定义了一个消息 helloworld，该消息有三个成员，类型为 int32 的 id，另一个为类型为 string 的成员 str。opt 是一个可选的成员，即消息中可以不包含该成员。&lt;/p&gt;
&lt;h2 id=&#34;编译proto文件&#34;&gt;编译proto文件
&lt;/h2&gt;</description>
        </item>
        <item>
        <title>2018-05-11 随笔</title>
        <link>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/2018-05-11-%E9%9A%8F%E7%AC%94/</link>
        <pubDate>Fri, 11 May 2018 09:50:00 +0000</pubDate>
        
        <guid>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/2018-05-11-%E9%9A%8F%E7%AC%94/</guid>
        <description>&lt;p&gt;开始准备写ss助手的服务器端。有很多问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;语言
如果将来要从事C++后台开发，最好还是使用C++比较好。但是也想使用一下其他的方案，比如Python。Python试了一下webpy非常的轻量，估计不会再使用之前的flask框架了。另外一个就是Go。Go的语法也是个问题，还没有学习。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;框架
暂时看到了C++的handy。不是特别想用muduo库。还是不想使用boost，虽然effective c++上面说了要学习boost。handy第一印象感觉很好。还在学习中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目标是先用handy写一个静态的服务器。之后再扩展。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>腾讯校招随笔</title>
        <link>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/%E8%85%BE%E8%AE%AF%E6%A0%A1%E6%8B%9B%E9%9A%8F%E7%AC%94/</link>
        <pubDate>Wed, 11 Apr 2018 08:39:00 +0000</pubDate>
        
        <guid>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/%E8%85%BE%E8%AE%AF%E6%A0%A1%E6%8B%9B%E9%9A%8F%E7%AC%94/</guid>
        <description>&lt;h2 id=&#34;前言&#34;&gt;前言
&lt;/h2&gt;&lt;p&gt;提前批有两次电话一面，这里略过了。
首发于：https://www.jianshu.com/p/d5aa63a27172&lt;/p&gt;
&lt;h2 id=&#34;一面&#34;&gt;一面
&lt;/h2&gt;&lt;p&gt;成都4月11日&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍自己的项目、难点在哪里、怎么解决的&lt;/li&gt;
&lt;li&gt;介绍C++11特性&lt;/li&gt;
&lt;li&gt;介绍fork函数&lt;/li&gt;
&lt;li&gt;介绍time_wait状态&lt;/li&gt;
&lt;li&gt;为什么tcp连接握手需要三次&lt;/li&gt;
&lt;li&gt;介绍迭代器失效。push_back会导致迭代器失效吗。&lt;/li&gt;
&lt;li&gt;红黑树的特征，介绍&lt;/li&gt;
&lt;li&gt;哈希冲突的解决方法。&lt;/li&gt;
&lt;li&gt;进程和线程的区别&lt;/li&gt;
&lt;li&gt;你都使用什么线程模型&lt;/li&gt;
&lt;li&gt;介绍协程&lt;/li&gt;
&lt;li&gt;介绍快排算法&lt;/li&gt;
&lt;li&gt;什么是稳定性排序，快排是稳定性的吗，为什么&lt;/li&gt;
&lt;li&gt;快排算法最差情况推导公式&lt;/li&gt;
&lt;li&gt;析构函数虚函数为什么&lt;/li&gt;
&lt;li&gt;构造函数为什么不能是虚函数&lt;/li&gt;
&lt;li&gt;打印在纸上的题目，考察：new [] 对象。static 成员。子类构造函数具体调用了啥。拷贝构造函数与赋值函数的区别。等号在拷贝构造函数出现的时机。什么时候需要赋值函数。深拷贝与浅拷贝。虚函数的调用时机。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是其中一道题目，请写出运行结果&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

struct A{
    A(){
        local_var++;
    }
    virtual void func(){
        cout &amp;lt;&amp;lt; &amp;#34;A&amp;#34; &amp;lt;&amp;lt; endl;
    }
    static int local_var;
};

int A::local_var = 0;

struct B : A{
    B(){
        local_var+=2;
    }
    virtual void func(){
        cout &amp;lt;&amp;lt; &amp;#34;B&amp;#34; &amp;lt;&amp;lt; endl;
    }
};

int main(){
    A* a1 = new B[3]; 
    cout &amp;lt;&amp;lt; a1[0].local_var &amp;lt;&amp;lt; endl;
    a1-&amp;gt;func();
    A a2 = a1[0];
    cout &amp;lt;&amp;lt; a2.local_var &amp;lt;&amp;lt; endl;
    a2.func();
    A a3;
    a3 = a1[0];
    cout &amp;lt;&amp;lt; a3.local_var &amp;lt;&amp;lt; endl;
    a3.func();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以下代码会出现什么问题。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

struct A{
    virtual void func1(){
        cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl;
    }
    void func2(){
        cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl;
    }
    void func3(){
        cout &amp;lt;&amp;lt; &amp;#34;a&amp;#34; &amp;lt;&amp;lt; endl;
    }
    int a;
};

int main(){
    A * a = (A*)malloc(sizeof(A));
    a-&amp;gt;func1();
    a-&amp;gt;func2();
    a-&amp;gt;func3();
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;笔试过程中（之前牛客笔试。面试官居然打印了我的笔试所有答案和结果，包括选择题和算法题，提交了多少次，失败了多少次）一道题的思路。考察虚指针的初始化时机。&lt;/li&gt;
&lt;li&gt;随机出一道纸上的题目。给定前序遍历ABC后序遍历CBA，求中序遍历是什么，画出来两种情况。&lt;/li&gt;
&lt;li&gt;笔试过程中（之前牛客笔试），第一道算法题的思路&lt;/li&gt;
&lt;li&gt;有100个弹珠，双方轮流拿，每个人只能拿1~5个，无法拿的人输，必胜解法。&lt;/li&gt;
&lt;li&gt;最近学什么（服务器编程）。之前学什么（TensorFlow），怎么学习的。你对Tensorflow强大的神经网络是怎么看待的。&lt;/li&gt;
&lt;li&gt;家庭情况了解。&lt;/li&gt;
&lt;li&gt;离开后在大厅手写代码，求char a数组中有的元素和char b数组中没有的元素，放到char c数组。这里我忘记把char字符转成unsigned char类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二面&#34;&gt;二面
&lt;/h2&gt;&lt;p&gt;成都4月13日&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自我介绍&lt;/li&gt;
&lt;li&gt;系统调用是什么。你用过哪些系统调用。什么系统调用会耗时长。&lt;/li&gt;
&lt;li&gt;gdb调试用过吗。什么是条件断点。&lt;/li&gt;
&lt;li&gt;函数指针和指针函数的区别。写个例子出来。&lt;/li&gt;
&lt;li&gt;手写fork调用示例。你在哪些场合使用过fork调用。&lt;/li&gt;
&lt;li&gt;介绍udp的connect函数。&lt;/li&gt;
&lt;li&gt;索引是什么。多加索引一定会好吗？（索引这个承认了看面经，但是后一个问题自己想出来了）&lt;/li&gt;
&lt;li&gt;上一次面试中，你有哪些问题你回去查了。&lt;/li&gt;
&lt;li&gt;上一次面试中，你的代码有问题，你知道吗。&lt;/li&gt;
&lt;li&gt;你回答的问题是从哪里学习的。你这两天在干什么？&lt;/li&gt;
&lt;li&gt;给你提一些建议，看下gdb调试，看下数据库知识，看下网络编程，多实践。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;后续&#34;&gt;后续
&lt;/h2&gt;&lt;p&gt;4月20日收到腾讯的电话offer确认。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>腾讯内推随笔</title>
        <link>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/%E8%85%BE%E8%AE%AF%E5%86%85%E6%8E%A8%E9%9A%8F%E7%AC%94/</link>
        <pubDate>Mon, 26 Mar 2018 12:23:00 +0000</pubDate>
        
        <guid>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/%E8%85%BE%E8%AE%AF%E5%86%85%E6%8E%A8%E9%9A%8F%E7%AC%94/</guid>
        <description>&lt;p&gt;今天下午在刷牛客。忽然想看看腾讯的内推进展如何，微信公众号结果显示，目前的岗位可能并不适合你。&lt;/p&gt;
&lt;p&gt;并没有什么特殊的感想。&lt;/p&gt;
&lt;p&gt;还需要努力，争取一个好的结果吧。无论如何，还是有机会的。&lt;/p&gt;
&lt;p&gt;下午刷题，网易的8道题目有3道不会做，感觉确实有很多要学习的点。&lt;/p&gt;
&lt;p&gt;买了一堆书，不知道什么时候才能看完。&lt;/p&gt;
&lt;p&gt;总之还是要乐观一点。&lt;/p&gt;
&lt;p&gt;面试官说我挺适合的，虽然那是可能还是挺开心的，但是我不会因为我被抛弃了而伤心，也不会因为我被选择了而骄傲。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>我的第一个程序</title>
        <link>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/</link>
        <pubDate>Wed, 21 Mar 2018 08:06:00 +0000</pubDate>
        
        <guid>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/</guid>
        <description>&lt;h2 id=&#34;前言&#34;&gt;前言
&lt;/h2&gt;&lt;p&gt;留白&lt;/p&gt;
&lt;h2 id=&#34;尝试&#34;&gt;尝试
&lt;/h2&gt;&lt;p&gt;在大一的时候，我记得当时参加了一个学院的比赛，这是我第一次接触到有关编程的概念。&lt;/p&gt;
&lt;p&gt;这个比赛是通过该实验室提供的带有编程功能的积木与玩具，搭建出一个作品。有点类似于米兔机器人一样的概念，只不过当时时间比较早而已。&lt;/p&gt;
&lt;p&gt;我搭建了一个智能的小车，它能够按照地面上的黑色胶带的轨迹来行动，然后做出相应的动作。他拥有以下三个功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按照地面上的单线胶带行动。该功能是通过两个红外传感器实现的。&lt;/li&gt;
&lt;li&gt;遇到障碍可以按照事先约定好的动作绕过障碍。通过一个红外传感器实现。&lt;/li&gt;
&lt;li&gt;可以用爪子抓取地面上的乒乓球。通过一个电机带动行动。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我记得当时的编程界面是通过一个图形界面操作的，这个程序中可以拖动不同的矩形，代表程序体。然后用连线来表示状态的转移。编写好代码，需要通过红外线装置传输到可编程积木中。红外线的传输装置有点像立起来的熨斗，积木很大一块，可以安装锂电池，上面有一些齿轮状的物体，可以将其他的轮胎或者是滑动装置安装上去。这样整个装置就可以按照你的期望运动了。&lt;/p&gt;
&lt;p&gt;我记得当时评比的时候，除了我自己的作品外，没有一个队伍的作品能够动起来（就是没有写程序）。&lt;/p&gt;
&lt;p&gt;其他队伍在介绍自己的机器人的时候，只是介绍了功能，但是很遗憾，动不了。&lt;/p&gt;
&lt;p&gt;轮到我介绍的时候，确实惊艳了全场，评委老师很惊奇的看到我的机器人能动。&lt;/p&gt;
&lt;p&gt;实际上，这个内置的程序是掉电消失的，并且，由于积木很老了，里面的锂电池根本就撑不了多久。我在基地写好程序，拿到比赛现场，为了防止程序丢失，我找了充电器。因为在运行的时候，不带充电线的锂电池会瞬间掉电，然后程序消失。所以能动起来也很幸运。&lt;/p&gt;
&lt;p&gt;我本来就没期待什么，我感觉只是按照自己的想法实现了这个小作品。后来宣布第一名的时候，居然不是我。我没有觉得很失落，毕竟也是很好玩的。只是上去领奖的那个人不是我，这让在场的所有人都感到十分的诧异。&lt;/p&gt;
&lt;p&gt;然后颁奖人员说弄错了，最后我还是获得了第一名。&lt;/p&gt;
&lt;h2 id=&#34;失败&#34;&gt;失败
&lt;/h2&gt;&lt;p&gt;学校要举行一个电子设计竞赛，面向全校人员开放。&lt;/p&gt;
&lt;p&gt;我看了比赛的题目，然后觉得可以尝试一下。我在百度上找到了类似的题目。内容是需要一系列的电子原件，焊接在一起，然后烧录所需要的程序，程序已经提供了。&lt;/p&gt;
&lt;p&gt;对于当时的我，那堆代码就是一堆乱码。&lt;/p&gt;
&lt;p&gt;我去了杭州电子市场，我在无数家商铺中穿梭，商店主人一个个看我感觉就像是异人一样。&lt;/p&gt;
&lt;p&gt;我笨拙着说出我想要的电子原件。商店主人好心的送了我一些LED小灯泡。&lt;/p&gt;
&lt;p&gt;她还说电烙铁要用扁头的，尖头的初学者用不好。&lt;/p&gt;
&lt;p&gt;他们很好奇我到底要做什么。&lt;/p&gt;
&lt;p&gt;原件买回来了，我坐在地板上，按照那篇博客给的电路图，在椅子上将东西焊好了。&lt;/p&gt;
&lt;p&gt;噢，对了，那个时候我也没有学过电路图，所以我只是按照想法焊好的。&lt;/p&gt;
&lt;p&gt;我觉得那时候的我挺单纯的，没有一点基础还想把东西焊出来。但是我却没有资格嘲笑他。&lt;/p&gt;
&lt;p&gt;然后开始烧录程序，我把单芯片放到了插座上，然后又把插座接上电源，开始用软件把那篇博客提供的程序尝试下载到芯片中。&lt;/p&gt;
&lt;p&gt;我其实想对他说，嘿，你确定这个网站提供的固件程序和你的芯片型号一致吗？芯片好烫，其实你插反了你知道吗，芯片估计已经被你烧毁了。&lt;/p&gt;
&lt;p&gt;然而我什么都不知道，我傻傻的拿着一个不知道什么原件焊出来的玩意和一个其实已经烧毁的芯片去参加评比，可想而知，我被评审专家鄙视了。&lt;/p&gt;
&lt;p&gt;然而我不知道的是，几乎没有像我这样的人去报名参加比赛。学校有一个电子设计竞赛实验班，在这个班上可以学习到所有你想学习的有关电子设计的知识。&lt;/p&gt;
&lt;p&gt;虽然比赛是面向全校的，但是报名的也只有这个实验班的会报名。&lt;/p&gt;
&lt;h2 id=&#34;我的第一个程序&#34;&gt;我的第一个程序
&lt;/h2&gt;&lt;p&gt;后来我才明白有电子设计班的存在。大二我报名了，我记得有一个考试和面试，通过才能进入。&lt;/p&gt;
&lt;p&gt;我记得当时他们问了几个问题，我都答不上来。后来问我C语言成绩是多少，我说97，然后就说可以，你通过了。&lt;/p&gt;
&lt;p&gt;第一个星期主要讲焊接的基本知识。虽然似乎故事才刚刚开始，然而我的这篇文章要讲的故事也快要结束了。&lt;/p&gt;
&lt;p&gt;第二个星期主要讲LED数码管的知识，我拿到了发的51开发板。晚上，我在寝室里学习让数码管按照自己的想法亮起来。&lt;/p&gt;
&lt;p&gt;我学习了怎么显示数字，是常亮的，我明白了原来是先要位选然后段选，我突然明白了很多，这就是最最原始的时间分片法吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/4388248-cb4503278381c120.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;我突然有一个想法，我想让数码管实现跑马灯的效果，就是外面的一圈不断的转圈圈。&lt;/p&gt;
&lt;p&gt;我写也写，写呀写。&lt;/p&gt;
&lt;p&gt;我写出来了。&lt;/p&gt;
&lt;p&gt;烧进去，运行，居然和我想象的一样，外面的一圈转呀转，真的很好看。我很开心。&lt;/p&gt;
&lt;h2 id=&#34;后记&#34;&gt;后记
&lt;/h2&gt;&lt;p&gt;也许那算不上我写的第一个程序，毕竟在那之前，C语言课也要求设计程序，那我应该已经写过程序了。&lt;/p&gt;
&lt;p&gt;然而对我而言，那个跑马灯，才是对我真正意义上的第一个程序，完全由我创造。&lt;/p&gt;
&lt;p&gt;就算有一天我死了，如果我写的程序能够运行下去，我可以以另一种方式来延续自己的生命。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>牛客网面经题目摘抄</title>
        <link>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/%E7%89%9B%E5%AE%A2%E7%BD%91%E9%9D%A2%E7%BB%8F%E9%A2%98%E7%9B%AE%E6%91%98%E6%8A%84/</link>
        <pubDate>Sat, 17 Mar 2018 06:42:00 +0000</pubDate>
        
        <guid>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/%E7%89%9B%E5%AE%A2%E7%BD%91%E9%9D%A2%E7%BB%8F%E9%A2%98%E7%9B%AE%E6%91%98%E6%8A%84/</guid>
        <description>&lt;h2 id=&#34;来源-阿里菜鸟java实习电话面试经凉凉&#34;&gt;来源 阿里菜鸟java实习电话面试经，凉凉~！~
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.nowcoder.com/discuss/67251?type=2&amp;amp;order=0&amp;amp;pos=7&amp;amp;page=1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.nowcoder.com/discuss/67251?type=2&amp;order=0&amp;pos=7&amp;page=1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;去除了java部分的题目&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用户请求在服务器是一个线程一个请求吗
这个问题搜了下有两种模型，一种是阻塞的一种是非阻塞的。现在一般使用基于IO多路复用的技术，Reactor模式，只需要一个线程或者少量线程，就可以处理大量请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器抗压策略
这个问题就更大了。百度了一下有两点，一个是缓存，一个是分布式。网友回答了消息队列，可以减轻大量并发量突发的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;很多很多个数，找到前十个
可以使用快排的变体&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;堆排序时间复杂度如何计算？
n×log n，就是n次，每次从低向顶出堆要log n次&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP和TCP
这个不知道问的具体是什么，可能是联系？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP关闭连接四次挥手，为啥
两次fin+ack，中间插入未发送完的数据。在带有延迟ack的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;来源-网易内推cc研发offer之路&#34;&gt;来源 网易内推（C++/C研发）offer之路
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.nowcoder.com/discuss/3038?type=2&amp;amp;order=0&amp;amp;pos=15&amp;amp;page=4&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.nowcoder.com/discuss/3038?type=2&amp;order=0&amp;pos=15&amp;page=4&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C++多态性都有哪些？
多态是一种接口多种实现。静态多态和动态多态。静态多态是通过泛型编程实现的，动态多态是通过虚函数实现的。&lt;/li&gt;
&lt;li&gt;动态绑定是怎么实现的？
静态绑定：编译时绑定，通过对象调用
动态绑定：运行时绑定，通过地址实现
动态绑定是通过虚表实现的。&lt;/li&gt;
&lt;li&gt;类型转换有哪些？
C风格的转换，强制类型转换，隐式类型转换。C++四种类型转换：static_cast，const_cast，dynamic_cost，reinterpret_cost。分别用于内置静态类型转换（int float）、去掉类型的const属性，用于动态类型转换（必须为父子类），重新解释类型而不做实质转换（指针强转）。&lt;/li&gt;
&lt;li&gt;内存对齐的原则
结构体基本数据类型成员要从成员大小的整数倍开始对齐，结构体作为成员要从最宽的数据类型的整数倍对齐。结构体的大小为内部最大的成员的整数倍对齐。&lt;/li&gt;
&lt;li&gt;模板是如何实现的？
编译器在遇到模板声明时记住这个模板名称。在调用时根据模板传入的参数类型产生出具体的类型的代码，然后进行编译。&lt;/li&gt;
&lt;li&gt;指针和const的用法？
const类型的指针，指向const类型的指针，指向const类型的const类型的指针。&lt;/li&gt;
&lt;li&gt;虚函数、纯虚函数、虚函数与析构函数？为什么析构函数要定义成虚函数？
&lt;a class=&#34;link&#34; href=&#34;http://liaoxl.github.io/blog/20131205/virtual-destructor/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://liaoxl.github.io/blog/20131205/virtual-destructor/&lt;/a&gt;
根据这篇文章所述，意思是如果定义为虚函数并且子类也实现了的话，那么子类的析构函数和父类的析构函数都会调用。&lt;/li&gt;
&lt;li&gt;内联函数&lt;/li&gt;
&lt;li&gt;const 和 typedef&lt;/li&gt;
&lt;li&gt;排序算法有哪些？快速排序怎么实现的？最好时间复杂度，平均时间复杂度。
插入、冒泡、堆排序、归并排序、桶排序、希尔排序、快速排序。&lt;/li&gt;
&lt;li&gt;extern “C”有什么用
主要是为了调用C编写的程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2017暑期实习c面经阿里网易游戏腾讯等&#34;&gt;2017暑期实习C++面经(阿里，网易游戏，腾讯等)
&lt;/h2&gt;&lt;p&gt;来源：https://www.nowcoder.com/discuss/23512?type=2&amp;amp;order=0&amp;amp;pos=20&amp;amp;page=2&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;map由什么实现的？你知道红黑树和AVL树有什么区别吗？为什么像map，set都用红黑树来实现？你有听过skip-list吗？&lt;/li&gt;
&lt;li&gt;用过vector.reserve()吗，vector的数组是怎么增长的？&lt;/li&gt;
&lt;li&gt;map-reduce了解吗？&lt;/li&gt;
&lt;li&gt;linux熟悉吗？目录权限，如644代表什么，目录如果有可执行权限代表什么？&lt;/li&gt;
&lt;li&gt;平时有使用vi吗？一般的linux命令熟悉吗？(如awk，grep等) 有用过gdb的调试吗？&lt;/li&gt;
&lt;li&gt;TCP/UDP的区别，如何实现拥塞控制，如何实现可靠传输？UDP的应用？
可靠/不可靠 字节流/报文 连接/非连接 开销大/开销小 有拥塞控制/无拥塞控制 全双工/单工
拥塞控制目的是为了防止发送的数据包超出了网络的承载能力，涉及到所有的主机和路由器。拥塞控制认为丢包是因为数据包超出了网络的承载能力，所以在发送数据包的，需要慢开始，不断地达到网络的承载能力，将拥塞窗口以指数的规律增长到慢开始门限，超出门限后，如果继续增大数据包的发送量，认为网络将会出现拥塞，所以进入拥塞避免状态，该阶段以线性的增长规模扩大拥塞窗口，直到拥塞发生。如果某个数据包在超时计时器已到仍然没有收到对方的ACK，则认为网络中出现了拥塞，此时将慢开始门限设置为当前窗口的一半，并执行慢开始算法。如果收到了对方的三个重复的确认报文，则认为对方尚未收到丢失的报文，则尽早重传未被确认的报文，而不是等到超时计时器到时时才重传，这就是快速重传。如果出现了快速重传，则不执行慢开始算法，而是将拥塞窗口设置为慢开始门限，然后执行拥塞避免，这就是快恢复。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;作者：Simon_
链接：&lt;a class=&#34;link&#34; href=&#34;https://www.nowcoder.com/discuss/23512?type=2&amp;amp;order=0&amp;amp;pos=20&amp;amp;page=2&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.nowcoder.com/discuss/23512?type=2&amp;amp;order=0&amp;amp;pos=20&amp;amp;page=2&lt;/a&gt;
来源：牛客网&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;我觉得阿里更注重项目和分布式，多线程方面的知识。网易游戏的话更注重算法和C++吧。腾讯的话就什么都问，从C++的内存结构，RTTI，到网络编程，到智力题的算法实现。同学们可以根据自己要投的公司再好好准备准备。与君共勉。&lt;/p&gt;
&lt;p&gt;准备实习之前刷过的书籍有《C++ primer》, 《深度探索C++对象模型》，《Effective C++》，《STL源码解析》，《剑指offer》还有就是一些网络和操作系统的书。刷了leetcode前120的题 目。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;给未来找C++研发实习的学弟学妹的一些建议：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;最好在找实习之前，先把C++ primer刷几遍，不懂的可以做个笔记，下次再看。当你看《对象模型》的时候，你会发现Primer中看不懂的知识都能在《对象模型》中迎刃而解。（关于Primer的学习方法我是参照https://www.zhihu.com/question/32087709中的第一个回答来做的）&lt;/li&gt;
&lt;li&gt;《STL源码解析》最好也看看。面试官很喜欢问vector，map等的底层实现或者动态增长，如果不看书，关靠看博客和面经的话可能理解起来比较困难。&lt;/li&gt;
&lt;li&gt;剑指offer是大部分公司一面的算法题，我觉得最好把每个题目都看懂吧。leetcode的话前100题确实很经典，二分查找，hash，动态规划，二叉树等的知识也可以通过刷题来巩固。&lt;/li&gt;
&lt;li&gt;网络的话肯定是TCP/IP详解  卷1，有时间的话可以再看看Unix网络编程。时间更充裕的话最好刷一刷陈硕的《linux多线程服务器编程》，对多线程的知识会有一个了解。&lt;/li&gt;
&lt;li&gt;最后一个建议就是越早准备越好，投递简历、面试期间只适合整理牛客网上的面经以及自己的面经，补缺补漏。毕竟面试题都是随机的，想要在面试中表现好一些，最好还是平时多积累。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;cc后台研发-腾讯实习春招一面-凉凉&#34;&gt;C/C++后台研发 腾讯实习春招一面 凉凉~
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.nowcoder.com/discuss/68508?type=0&amp;amp;order=0&amp;amp;pos=8&amp;amp;page=0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.nowcoder.com/discuss/68508?type=0&amp;order=0&amp;pos=8&amp;page=0&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vector底层的实现. 这里我说的比较多,所以他问到了insert具体做里那些事情. resize函数调用的是什么样. 扩容的情况.&lt;/li&gt;
&lt;li&gt;进程间通信机制
管道（pipe），有名管道（FIFO）
信号（signal）
消息队列
共享内存
信号量
套接字（socket)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;阿里巴巴菜鸟网络二面&#34;&gt;阿里巴巴菜鸟网络二面
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://blog.csdn.net/caishenfans/article/details/44496581&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://blog.csdn.net/caishenfans/article/details/44496581&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;fill和memset的区别
fill 是stl算法，会调用拷贝构造函数，如果是基础类型应该会直接按位复制。memset是c算法，就是一个字节一个字节拷贝到原始指针指向的位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C++内存管理方法
RAII全称为Resource Acquisition Is Initialization
利用栈展开过程栈上对象的析构函数将被 自动调用的保证，从而正确地释放先前获取的资源。RAII只有在栈展开正常执行的前提下才能正常工作。函数调用和正常的C++异常处理流程(异常处于 try-catch块)都存在栈展开。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;智能指针的实现
当有另外一个智能指针对当前智能指针进行拷贝时，引用计数器加1。
当两个智能指针进行赋值操作时，左边的指针指向的对象引用计数减1，右边的加1。
析构时，同样引用计数减1。
当引用计数为0时，对象被回收。
重新定义了一组operator ：-&amp;gt;指针，返回原始指针的指针。解引用*T，返回原始指针的解引用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;阿里实习电话面试经验一个多小时&#34;&gt;阿里实习电话面试经验，一个多小时
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.nowcoder.com/discuss/3836&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.nowcoder.com/discuss/3836&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是二叉平衡树，如何插入节点，删除节点，说出关键步骤。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;学生党如何拿到阿里技术offer阿里实习生面试经验成功&#34;&gt;学生党如何拿到阿里技术offer：《阿里实习生面试经验（成功）》
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://yq.aliyun.com/articles/6395&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://yq.aliyun.com/articles/6395&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;阿里c研发实习二面和三面面经已跪&#34;&gt;阿里C++研发实习二面和三面面经(已跪)
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.nowcoder.com/discuss/27801?type=2&amp;amp;order=3&amp;amp;pos=55&amp;amp;page=1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.nowcoder.com/discuss/27801?type=2&amp;order=3&amp;pos=55&amp;page=1&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;实习面试总结&#34;&gt;实习面试总结
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.nowcoder.com/discuss/25302?type=2&amp;amp;order=3&amp;amp;pos=190&amp;amp;page=1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.nowcoder.com/discuss/25302?type=2&amp;order=3&amp;pos=190&amp;page=1&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;知乎牛客总结&#34;&gt;知乎牛客总结
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://link.zhihu.com/?target=https%3A//www.nowcoder.com/discuss/27801%3Ftype%3D2%26order%3D3%26pos%3D55%26page%3D1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;阿里C++研发实习二面和三面面经(已跪)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://link.zhihu.com/?target=https%3A//www.nowcoder.com/discuss/27739%3Ftype%3D2%26order%3D3%26pos%3D57%26page%3D2&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;【阿里、腾讯、头条】等12家企业【C++方向】30场面试经验&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://link.zhihu.com/?target=https%3A//www.nowcoder.com/discuss/27616%3Ftype%3D2%26order%3D3%26pos%3D61%26page%3D1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;阿里校招实习一面面经&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://link.zhihu.com/?target=https%3A//www.nowcoder.com/discuss/27349%3Ftype%3D2%26order%3D3%26pos%3D71%26page%3D1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;阿里巴巴秋招再见&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://link.zhihu.com/?target=https%3A//www.nowcoder.com/discuss/26107%3Ftype%3D2%26order%3D3%26pos%3D125%26page%3D1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;百度三面（offer）&amp;amp;&amp;amp;阿里四面（进行中）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://link.zhihu.com/?target=https%3A//www.nowcoder.com/discuss/25923%3Ftype%3D2%26order%3D3%26pos%3D143%26page%3D1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;双非大三春招实习面经&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://link.zhihu.com/?target=https%3A//www.nowcoder.com/discuss/25302%3Ftype%3D2%26order%3D3%26pos%3D190%26page%3D1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;实习面试总结&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://link.zhihu.com/?target=https%3A//www.nowcoder.com/discuss/24900%3Ftype%3D2%26order%3D3%26pos%3D230%26page%3D1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;阿里，摩根，野村，腾讯，微软，图鸭科技面经分享&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://link.zhihu.com/?target=http%3A//www.nowcoder.com/discuss/8343%3Ftype%3D0%26order%3D3%26pos%3D3950%26page%3D1%26from%3Dmnks201&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;阿里四面面经 + 已成功拿到offer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://link.zhihu.com/?target=https%3A//www.nowcoder.com/discuss/18460%3Ftype%3D2%26order%3D3%26pos%3D57%26page%3D2%26from%3Dmnks201&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;我的2016笔试面试经验(送给下一届的学弟学妹们)&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;阿里巴巴2017实习面试分享技术三面hr面&#34;&gt;阿里巴巴2017实习面试分享（技术三面+HR面）
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.nowcoder.com/discuss/25446&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.nowcoder.com/discuss/25446&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>菜鸟B2B面试一面经历记录、c&#43;&#43;后台开发</title>
        <link>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/%E8%8F%9C%E9%B8%9Fb2b%E9%9D%A2%E8%AF%95%E4%B8%80%E9%9D%A2%E7%BB%8F%E5%8E%86%E8%AE%B0%E5%BD%95c&#43;&#43;%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/</link>
        <pubDate>Fri, 09 Mar 2018 02:30:00 +0000</pubDate>
        
        <guid>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/%E8%8F%9C%E9%B8%9Fb2b%E9%9D%A2%E8%AF%95%E4%B8%80%E9%9D%A2%E7%BB%8F%E5%8E%86%E8%AE%B0%E5%BD%95c&#43;&#43;%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/</guid>
        <description>&lt;h2 id=&#34;前言&#34;&gt;前言
&lt;/h2&gt;&lt;p&gt;我是研二学生，而且导师不放实习，但是为了增加面试经验所以面了春招实习。
我的简历写的很朴素很简单，所以面试官的题目难度比较低。一面，面试时间是2018年3月8日晚7点。由于前一晚我在做阿里测试，所以面试官说延后一天面试，这也给了我时间来准备面试。特别是又把基础知识复习了一遍，很有帮助。&lt;/p&gt;
&lt;h2 id=&#34;自我介绍&#34;&gt;自我介绍
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;略&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;项目的经历和对你的影响&#34;&gt;项目的经历和对你的影响
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;略&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四层网络结构有哪些&#34;&gt;四层网络结构有哪些
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;我回答了包含有光纤、交换机、双绞线的物理层，ip的网络层，tcp icmp udp的传输层，http dns的应用层。&lt;/li&gt;
&lt;li&gt;标准答案：实际上TCP/IP标准并不定义与ISO数据链路层和物理层相对应的功能。相反，它定义像地址解析协议（Address Resolution Protocol,ARP）这样的协议，提供TCP/IP协议的数据结构和实际物理硬件之间的接口。所以第一个应该是链路层，包含有ARP协议，以及设备的驱动。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;你对其中的哪一层比较熟悉&#34;&gt;你对其中的哪一层比较熟悉？
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;我回答了传输层的tcp协议。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tcp与udp的区别&#34;&gt;TCP与udp的区别？
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;略&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三次握手与四次挥手&#34;&gt;三次握手与四次挥手？
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;略&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;你为什么对这个过程比较熟悉&#34;&gt;你为什么对这个过程比较熟悉？
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;我回答了是主要看书看的。当然项目里也用到了，自己用tcpdump和wireshark抓包看过过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;io多路复用是怎么样的&#34;&gt;I/O多路复用是怎么样的？
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我回答了因为多线程比较占开销之类的，对方听了一会说，不是，他想问I/O多路复用的实现原理。我回答说忘记了，但是我记得select poll epoll的实现过程中使用了高效的数据结构来检查到底是哪一个文件描述符上出现了io操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标准答案是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;epoll的高效就在于，当我们调用epoll_ctl往里塞入百万个句柄时，epoll_wait仍然可以飞快的返回，并有效的将发生事件的句柄给我们用户。这是由于我们在调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。
传统的select/poll另一个致命弱点就是当你拥有一个很大的socket集合，不过由于网络延时，任一时间只有部分的socket是“活跃”的，但是select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。但是epoll不存在这个问题，它只会对“活跃”的socket进行操作&amp;mdash;这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。那么，只有“活跃”的socket才会主动的去调用 callback函数，其他idle状态socket则不会。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;介绍c里的多态&#34;&gt;介绍C++里的多态
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;略&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;什么是析构函数作用呢&#34;&gt;什么是析构函数，作用呢
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;略&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;虚析构函数的作用&#34;&gt;虚析构函数的作用？
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;略&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;父类的析构函数是否要设置成为虚函数&#34;&gt;父类的析构函数是否要设置成为虚函数？
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;肯定要&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;浅拷贝和深拷贝的区别&#34;&gt;浅拷贝和深拷贝的区别？
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;略&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;如果一个函数传入一个对象那么这是浅拷贝还是深拷贝&#34;&gt;如果一个函数传入一个对象，那么这是浅拷贝还是深拷贝？
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;我回答了这要看拷贝构造函数。但是具体是如何的我不确定。&lt;/li&gt;
&lt;li&gt;标准答案应该是，如果使用的是引用或指针不会发生拷贝，如果传入的类没有实现拷贝构造函数则是浅拷贝，如果实现了拷贝构造函数则看实现的拷贝构造函数是浅拷贝还是深拷贝。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;c语言里的指针是什么&#34;&gt;C语言里的指针是什么。
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;我回答是首先它是一个变量，里面存的是所指向的内部数据类型或对象的地址。取内容可以获得这个数据或对象。&lt;/li&gt;
&lt;li&gt;实际上指针不一定是变量，也有常量指针，不过一般都说指针是指针变量的简称。所以上述表达没有什么问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;形参实参的区别&#34;&gt;形参实参的区别。
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;说实话我也搞不清楚，我说不知道但是把指针、引用、普通传参都说了一遍。&lt;/li&gt;
&lt;li&gt;后来查到形参指的是外部调用的时候传入的参数，实参是函数在处理内部所使用的参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;介绍模拟退火算法&#34;&gt;介绍模拟退火算法
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;由于简历上写了&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;熵是什么增大代表什么&#34;&gt;熵是什么，增大代表什么
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;略&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;部门主要以java开发如果让你做java开发你会抵触吗&#34;&gt;部门主要以Java开发，如果让你做Java开发你会抵触吗？
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;略&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;对于公司有什么想了解的&#34;&gt;对于公司有什么想了解的。
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;略&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;后记&#34;&gt;后记
&lt;/h2&gt;&lt;p&gt;总时长27分钟，语速比较快，有点紧张和激动。大概就是这些，有想起来的再补充。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>C智能指针学习</title>
        <link>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/c&#43;&#43;-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0/</link>
        <pubDate>Sat, 03 Feb 2018 09:30:00 +0000</pubDate>
        
        <guid>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/c&#43;&#43;-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0/</guid>
        <description>&lt;h2 id=&#34;前言&#34;&gt;前言
&lt;/h2&gt;&lt;p&gt;智能指针似乎越来越广泛的使用了。有必要好好记住。&lt;/p&gt;
&lt;h2 id=&#34;shared_ptr&#34;&gt;shared_ptr
&lt;/h2&gt;&lt;p&gt;shared_ptr允许多个指针指向同一个对象，unique_ptr则独占所指的对象。&lt;/p&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;memory&amp;gt;
#include &amp;lt;thread&amp;gt;

class A
{
    char * str;
    public:
    A(){
        str = new char[20];
        printf(&amp;#34;构造\n&amp;#34;);
    }
    ~A()
    {
        printf(&amp;#34;析构\n&amp;#34;);
        delete [] str;
    }

};

std::shared_ptr&amp;lt;A&amp;gt; xixi;

void test()
{
    std::shared_ptr&amp;lt;A&amp;gt; shared_a = std::make_shared&amp;lt;A&amp;gt;();
    xixi = shared_a;
    printf(&amp;#34;%d\n&amp;#34;, xixi.use_count());
}

int main()
{   
    test();
    std::this_thread::sleep_for(std::chrono::seconds(1));
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面这个例子中，xixi是全局智能指针，会在程序结束时才会释放自己所指向的对象，如果去掉了xixi=shared_a，则在main函数延迟之前就会看到析构。&lt;/p&gt;
&lt;h2 id=&#34;unique_ptr&#34;&gt;unique_ptr
&lt;/h2&gt;&lt;p&gt;unique_ptr独占对象，只能在不同的unique_ptr中移动（std::move）。没有make_unique语句。只能在构造函数中传入对象的指针来构造unique_ptr。&lt;/p&gt;
&lt;p&gt;unique_ptr使用场景
1、为动态申请的资源提供异常安全保证
我们先来看看下面这一段代码：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void Func()
{
    int *p = new int(5);

    // ...（可能会抛出异常）

    delete p;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是我们传统的写法：当我们动态申请内存后，有可能我们接下来的代码由于抛出异常或者提前退出（if语句）而没有执行delete操作。&lt;/p&gt;
&lt;p&gt;解决的方法是使用unique_ptr来管理动态内存，只要unique_ptr指针创建成功，其析构函数都会被调用。确保动态资源被释放。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void Func()
{
    unique_ptr&amp;lt;int&amp;gt; p(new int(5));

    // ...（可能会抛出异常）
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;week_ptr&#34;&gt;week_ptr
&lt;/h2&gt;&lt;p&gt;week_ptr也是一种强大的指针，名字起的比较弱。week_ptr不控制对象的生命周期，用于在不持有对象时使用。week_ptr可以在对象存在时提升为shared_ptr。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>关于CSDN移动端被电信劫持红包广告的现象与感想</title>
        <link>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/%E5%85%B3%E4%BA%8Ecsdn%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%A2%AB%E7%94%B5%E4%BF%A1%E5%8A%AB%E6%8C%81%E7%BA%A2%E5%8C%85%E5%B9%BF%E5%91%8A%E7%9A%84%E7%8E%B0%E8%B1%A1%E4%B8%8E%E6%84%9F%E6%83%B3/</link>
        <pubDate>Sun, 31 Dec 2017 06:24:00 +0000</pubDate>
        
        <guid>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/%E5%85%B3%E4%BA%8Ecsdn%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%A2%AB%E7%94%B5%E4%BF%A1%E5%8A%AB%E6%8C%81%E7%BA%A2%E5%8C%85%E5%B9%BF%E5%91%8A%E7%9A%84%E7%8E%B0%E8%B1%A1%E4%B8%8E%E6%84%9F%E6%83%B3/</guid>
        <description>&lt;h2 id=&#34;前言&#34;&gt;前言
&lt;/h2&gt;&lt;p&gt;最近疑似被电信劫持，遂将分析记录下来&lt;/p&gt;
&lt;h2 id=&#34;现象&#34;&gt;现象
&lt;/h2&gt;&lt;p&gt;我的三星S8使用的是四川电信卡，在访问如下网站时会被跳转到全屏广告，也就是支付宝红包界界面，体验非常差，下面这个就是一个会被劫持的地址。
&lt;a class=&#34;link&#34; href=&#34;http://m.blog.csdn.net/skyroben/article/details/70195575&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://m.blog.csdn.net/skyroben/article/details/70195575&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;分析&#34;&gt;分析
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;手机使用ss代理（4G）再访问上述网站，没有广告，没有劫持&lt;/li&gt;
&lt;li&gt;手机直连，电信wifi，访问有劫持&lt;/li&gt;
&lt;li&gt;使用热点，用电脑点击上面的网址，不会出现劫持&lt;/li&gt;
&lt;li&gt;使用热点，使用插件更改电脑端user agent为Android客户端，有一定概率出现劫持？？&lt;/li&gt;
&lt;li&gt;不使用热点，电脑有线（电信），更改电脑端user agent为Android客户端，有一定概率出现劫持？？&lt;/li&gt;
&lt;li&gt;使用手机端chrome（s8），连上电信wifi，在网址前加上view-source:查看网页源码，并将结果分别保存，在电脑端查看两文件进行差分对比，并没有不同。&lt;/li&gt;
&lt;li&gt;使用手机端chrome（s8），连上移动wifi，有劫持！（脚本缓存？）&lt;/li&gt;
&lt;li&gt;使用ios chrome，连电信wifi，没有劫持&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;综上&#34;&gt;综上
&lt;/h2&gt;&lt;p&gt;由于劫持后网页源码没有变化，可能是劫持了脚本。由于使用移动wifi访问也会出现劫持，所有不能排除csdn自己加入的广告。使用ss代理就可以破解劫持，说明劫持是区域性的。电脑和ios访问不会被劫持，说明劫持只针对Android浏览器。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论
&lt;/h2&gt;&lt;p&gt;一般用户最好不要使用电信网络和Android手机，并且建议所有网站使用https进行加密&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Cocos Creator 从零学习 一</title>
        <link>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/cocos-creator-%E4%BB%8E%E9%9B%B6%E5%AD%A6%E4%B9%A0-%E4%B8%80/</link>
        <pubDate>Tue, 27 Jun 2017 09:31:00 +0000</pubDate>
        
        <guid>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/cocos-creator-%E4%BB%8E%E9%9B%B6%E5%AD%A6%E4%B9%A0-%E4%B8%80/</guid>
        <description>&lt;h2 id=&#34;前言&#34;&gt;前言
&lt;/h2&gt;&lt;p&gt;尽管知乎上对Cocos2dx成见很大，但是徘徊于纠结用什么游戏引擎不如都试试。况且这个软件是国人开发的，学习起来应该不算困难。&lt;/p&gt;
&lt;p&gt;虽然没有学过JavaScript，但是似乎也可以边查边写吧。JavaScript的教程： &lt;a class=&#34;link&#34; href=&#34;http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Cocos creator目前版本为1.5.1，官网有一份很详细的手册，网址为 &lt;a class=&#34;link&#34; href=&#34;http://www.cocos.com/docs/creator/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.cocos.com/docs/creator/&lt;/a&gt; 。这篇文章是该快速上手这一章的精简版，并且对游戏性进行了提升。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/4388248-97260c179cc5ff7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;知乎网友表情.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装
&lt;/h2&gt;&lt;p&gt;windows下面的安装是没有任何问题的。mac下的安装，需要注意一下。
在官网下载安装包之后，拖动到applications中之后，打开会提示该应用是未被信任的开发者。此时，打开系统偏好设置中的安全性与隐私中的通用，会看到打开的按钮，通过此方式打开之后，不再进行提醒了。&lt;/p&gt;
&lt;h2 id=&#34;快速开始&#34;&gt;快速开始
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/4388248-d9d3f43b9e1e4063.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;dashboard&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;从dashboard开始新建项目，或者打开项目。根据教程中关于快速上手的部分，我们从这个地址可以下载到一个初始工程项目 &lt;a class=&#34;link&#34; href=&#34;https://github.com/cocos-creator/tutorial-first-game/releases/download/v1.2/start_project.zip&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;下载初始项目&lt;/a&gt; 。
或者点击这里下载 &lt;a class=&#34;link&#34; href=&#34;https://github.com/cocos-creator/tutorial-first-game/releases/download/v1.2/start_project.zip&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/cocos-creator/tutorial-first-game/releases/download/v1.2/start_project.zip&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个快速上手最终做出的游戏效果是这样的： &lt;a class=&#34;link&#34; href=&#34;http://fbdemos.avosapps.com/star-catcher/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://fbdemos.avosapps.com/star-catcher/&lt;/a&gt; 。
这个游戏有点类似于接金币这样的游戏，但是更加困难，游戏的学习曲线非常的大，由于这个小怪物的水平加速度难以驾驭以及上下蹦跳的关系，几乎很难已去接到五角星，而且也没有什么剧情。我们最好把他改的好玩一点吧。&lt;/p&gt;
&lt;p&gt;打开这个项目，我们先学习一下界面。左下角是资源面板，在初始项目中，已经建立了一个工程目录，这里有最基本的资源，已经目录组织。assets的意思是资产，在这个总目录下面，有三个子目录，包含有字体，音频，与图片资源。&lt;/p&gt;
&lt;h2 id=&#34;创建场景&#34;&gt;创建场景
&lt;/h2&gt;&lt;p&gt;场景是至关重要的，因为场景包含了游戏脚本，而场景在游戏开始的时候会自动加载。在资源面板中的assets下点击加号创建一个场景，重命名为game，双击打开。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/4388248-3d7fb1d661e357d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;屏幕快照 2017-06-20 上午11.01.53.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;左上角的层级管理器显示的是当前的场景中节点之间的关系。
在这个game场景中，只有一个根节点canvas（画布），现在这个节点上是空的，意味着什么都不会加载。&lt;/p&gt;
&lt;p&gt;点击根结点在右侧数据面板中，我们可以设置根节点的分辨率。分辨率的高度设置为自适应，总为960x640，和iPhone第一代长宽比一致，推测这个分辨率应该是dp而不是pixel吧。&lt;/p&gt;
&lt;h2 id=&#34;场景图像&#34;&gt;场景图像
&lt;/h2&gt;&lt;p&gt;将资源background拖拽到canvas上，使得background成为canvas的一个子节点，注意不要将background变成另一个根节点。
使用cmd+s来保存刚刚的变动。
选中场景中的background图片，然后，在左上角找到变换工具的第四个按钮，分别是平移，旋转，缩放，矩形变换。选中矩形变换，将background变换为一个能覆盖场景的大小，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/4388248-8e82dacdb3280ea5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;场景图像&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;上述步骤也可以直接对background的属性进行设置，设置位置为0，0，宽高为1600和800就行。&lt;/p&gt;
&lt;p&gt;用同样的方法添加地面。
用同样的方法插入小怪物，并且重命名为player。图片的默认锚点为中心位置，这里将锚点anchor的y设置为0。&lt;/p&gt;
&lt;h2 id=&#34;创建脚步&#34;&gt;创建脚步
&lt;/h2&gt;&lt;p&gt;接下来出现了惊人的一幕，教程居然说不会编程也没关系，&lt;strong&gt;你可以交给你的程序员小伙伴来解决&lt;/strong&gt;，果然是我现在只差一个程序员了。&lt;/p&gt;
&lt;p&gt;在下图中资源的player的位置建立一个js脚本文件，并打开。
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/4388248-f9e3103c2df38876.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;脚本&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在properties中插入以下内容，这部分是小怪物的物理属性&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;        jumpHeight:0,
        jumpDuration:0,
        maxMoveSpeed:0,
        accel:0,
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;选中小怪物图片，在属性框中找到添加组件，把player脚本添加到player图片上，并且设置好相关参数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/4388248-177701eab4de6cc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;参数设置&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;完善脚本&#34;&gt;完善脚本
&lt;/h2&gt;&lt;p&gt;我们在脚本中继续加入其他功能。首先是跳跃的动作。&lt;/p&gt;
&lt;p&gt;在properties下面加入这一段&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    setJumpAction: function(){
        var jumpUp = cc.moveBy(this.jumpDuration, cc.p(0,this.jumpHeight)).easing(cc.easeQuadraticActionOut());
        var jumpDown = cc.moveBy(this.jumpDuration, cc.p(0,-this.jumpHeight)).easing(cc.easeQuadraticActionIn());
        return cc.repeatForever(cc.sequence(jumpUp, jumpDown));
    },
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;moveBy是官方的API，在官方API中查询一下该API的使用，第一个参数是移动的距离，第二个参数是移动的位置。很显然是向上移动了一段距离。后面的easing是生成缓动运动，生成的对象是easeQuadraticActionIn和Out，这两个是二次曲线。原来的教程中是三次曲线，这个和真实世界中的物理运动差的太多了。&lt;/p&gt;
&lt;p&gt;在onload方法中加入下面这段代码，启动动画。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    onLoad: function () {
        this.jumpAction = this.setJumpAction();
        this.node.runAction(this.jumpAction);
    },
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在点击播放按钮刻可以查看初始的效果。&lt;/p&gt;
&lt;h2 id=&#34;控制角色&#34;&gt;控制角色
&lt;/h2&gt;&lt;p&gt;为主角加上移动的控制。
在setJumpAction下面继续添加方法。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    setInputControl: function(){
        var self = this;
        cc.eventManager.addListener({
            event: cc.EventListener.KEYBOARD,
            onKeyPressed: function(keyCode, event){
                switch(keyCode){
                    case cc.KEY.a:
                        self.accLeft = true;
                        self.accRight = false;
                        break;
                    case cc.KEY.d:
                        self.accRight = true;
                        self.accLeft = false;
                }
            },
            onKeyReleased: function(keyCode, event){
                switch(keyCode){
                    case cc.KEY.a:
                        self.accLeft = false;
                        break;
                    case cc.KEY.d:
                        self.accRight = false;
                        break;
                }
            }
        }, self.node)
    },
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更新onload和update代码&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    onLoad: function () {
        this.jumpAction = this.setJumpAction();
        this.node.runAction(this.jumpAction);
        
        this.accLeft = false;
        this.accRight = false;
        
        this.xSpeed = 0;
        
        this.setInputControl();
    },

    update: function(dt){
        if(this.accLeft){
            this.xSpeed -= this.accel * dt;
        }
        else if(this.accRight){
            this.xSpeed += this.accel * dt;
        }
        if(this.xSpeed &amp;gt;0){
            this.xSpeed -= this.accel/2 * dt;
        }
        else if( this.xSpeed &amp;lt;0){
            this.xSpeed += this.accel/2 * dt;
        }
        if(Math.abs(this.xSpeed) &amp;gt; this.maxMoveSpeed){
            this.xSpeed = this.maxMoveSpeed * this.xSpeed / Math.abs(this.xSpeed);
        }
        
        this.node.x += this.xSpeed * dt;
    },
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第一个代码添加了个监听器，按键变动的时候改变accLeft和accRight的值。启动时打开监听，然后，在每一帧需要更新的时候，计算怪物的位置。&lt;/p&gt;
&lt;h2 id=&#34;增加五角星&#34;&gt;增加五角星
&lt;/h2&gt;&lt;p&gt;添加Game脚本到assets/scripts文件夹下，双击打开脚本，加入以下代码&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cc.Class({
    extends: cc.Component,

    properties: {
        // 这个属性引用了星星预制资源
        starPrefab: {
            default: null,
            type: cc.Prefab
        },
        // 星星产生后消失时间的随机范围
        maxStarDuration: 0,
        minStarDuration: 0,
        // 地面节点，用于确定星星生成的高度
        ground: {
            default: null,
            type: cc.Node
        },
        // player 节点，用于获取主角弹跳的高度，和控制主角行动开关
        player: {
            default: null,
            type: cc.Node
        },
        scoreDisplay: {
            default: null,
            type: cc.Label
        }
    },

    onLoad: function () {
        // 获取地平面的 y 轴坐标
        this.groundY = this.ground.y + this.ground.height/2;
        // 生成一个新的星星
        this.spawnNewStar();
        this.score = 0;
    },
    
    gainScore: function () {
        this.score += 1;
        // 更新 scoreDisplay Label 的文字
        this.scoreDisplay.string = &amp;#39;Score: &amp;#39; + this.score.toString();
    },

    spawnNewStar: function() {
        // 使用给定的模板在场景中生成一个新节点
        var newStar = cc.instantiate(this.starPrefab);
        // 将新增的节点添加到 Canvas 节点下面
        this.node.addChild(newStar);
        // 为星星设置一个随机位置
        newStar.setPosition(this.getNewStarPosition());
        newStar.getComponent(&amp;#39;star&amp;#39;).game = this;
    },

    getNewStarPosition: function () {
        var randX = 0;
        // 根据地平面位置和主角跳跃高度，随机得到一个星星的 y 坐标
        var randY = this.groundY + cc.random0To1() * this.player.getComponent(&amp;#39;Player&amp;#39;).jumpHeight + 50;
        // 根据屏幕宽度，随机得到一个星星 x 坐标
        var maxX = this.node.width/2;
        randX = cc.randomMinus1To1() * maxX;
        // 返回星星坐标
        return cc.p(randX, randY);
    },
    
    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从 资源管理器 中拖拽 assets/textures/star 资源到场景中，添加名叫 Star 的JavaScript脚本到assets/scripts/中，并关联脚本。
打开star脚本，添加如下代码&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: &amp;#39;Foo&amp;#39;, // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        pickRadius:0,
    },

    // use this for initialization
    onLoad: function () {

    },
    
    getPlayerDistance: function () {
        // 根据 player 节点位置判断距离
        var playerPos = this.game.player.getPosition();
        // 根据两点位置计算两点之间距离
        var dist = cc.pDistance(this.node.position, playerPos);
        return dist;
    },

    onPicked: function() {
        // 当星星被收集时，调用 Game 脚本中的接口，生成一个新的星星
        this.game.spawnNewStar();
        this.game.gainScore();
        // 然后销毁当前星星节
        this.node.destroy();
        
    },
    
    update: function (dt) {
        // 每帧判断和主角之间的距离是否小于收集距离
        if (this.getPlayerDistance() &amp;lt; this.pickRadius) {
            // 调用收集行为
            this.onPicked();
            return;
        }
    },    
    
    

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在在star的属性中设置pickRadius为60。
从层级管理器中将star节点拖拽到资源管理器中的assets文件夹下，就生成了名叫star的 Prefab 资源。
从场景中删除star节点。
选中Canvas节点后，拖拽脚本到 属性检查器，从资源管理器中拖拽star Prefab 资源到Game组件的Star Prefab属性中，从层级编辑器中拖拽ground和Player 节点到组件中相同名字的属性上。&lt;/p&gt;
&lt;p&gt;接下来再加入计分机制，和上面的过程十分的类似，这里就略去不详细写了，此时，测试一下游戏的效果，已经可以看到游戏大致效果。&lt;/p&gt;
&lt;p&gt;如果你有任何问题，可以查看官方的上手的教程，也可以点击这里可以下载到此为止的工程：
链接: &lt;a class=&#34;link&#34; href=&#34;https://pan.baidu.com/s/1dFw3VSP&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://pan.baidu.com/s/1dFw3VSP&lt;/a&gt; 密码: 7vgu&lt;/p&gt;
&lt;p&gt;官方在接下来继续进行了游戏的完善，不过我不打算继续完善下去了，接下来将关注对触摸屏的支持&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/4388248-8728df4746c57aa3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;效果&#34;
	
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>如何在windows10的微软拼音中设置小鹤双拼</title>
        <link>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/%E5%A6%82%E4%BD%95%E5%9C%A8windows10%E7%9A%84%E5%BE%AE%E8%BD%AF%E6%8B%BC%E9%9F%B3%E4%B8%AD%E8%AE%BE%E7%BD%AE%E5%B0%8F%E9%B9%A4%E5%8F%8C%E6%8B%BC/</link>
        <pubDate>Mon, 05 Jun 2017 06:16:00 +0000</pubDate>
        
        <guid>https://nansenli.com/zh-cn/post/jianshu/%E9%9A%8F%E7%AC%94/%E5%A6%82%E4%BD%95%E5%9C%A8windows10%E7%9A%84%E5%BE%AE%E8%BD%AF%E6%8B%BC%E9%9F%B3%E4%B8%AD%E8%AE%BE%E7%BD%AE%E5%B0%8F%E9%B9%A4%E5%8F%8C%E6%8B%BC/</guid>
        <description>&lt;h2 id=&#34;前言&#34;&gt;前言
&lt;/h2&gt;&lt;p&gt;win10最新版本系统自带的拼音已经可以支持小鹤双拼了，妈妈再也不用担心我装全家桶啦！&lt;/p&gt;
&lt;p&gt;时隔4年，更新一下进阶版设置，妈妈再也不用担心我一个一个配置按键啦：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;win + R，输入 regedit，打开注册表&lt;/li&gt;
&lt;li&gt;找到  &lt;code&gt;计算机\HKEY_CURRENT_USER\Software\Microsoft\InputMethod\Settings\CHS&lt;/code&gt; 项&lt;/li&gt;
&lt;li&gt;新建一个名为 UserDefinedDoublePinyinScheme0 的字符串值，值为 &lt;code&gt;小鹤双拼*2*^*iuvdjhcwfg^xmlnpbksqszxkrltvyovt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;打开微软拼音输入法设置，把 &lt;code&gt;小鹤双拼&lt;/code&gt; 设置为双拼的默认方案即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果担心修改注册表引起系统错乱，这里还有手工配置的方案：&lt;/p&gt;
&lt;h2 id=&#34;第一步-打开设置&#34;&gt;第一步 打开设置
&lt;/h2&gt;&lt;p&gt;系统的拼音输入法虽然没有小鹤双拼，但是我们可以自定义。&lt;/p&gt;
&lt;p&gt;首先在设置中找到设置双拼的位置，如果你找不到，可以看动图：
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/4388248-89a2a034b1eeacac.gif?imageMogr2/auto-orient/strip&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;找到设置&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;第二步-编辑自定义双拼&#34;&gt;第二步 编辑自定义双拼
&lt;/h2&gt;&lt;p&gt;双拼设置如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/4388248-fad73bc68cb1d79a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;小鹤方案&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;除了模板那里不用设置以外，其他的按照图中的设置就可以了，一个是零声母模式，另外一个是自定义按键，自定义按键按照图中的预览设置就可以了。需要注意的是，小鹤双拼中没有er这个音节，设置成e或者r键都可以。另外，ue，ve这两个音节都设置为T。有一个小技巧，设置按键的时候，可以直接按下对应的按键，而不用找到这个键来设置。&lt;/p&gt;
&lt;h2 id=&#34;第三步-保存方案&#34;&gt;第三步 保存方案
&lt;/h2&gt;&lt;p&gt;如果添加按钮变为可用，说明方案设置正确。添加为方案后，把该方案设置为默认方案，就可以使用小鹤双拼啦。&lt;/p&gt;
&lt;h2 id=&#34;测试&#34;&gt;测试
&lt;/h2&gt;&lt;p&gt;进行打字测试，查看设置的对不对&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/4388248-7cf2b91fa49d4923.gif?imageMogr2/auto-orient/strip&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;测试&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;第四步-点击喜欢&#34;&gt;第四步 点击喜欢
&lt;/h2&gt;&lt;p&gt;点击喜欢，提高页面排名，帮助更多人用上win10小鹤双拼&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
