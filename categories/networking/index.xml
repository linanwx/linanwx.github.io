<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Networking on Nansen Li&#39;s Blog
ÊùéÊ•†Ê£ÆÁöÑÂçöÂÆ¢
</title>
        <link>https://nansenli.com/categories/networking/</link>
        <description>Recent content in Networking on Nansen Li&#39;s Blog
ÊùéÊ•†Ê£ÆÁöÑÂçöÂÆ¢
</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>Nansen Li üåà ÔºàÊùéÊ•†Ê£ÆÔºâ</copyright>
        <lastBuildDate>Tue, 11 Dec 2018 10:50:00 +0000</lastBuildDate><atom:link href="https://nansenli.com/categories/networking/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Socket.io Learning</title>
        <link>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/socket-io%E5%AD%A6%E4%B9%A0/</link>
        <pubDate>Tue, 11 Dec 2018 10:50:00 +0000</pubDate>
        
        <guid>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/socket-io%E5%AD%A6%E4%B9%A0/</guid>
        <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction
&lt;/h2&gt;&lt;p&gt;In a hurry, will write more later&lt;/p&gt;
&lt;h2 id=&#34;core-concepts&#34;&gt;Core Concepts
&lt;/h2&gt;&lt;p&gt;Both the server and client have &lt;code&gt;emit&lt;/code&gt; and &lt;code&gt;on&lt;/code&gt; functions, which can be considered the core of socket.io. Through &lt;code&gt;emit&lt;/code&gt; and &lt;code&gt;on&lt;/code&gt;, bidirectional communication between server and client can be easily implemented.&lt;/p&gt;
&lt;p&gt;emit: Used to emit or trigger an event. The first parameter is the event name, the second parameter is the data to be sent, and the third parameter is a callback function (generally omitted, but needed when immediate confirmation is required after the other party receives the information).
on: Used to listen for an event emitted by &lt;code&gt;emit&lt;/code&gt;. The first parameter is the name of the event to listen for, and the second parameter is an anonymous function used to receive data from the other party. The first parameter of this anonymous function is the received data, and if there is a second parameter, it is the function to be returned.
socket.io provides three default events (both client and server have them): connect, message, and disconnect. The connect event is automatically triggered when a connection is established with the other party, the message event is triggered when data is received from the other party (usually triggered by socket.send()), and the disconnect event is triggered when the other party closes the connection.&lt;/p&gt;
&lt;p&gt;On the server side, distinguish between these three situations:&lt;/p&gt;
&lt;p&gt;socket.emit(): Broadcasts to the client that established the connection
socket.broadcast.emit(): Broadcasts to all clients except the one that established the connection
io.sockets.emit(): Broadcasts to all clients, equivalent to the sum of the above two&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Legal Single-Line Dual Dial - Improving Dorm Router Bandwidth Utilization</title>
        <link>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/%E5%90%88%E6%B3%95%E5%8D%95%E7%BA%BF%E5%8F%8C%E6%8B%A8%E6%8F%90%E9%AB%98%E5%AF%9D%E5%AE%A4%E8%B7%AF%E7%94%B1%E5%B8%A6%E5%AE%BD%E5%88%A9%E7%94%A8%E7%8E%87/</link>
        <pubDate>Sat, 10 Nov 2018 18:08:00 +0000</pubDate>
        
        <guid>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/%E5%90%88%E6%B3%95%E5%8D%95%E7%BA%BF%E5%8F%8C%E6%8B%A8%E6%8F%90%E9%AB%98%E5%AF%9D%E5%AE%A4%E8%B7%AF%E7%94%B1%E5%B8%A6%E5%AE%BD%E5%88%A9%E7%94%A8%E7%8E%87/</guid>
        <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction
&lt;/h2&gt;&lt;p&gt;My dormitory has two China Mobile broadband connections via fiber to the home. One is 20Mbps and the other is 30Mbps, both using PPPoE dial-up. I hope to combine these two bandwidths.&lt;/p&gt;
&lt;h2 id=&#34;solution-1&#34;&gt;Solution 1
&lt;/h2&gt;&lt;p&gt;Searched for multi-WAN port routers on JD.com, but they are quite expensive. Pass.&lt;/p&gt;
&lt;h2 id=&#34;solution-2&#34;&gt;Solution 2
&lt;/h2&gt;&lt;p&gt;Modify my Xiaomi Router Mini by flashing OpenWrt.&lt;/p&gt;
&lt;h2 id=&#34;flashing-openwrt&#34;&gt;Flashing OpenWrt
&lt;/h2&gt;&lt;p&gt;This isn&amp;rsquo;t the focus of this article. However, it&amp;rsquo;s worth noting that OpenWrt firmware can be found and downloaded from the official website. Its repositories are complete and up-to-date, so you don&amp;rsquo;t need to flash outdated firmware like Pandorabox with unreliable repositories. The router needs to be flashed with a developer version firmware and SSH firmware, then OpenWrt firmware can be flashed via command line. There&amp;rsquo;s no need to flash the Breed u-boot, which is too risky and can cause loss of the SN.&lt;/p&gt;
&lt;h2 id=&#34;first-dial-up-setting-up-domestic-repositories&#34;&gt;First Dial-up, Setting Up Domestic Repositories
&lt;/h2&gt;&lt;p&gt;First, turn on the router, plug in the network cable, access 192.168.1.1, and set the root password on the page.&lt;/p&gt;
&lt;p&gt;In the System Software page, click Configuration, replace downloads.openwrt.org with openwrt.proxy.ustclug.org, and submit. In the Network - Interface page, edit the WAN configuration, change the protocol, and configure PPPoE internet access.&lt;/p&gt;
&lt;p&gt;Connect to the router via SSH, type opkg update in the command line. Make sure it succeeds.
Then type opkg install kmod-macvlan mwan3 luci-app-mwan3. If it doesn&amp;rsquo;t succeed, try a few more times.&lt;/p&gt;
&lt;h2 id=&#34;setting-up-a-virtual-network-card&#34;&gt;Setting Up a Virtual Network Card
&lt;/h2&gt;&lt;p&gt;Check the VLAN binding of the WAN interface, which is eth0.2. In the terminal, enter ip link add link eth0.2 name veth0 type macvlan, and then ifconfig veth0 up.&lt;/p&gt;
&lt;h2 id=&#34;binding-network-card-to-interface&#34;&gt;Binding Network Card to Interface
&lt;/h2&gt;&lt;p&gt;For convenience, modify WAN6 as our second interface, set up the second account&amp;rsquo;s PPPoE internet account, and then modify its physical setting to veth0.&lt;/p&gt;
&lt;p&gt;If the two accounts cannot dial simultaneously at this point, it means single-line dual dial is not supported.&lt;/p&gt;
&lt;h2 id=&#34;setting-hop-count&#34;&gt;Setting Hop Count
&lt;/h2&gt;&lt;p&gt;Set the use gateway metric in both the WAN and WAN6 pages. Make sure they are different, for example, one at 10 and one at 11.&lt;/p&gt;
&lt;h2 id=&#34;setting-up-load-balancing&#34;&gt;Setting Up Load Balancing
&lt;/h2&gt;&lt;p&gt;Configure the load balance settings in sequence.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/4388248-4ab82e3c830e21eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/4388248-4d33889aa0f50ac4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/4388248-b2c855543979f90d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/4388248-663f2ac3b0c03f9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/4388248-1471b0c103f8d280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/4388248-9700345d9f5cc1b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;restart-service&#34;&gt;Restart Service
&lt;/h2&gt;&lt;p&gt;Click to restart the service&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/4388248-4c7cf9d8e39f4654.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;testing&#34;&gt;Testing
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/4388248-85863aecfb262d0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Reference: &lt;a class=&#34;link&#34; href=&#34;https://acris.me/2017/06/25/Load-balancing-multiple-PPPoE-on-LEDE/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://acris.me/2017/06/25/Load-balancing-multiple-PPPoE-on-LEDE/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>Using Let&#39;s Encrypt and Nginx to Configure HTTPS Access</title>
        <link>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/%E4%BD%BF%E7%94%A8lets-encrypt%E5%92%8Cnginx%E9%85%8D%E7%BD%AEhttps%E8%AE%BF%E9%97%AE/</link>
        <pubDate>Mon, 04 Jun 2018 09:12:00 +0000</pubDate>
        
        <guid>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/%E4%BD%BF%E7%94%A8lets-encrypt%E5%92%8Cnginx%E9%85%8D%E7%BD%AEhttps%E8%AE%BF%E9%97%AE/</guid>
        <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction
&lt;/h2&gt;&lt;p&gt;To encrypt HTTP data transmission, we need to use HTTPS certificates. Let&amp;rsquo;s Encrypt provides free certificates.&lt;/p&gt;
&lt;h2 id=&#34;configure-nginx-forwarding&#34;&gt;Configure Nginx Forwarding
&lt;/h2&gt;&lt;p&gt;We need to configure Nginx on our server so that Let&amp;rsquo;s Encrypt can verify our domain.
Below is the configuration file for Nginx on my server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-nginx&#34; data-lang=&#34;nginx&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;server&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;listen&lt;/span&gt;       &lt;span style=&#34;color:#ae81ff&#34;&gt;80&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;server_name&lt;/span&gt;  &lt;span style=&#34;color:#e6db74&#34;&gt;www.unrealblue.cc&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;location&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;/&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;301&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;https://&lt;/span&gt;$host$request_uri;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;location&lt;/span&gt; ~ &lt;span style=&#34;color:#e6db74&#34;&gt;/.well-known/acme-challenge&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;root&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;/var/www/html&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;allow&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;all&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Explanation: The first location directive forwards all HTTP requests on port 80 to HTTPS connections. The second location directive means that if /.well-known is accessed, use the /var/www/html directory we provided.&lt;/p&gt;
&lt;p&gt;Save this file as default.conf.&lt;/p&gt;
&lt;p&gt;Here I used an Nginx Docker container for deployment, so I didn&amp;rsquo;t install Nginx directly.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-docker&#34; data-lang=&#34;docker&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; nginx&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;LABEL&lt;/span&gt; MAINTAINER linanwx@gmail.com&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;RUN&lt;/span&gt; apt update&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;RUN&lt;/span&gt; apt install -y certbot&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;RUN&lt;/span&gt; mkdir -p /var/www/html&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;COPY&lt;/span&gt; ./default.conf /etc/nginx/conf.d/&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;EXPOSE&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; 80:80&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;EXPOSE&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; 443:443&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;VOLUME&lt;/span&gt; [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/etc/letsencrypt/&amp;#34;&lt;/span&gt;]&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Save the first code segment as default.conf and the second code segment as Dockerfile, then run &lt;code&gt;docker build -t nginx-server .&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Run &lt;code&gt;docker run -it --rm -d -p80:80 -p443:443 --net=server-net --name nginx-server -v $PWD/letsencrypt:/etc/letsencrypt nginx-server&lt;/code&gt; to start the container in the background.&lt;/p&gt;
&lt;h2 id=&#34;generate-certificates&#34;&gt;Generate Certificates
&lt;/h2&gt;&lt;p&gt;Run &lt;code&gt;docker exec -it nginx-server /bin/bash&lt;/code&gt; to enter the container.
Run the following commands to generate the certificate:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;openssl dhparam -out /etc/letsencrypt/live/dhparams.pem 2048
certbot certonly --agree-tos -a webroot --webroot-path=/var/www/html -d www.unrealblue.cc -m linanwx@gmail.com
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The certbot program will access your domain to confirm your domain ownership, which uses the Nginx configuration from the previous step. There are also some parameters that you can understand by checking the help documentation. Additionally, unless you are certain you want to deploy to a production server, use the &amp;ndash;test-cert parameter during the testing phase, as there are limits on the number of certificates that can be generated.
Another point is generating dhparam. This is a parameter for the Diffie-Hellman key exchange protocol, which takes relatively long to generate. We will use this in Nginx later.&lt;/p&gt;
&lt;p&gt;If everything goes well, you will obtain the certificates stored in the /etc/letsencrypt/ directory. Also, because we used a volume when starting the container, the certificates will appear on the host machine.&lt;/p&gt;
&lt;h2 id=&#34;configure-nginx-https&#34;&gt;Configure Nginx HTTPS
&lt;/h2&gt;&lt;p&gt;Create a new file named https.conf:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-nginx&#34; data-lang=&#34;nginx&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# https://www.jianshu.com/p/f7f39cb24423
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;server&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;listen&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;443&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;ssl&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;server_name&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;www.unrealblue.cc&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;ssl_certificate&lt;/span&gt;                 &lt;span style=&#34;color:#e6db74&#34;&gt;/etc/letsencrypt/live/www.unrealblue.cc/fullchain.pem&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;ssl_trusted_certificate&lt;/span&gt;         &lt;span style=&#34;color:#e6db74&#34;&gt;/etc/letsencrypt/live/www.unrealblue.cc/fullchain.pem&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;ssl_certificate_key&lt;/span&gt;             &lt;span style=&#34;color:#e6db74&#34;&gt;/etc/letsencrypt/live/www.unrealblue.cc/privkey.pem&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;ssl_dhparam&lt;/span&gt;                     &lt;span style=&#34;color:#e6db74&#34;&gt;/etc/letsencrypt/live/dhparams.pem&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;ssl_ciphers&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;ssl_prefer_server_ciphers&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;on&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;ssl_protocols&lt;/span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;TLSv1&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;TLSv1.1&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;TLSv1.2&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;ssl_session_cache&lt;/span&gt;          &lt;span style=&#34;color:#e6db74&#34;&gt;shared:SSL:50m&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;ssl_session_timeout&lt;/span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;1d&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;ssl_stapling&lt;/span&gt;               &lt;span style=&#34;color:#66d9ef&#34;&gt;on&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;ssl_stapling_verify&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;on&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;add_header&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;Strict-Transport-Security&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;max-age=60&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;location&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;/&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;root&lt;/span&gt;   &lt;span style=&#34;color:#e6db74&#34;&gt;/usr/share/nginx/html&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;index&lt;/span&gt;  &lt;span style=&#34;color:#e6db74&#34;&gt;index.html&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;index.htm&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# location = /gfwlist {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;#     proxy_pass http://server-handy:8081;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;error_page&lt;/span&gt;   &lt;span style=&#34;color:#ae81ff&#34;&gt;500&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;502&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;503&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;504&lt;/span&gt;  &lt;span style=&#34;color:#e6db74&#34;&gt;/50x.html&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;location&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;/50x.html&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;root&lt;/span&gt;   &lt;span style=&#34;color:#e6db74&#34;&gt;/usr/share/nginx/html&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Save this file. Then modify the Dockerfile as follows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-dockerfile&#34; data-lang=&#34;dockerfile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; nginx&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;LABEL&lt;/span&gt; MAINTAINER linanwx@gmail.com&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;RUN&lt;/span&gt; apt update&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;RUN&lt;/span&gt; apt install -y certbot&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;RUN&lt;/span&gt; mkdir -p /var/www/html&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;COPY&lt;/span&gt; ./default.conf /etc/nginx/conf.d/&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;COPY&lt;/span&gt; ./https.conf /etc/nginx/conf.d/&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;EXPOSE&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; 80:80&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;EXPOSE&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; 443:443&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;VOLUME&lt;/span&gt; [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/etc/letsencrypt/&amp;#34;&lt;/span&gt;]&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here, the https.conf file is also copied in.&lt;/p&gt;
&lt;p&gt;Restart the container, visit https://127.0.0.1, and you can see the access is successful.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/4388248-edc2003618e67290.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;When testing in a local environment, you will be prompted that the certificate is not correct.
Click continue.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/4388248-f155d050593dadf4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image.png&#34;
	
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Learning the socat Command</title>
        <link>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/socat%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/</link>
        <pubDate>Wed, 23 May 2018 09:04:00 +0000</pubDate>
        
        <guid>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/socat%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/</guid>
        <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction
&lt;/h2&gt;&lt;p&gt;socat is a powerful and easy-to-use tool that can implement conversions between any types of sockets.&lt;/p&gt;
&lt;h2 id=&#34;usage&#34;&gt;Usage
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;socat [options] &amp;lt;address&amp;gt; &amp;lt;address&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;You can check the help documentation for options.&lt;/p&gt;
&lt;p&gt;Address can take several forms:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-&lt;/code&gt; &lt;code&gt;STDIN&lt;/code&gt; &lt;code&gt;STDOUT&lt;/code&gt;: Represents standard input/output, can be replaced with just a dash&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/var/log/syslog&lt;/code&gt;: Can also be any path (use ./ for relative paths), opens a file as a data stream&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TCP:127.0.0.1:1080&lt;/code&gt;: Establishes a TCP connection as a data stream, TCP can also be replaced with UDP&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TCP-LISTEN:12345&lt;/code&gt;: Creates a TCP listening port, TCP can also be replaced with UDP&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EXEC:/bin/bash&lt;/code&gt;: Executes a program as a data stream&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;scenario-1&#34;&gt;Scenario 1
&lt;/h2&gt;&lt;p&gt;I have a local file that I want to display in the terminal&lt;/p&gt;
&lt;p&gt;&lt;code&gt;socat - /etc/sysctl.conf&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;scenario-2&#34;&gt;Scenario 2
&lt;/h2&gt;&lt;p&gt;A TCP connection will connect, and I want to see what data will be received
&lt;code&gt;socat TCP-LISTEN:12345 -&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;scenario-3&#34;&gt;Scenario 3
&lt;/h2&gt;&lt;p&gt;I&amp;rsquo;m a hacker and I want to create a shell proxy on the target machine
&lt;code&gt;socat TCP-LISTEN:12345 EXEC:/bin/bash&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;scenario-4&#34;&gt;Scenario 4
&lt;/h2&gt;&lt;p&gt;I have a UNIX DOMAIN socket locally, and I want to convert it to a TCP SOCKET for use by machines in the local network. How do I do it?&lt;/p&gt;
&lt;p&gt;&lt;code&gt;socat TCP-LISTEN:12345,reuseaddr,fork UNIX-CONNECT:/data/deCOREIDPS/unix.domain&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;When multiple TCP connections come in, it forks one to connect to the domain socket&lt;/p&gt;
&lt;h2 id=&#34;scenario-5&#34;&gt;Scenario 5
&lt;/h2&gt;&lt;p&gt;Forward local port 80 to a remote destination&lt;/p&gt;
&lt;p&gt;&lt;code&gt;socat TCP-LISTEN:80,fork TCP:www.baidu.com:80&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Reference: &lt;a class=&#34;link&#34; href=&#34;http://brieflyx.me/2015/linux-tools/socat-introduction/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://brieflyx.me/2015/linux-tools/socat-introduction/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>Epoll Code Example - Analysis of Handy Library&#39;s Built-in epoll.cc</title>
        <link>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/epoll%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8Bhandy%E5%BA%93%E8%87%AA%E5%B8%A6epoll-cc%E5%88%86%E6%9E%90/</link>
        <pubDate>Wed, 16 May 2018 07:43:00 +0000</pubDate>
        
        <guid>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/epoll%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8Bhandy%E5%BA%93%E8%87%AA%E5%B8%A6epoll-cc%E5%88%86%E6%9E%90/</guid>
        <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction
&lt;/h2&gt;&lt;p&gt;There are many C++ network libraries. Handy is a network library with C++11 style that is very helpful for in-depth learning of C++.&lt;/p&gt;
&lt;h2 id=&#34;code-analysis&#34;&gt;Code Analysis
&lt;/h2&gt;&lt;p&gt;Below is the epoll.cc file from handy/raw_examples. It&amp;rsquo;s an example of level triggering. This HTTP server returns a static resource &amp;ldquo;123456&amp;rdquo; regardless of what kind of request it receives. Compilation: c++ -o epoll epoll.cc, execution: sudo ./epoll. The if (con.writeEnabled) statement in sendRes of the source code seems to have some issues, causing problems when sending large resources. I have modified it to correctly send large files.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/*
 * Compilation: c++ -o epoll epoll.cc
 * Execution: ./epoll
 * Testing: curl -v localhost
 */


/* 
    Running Effect
    Run the epoll program with sudo. This program listens on port 80 at 0.0.0.0 on the local machine, running as an HTTP server
    Whenever a connection accesses, it returns the static resource httpRes
    LT is the default mode

 */

#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;sys/epoll.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;map&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;iostream&amp;gt;
using namespace std;


bool output_log = true;
// A macro for printing errors and exiting
#define exit_if(r, ...) if(r) {printf(__VA_ARGS__); printf(&amp;#34;%s:%d error no: %d error msg %s\n&amp;#34;, __FILE__, __LINE__, errno, strerror(errno)); exit(1);}
// This function is used to set the specified fd to non-blocking status
void setNonBlock(int fd) {
    // First, we get the original flags of the file descriptor
    int flags = fcntl(fd, F_GETFL, 0);
    exit_if(flags&amp;lt;0, &amp;#34;fcntl failed&amp;#34;);
    // Then add O_NONBLOCK and set it back
    int r = fcntl(fd, F_SETFL, flags | O_NONBLOCK);
    exit_if(r&amp;lt;0, &amp;#34;fcntl failed&amp;#34;);
}
// A wrapper for epoll_ctl, putting events and fd into ev.
// And setting events to trigger when readable and writable
void updateEvents(int efd, int fd, int events, int op) {
    struct epoll_event ev = {0};
    ev.events = events;
    ev.data.fd = fd;
    printf(&amp;#34;%s fd %d events read %d write %d\n&amp;#34;,
           op==EPOLL_CTL_MOD?&amp;#34;mod&amp;#34;:&amp;#34;add&amp;#34;, fd, ev.events &amp;amp; EPOLLIN, ev.events &amp;amp; EPOLLOUT);
    int r = epoll_ctl(efd, op, fd, &amp;amp;ev);
    exit_if(r, &amp;#34;epoll_ctl failed&amp;#34;);
}
// Try to perform accept operation on fd. If successful, add it to the monitoring list of epoll fd. Set epoll events to trigger when data is written.
void handleAccept(int efd, int fd) {
    struct sockaddr_in raddr;
    socklen_t rsz = sizeof(raddr);
    int cfd = accept(fd,(struct sockaddr *)&amp;amp;raddr,&amp;amp;rsz);
    exit_if(cfd&amp;lt;0, &amp;#34;accept failed&amp;#34;);
    sockaddr_in peer, local;
    socklen_t alen = sizeof(peer);
    int r = getpeername(cfd, (sockaddr*)&amp;amp;peer, &amp;amp;alen);
    exit_if(r&amp;lt;0, &amp;#34;getpeername failed&amp;#34;);
    printf(&amp;#34;accept a connection from %s\n&amp;#34;, inet_ntoa(raddr.sin_addr));
    setNonBlock(cfd);
    updateEvents(efd, cfd, EPOLLIN, EPOLL_CTL_ADD);
}
// Represents a connection. Members include data read from the connection, data written
// Is it okay to use string to store binary content, what happens if \0 is encountered?
// No problem, see https://www.zhihu.com/question/33104941
struct Con {
    string readed;
    size_t written;
    bool writeEnabled;
    Con(): written(0), writeEnabled(false) {}
};
// Data structure used to map fd to con
map&amp;lt;int, Con&amp;gt; cons;

string httpRes;
// Send resources
void sendRes(int efd, int fd) {
    // First get the connection information
    Con&amp;amp; con = cons[fd];
    // Request to write when no data is received
    // This means that data sent last time might have been sent completely
    // Its corresponding file descriptor has been deleted in cons
    // Then the epoll signal was triggered
    // At this time, close its last send flag
    // Then close the buffer send trigger epoll flag
    // Only keep it triggered when there is data to read
    // Why not do this step when all data is written?
    // if (!con.readed.length()) {
    //     if (con.writeEnabled) {
    //         updateEvents(efd, fd, EPOLLIN, EPOLL_CTL_MOD);
    //         con.writeEnabled = false;
    //     }
    //     return;
    // }
    // Calculate the length of data that still needs to be written
    size_t left = httpRes.length() - con.written;
    int wd = 0;
    // Continuously write data until the kernel buffer can&amp;#39;t accept any more
    while((wd=::write(fd, httpRes.data()+con.written, left))&amp;gt;0) {
        con.written += wd;
        left -= wd;
        if(output_log) printf(&amp;#34;write %d bytes left: %lu\n&amp;#34;, wd, left);
    };
    // If there is no data to write, delete this connection. But don&amp;#39;t disconnect, just empty the connection information
    if (left == 0) {
//        close(fd); // Keepalive is used in testing, so don&amp;#39;t close the connection. The connection will be closed in the read event
        if (con.writeEnabled) {
            updateEvents(efd, fd, EPOLLIN, EPOLL_CTL_MOD);
            con.writeEnabled = false;
        }
        cons.erase(fd);
        return;
    }
    // If the kernel buffer is full, can&amp;#39;t write anymore
    if (wd &amp;lt; 0 &amp;amp;&amp;amp;  (errno == EAGAIN || errno == EWOULDBLOCK)) {
        // Mark it as can continue writing
        if (!con.writeEnabled) {
            // Wait for it to be able to continue writing, or be readable
            // Avoid repeated system calls, use con.writeEnabled flag
            printf(&amp;#34;update it to EPOLLIN|EPOLLOUT\n&amp;#34;);
            updateEvents(efd, fd, EPOLLIN|EPOLLOUT, EPOLL_CTL_MOD);
            con.writeEnabled = true;
        }
        return;
    }
    // If it&amp;#39;s other situations, such as returning 0 without completing data writing, or returning other errors
    // It means an error occurred
    if (wd&amp;lt;=0) {
        printf(&amp;#34;write error for %d: %d %s\n&amp;#34;, fd, errno, strerror(errno));
        close(fd);
        cons.erase(fd);
    }
}
// When loop_once processes read data, call this function
void handleRead(int efd, int fd) {
    char buf[4096];
    int n = 0;
    // Read 4k bytes each time, loop to read out all the data already in the kernel (information may be incomplete due to packet splitting)
    while ((n=::read(fd, buf, sizeof buf)) &amp;gt; 0) {
        if(output_log) printf(&amp;#34;read %d bytes\n&amp;#34;, n);
        // Here, use a map to get the connection information corresponding to the previous fd.
        // When the index corresponding to fd does not exist, it will call the default constructor of con: Con(): written(0), writeEnabled(false) {}
        string&amp;amp; readed = cons[fd].readed;
        // Call the append method of the string class to add data to the connection information
        // Note that parameter n needs to be passed to ensure binary safety
        readed.append(buf, n);
        std::cout  &amp;lt;&amp;lt; &amp;#34;now info is&amp;#34; &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; &amp;#34;---&amp;#34; &amp;lt;&amp;lt;  readed &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; &amp;#34;---&amp;#34; &amp;lt;&amp;lt;  std::endl;
        // Determine when an HTTP request is complete.
        // Don&amp;#39;t judge the content of the HTTP request, just send static resources
        if (readed.length()&amp;gt;4) {
            if (readed.substr(readed.length()-2, 2) == &amp;#34;\n\n&amp;#34; || readed.substr(readed.length()-4, 4) == &amp;#34;\r\n\r\n&amp;#34;) {
                // When a complete HTTP request is read, test sending a response
                // After the TCP connection is established, the client starts transmitting the header, then uses \r\n\r\n to mark the end of the header and the beginning of the entity (of course, there will be the beginning of the entity only if the request contains an entity),
                // Then the entity is transmitted, when the entity is transmitted, the client starts receiving data, the server knows, this request has ended,
                // Then the entity is that segment of data from \r\n\r\n to stopping reception. Correspondingly, the client receives the response in the same way.
                // If there is no entity, then \r\n\r\n is the end of http
                // Start writing data. Note that it may fill the buffer, if it&amp;#39;s full, continue writing later
                sendRes(efd, fd);
            }
        }
    }
    // If read cannot read, it will return -1. At this time, errno (errno belongs to the thread, it is thread-safe) is EAGAIN, which means it&amp;#39;s not all read. EWOULDBLOCK and EAGAIN are the same.
    // Then return, and wait for the next read
    if (n&amp;lt;0 &amp;amp;&amp;amp; (errno == EAGAIN || errno == EWOULDBLOCK)){
        printf(&amp;#34;nothing to read from %d, return. \n&amp;#34;, fd);
        return;
    }
    // In actual applications, n&amp;lt;0 should check various errors, such as EINTR
    if (n &amp;lt; 0) {
        printf(&amp;#34;read %d error: %d %s\n&amp;#34;, fd, errno, strerror(errno));
    }
    // Executing here, n is 0, indicating that the peer has closed the connection. At this time, we also close the connection
    printf(&amp;#34;%d close the connection\n&amp;#34;, fd);
    close(fd);
    cons.erase(fd);
}
// When the buffer can be written in loop_once, simply write our prepared static resources
void handleWrite(int efd, int fd) {
    sendRes(efd, fd);
}
// Perform one operation in a loop on an epoll handle
// Where l is the LISTEN fd
void loop_once(int efd, int lfd, int waitms) {
    // At most copy 20 events out from the kernel
    const int kMaxEvents = 20;
    struct epoll_event activeEvs[100];
    int n = epoll_wait(efd, activeEvs, kMaxEvents, waitms);
    // n is how many events were returned
    if(output_log) printf(&amp;#34;epoll_wait return %d\n&amp;#34;, n);
    for (int i = 0; i &amp;lt; n; i ++) {
        int fd = activeEvs[i].data.fd;
        int events = activeEvs[i].events;
        // EPOLLIN event or EPOLLERR event. EPOLLERR also means the pipe write ended.
        // See: http://man7.org/linux/man-pages/man2/epoll_ctl.2.html
        if (events &amp;amp; (EPOLLIN | EPOLLERR)) {
            // The EPOLLIN event is only triggered when the peer has data written, so after triggering once, you need to keep reading all the data until you finish reading EAGAIN. Otherwise, the remaining data will only be taken out together the next time the peer writes.
            // When the other party closes the connection, it is an EPOLLERR event
            if (fd == lfd) {
                printf(&amp;#34;this is accept\n&amp;#34;);
                handleAccept(efd, fd); 
            } else {
                printf(&amp;#34;this can read\n&amp;#34;);
                handleRead(efd, fd);
            }
        } else if (events &amp;amp; EPOLLOUT) {
            // This handles events if the file descriptor can be written
            // The EPOLLOUT event is only triggered once during connection, indicating it can be written
            // Afterwards, it indicates that the data in the buffer has been sent out and can continue to be written
            // See https://www.zhihu.com/question/22840801
            if(output_log) printf(&amp;#34;handling epollout\n&amp;#34;);
            handleWrite(efd, fd);
        } else {
            exit_if(1, &amp;#34;unknown event&amp;#34;);
        }
    }
}

int main(int argc, const char* argv[]) {
    if (argc &amp;gt; 1) { output_log = false; }
    /* 
Small Knowledge
signal (parameter 1, parameter 2);
Parameter 1: The signal we want to process. We can view the system signals (64 in total) by typing kill -l in the terminal. In fact, these signals are macros defined by the system.
Parameter 2: The way we handle it (system default, ignore, or capture). SIG_IGN: If the func parameter is set to SIG_IGN, the signal will be ignored.
     */
    ::signal(SIGPIPE, SIG_IGN);
    // Set the content of the HTTP response
    httpRes = &amp;#34;HTTP/1.1 200 OK\r\nConnection: Keep-Alive\r\nContent-Type: text/html; charset=UTF-8\r\nContent-Length: 19048576\r\n\r\n123456&amp;#34;;
    // Fill the rest of the content with 0. The final length of content is about 1024*1024
    for(int i=0;i&amp;lt;19048570;i++) {
        httpRes+=&amp;#39;\0&amp;#39;;
    }
    // Set the port to 80
    short port = 80;
    // Create an epoll handle
    int epollfd = epoll_create(1);
    exit_if(epollfd &amp;lt; 0, &amp;#34;epoll_create failed&amp;#34;);
    // Create a socket
    int listenfd = socket(AF_INET, SOCK_STREAM, 0);
    exit_if(listenfd &amp;lt; 0, &amp;#34;socket failed&amp;#34;);
    struct sockaddr_in addr;
    memset(&amp;amp;addr, 0, sizeof addr);
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = INADDR_ANY;
    // First bind the socket to the port
    int r = ::bind(listenfd,(struct sockaddr *)&amp;amp;addr, sizeof(struct sockaddr));
    // This step will report an error if you don&amp;#39;t have superuser permissions. Linux doesn&amp;#39;t allow non-root users to use ports below 1024
    exit_if(r, &amp;#34;bind to 0.0.0.0:%d failed %d %s&amp;#34;, port, errno, strerror(errno));
    /* 
    #include&amp;lt;sys/socket.h&amp;gt;
int listen(int sockfd, int backlog)
Return: 0‚îÄ‚îÄsuccess, -1‚îÄ‚îÄfailure
Parameter sockfd
The socket that the listen function acts on, sockfd was previously returned by the socket function. At the time when the socket function returns the socket fd, it is an active connection socket,
which means the system assumes the user will call the connect function on this socket, expecting it to actively connect with other processes, then in server programming, the user wants this socket to accept external connection requests,
that is, passively wait for users to connect. Since the system assumes by default that a socket is actively connected, it needs to be told in some way, and the user process completes this by making the system call listen.
Parameter backlog
This parameter involves some network details. While a process is handling one connection request, there may be other connection requests.
Because TCP connection is a process, there may be a half-connected state, and sometimes due to too many users trying to connect simultaneously, the server process cannot quickly complete the connection request.
If this situation occurs, how does the server process want the kernel to handle it?
The kernel will maintain a queue in its own process space to track these completed connections that the server process has not yet handled or is processing. Such a queue cannot be arbitrarily large in the kernel,
so there must be an upper limit to its size. This backlog tells the kernel to use this value as the upper limit.
Without a doubt, the server process cannot arbitrarily specify a value, the kernel has a permissible range. This range is implementation-related. It&amp;#39;s hard to have some standardization, usually this value will be less than 30.
The length of the queue used by the kernel to track these completed connections but not yet accepted by user code is set to 20 here. When the queue length is less than 20, the kernel will immediately complete the connection establishment.
But if the queue length is greater than 20, the connection will not be established before the user code calls accept, and the other party will be in a blocked state.
     */
    r = listen(listenfd, 20);
    exit_if(r, &amp;#34;listen failed %d %s&amp;#34;, errno, strerror(errno));
    printf(&amp;#34;fd %d listening at %d\n&amp;#34;, listenfd, port);
    // Next, set the file descriptor to non-blocking.
    // Why set it to non-blocking? https://www.zhihu.com/question/23614342
    setNonBlock(listenfd);
    // Set it to trigger when readable, add to the epoll file descriptor pool
    updateEvents(epollfd, listenfd, EPOLLIN, EPOLL_CTL_ADD);
    for (;;) { // Actual applications should register signal handling functions and clean up resources when exiting
        loop_once(epollfd, listenfd, 10000);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;running-effect&#34;&gt;Running Effect
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/4388248-57aa370a0545fdb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo ./epoll
fd 4 listening at 80
add fd 4 events read 1 write 0
epoll_wait return 1
this is accept
accept a connection from 127.0.0.1
add fd 5 events read 1 write 0
epoll_wait return 1
this can read
read 412 bytes
now info is
---GET / HTTP/1.1
Host: 127.0.0.1
Connection: keep-alive
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36
Upgrade-Insecure-Requests: 1
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,und;q=0.8,zh-TW;q=0.7,en;q=0.6,pl;q=0.5


---
write 4081834 bytes left: 14966851
update it to EPOLLIN|EPOLLOUT
mod fd 5 events read 1 write 4
nothing to read from 5, return.
epoll_wait return 1
handling epollout
write 2226422 bytes left: 12740429
epoll_wait return 1
handling epollout
write 2095456 bytes left: 10644973
epoll_wait return 1
handling epollout
write 1964490 bytes left: 8680483
epoll_wait return 1
handling epollout
write 1506109 bytes left: 7174374
epoll_wait return 1
handling epollout
write 1833524 bytes left: 5340850
epoll_wait return 1
handling epollout
write 1637075 bytes left: 3703775
write 130966 bytes left: 3572809
epoll_wait return 1
handling epollout
write 1571592 bytes left: 2001217
epoll_wait return 1
handling epollout
write 1440626 bytes left: 560591
epoll_wait return 1
handling epollout
write 560591 bytes left: 0
mod fd 5 events read 1 write 0
epoll_wait return 1
this can read
read 375 bytes
now info is
---GET /favicon.ico HTTP/1.1
Host: 127.0.0.1
Connection: keep-alive
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36
Accept: image/webp,image/apng,image/*,*/*;q=0.8
Referer: http://127.0.0.1/
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,und;q=0.8,zh-TW;q=0.7,en;q=0.6,pl;q=0.5


---
write 10477280 bytes left: 8571405
update it to EPOLLIN|EPOLLOUT
mod fd 5 events read 1 write 4
nothing to read from 5, return.
epoll_wait return 1
handling epollout
write 1440626 bytes left: 7130779
epoll_wait return 1
handling epollout
write 1768041 bytes left: 5362738
epoll_wait return 1
handling epollout
write 1571592 bytes left: 3791146
epoll_wait return 1
handling epollout
write 1637075 bytes left: 2154071
epoll_wait return 1
handling epollout
write 1702558 bytes left: 451513
epoll_wait return 1
handling epollout
write 451513 bytes left: 0
mod fd 5 events read 1 write 0
epoll_wait return 0
epoll_wait return 0
epoll_wait return 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here I increased the size of the resource, changing it to the following value:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    httpRes = &amp;#34;HTTP/1.1 200 OK\r\nConnection: Keep-Alive\r\nContent-Type: text/html; charset=UTF-8\r\nContent-Length: 19048576\r\n\r\n123456&amp;#34;;
    // Fill the rest of the content with 0. The final length of content is about 1024*1024
    for(int i=0;i&amp;lt;19048570;i++) {
        httpRes+=&amp;#39;\0&amp;#39;;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can see it was transmitted in multiple parts. Finally, the terminal page displays 123456, with \0 after it, which won&amp;rsquo;t be displayed.
You can see that the browser made two requests, one for the root directory and one for the page icon favicon.ico
&amp;lt;/rewritten_file&amp;gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>TCP UDP IP Maximum Message Length</title>
        <link>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/tcp-udp-ip%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E9%95%BF%E5%BA%A6/</link>
        <pubDate>Mon, 26 Mar 2018 16:41:00 +0000</pubDate>
        
        <guid>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/tcp-udp-ip%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E9%95%BF%E5%BA%A6/</guid>
        <description>&lt;h2 id=&#34;udp&#34;&gt;UDP
&lt;/h2&gt;&lt;p&gt;For UDP protocol, the maximum length of the entire packet is 65535 bytes, and the payload length is 65535-20=65515 bytes.&lt;/p&gt;
&lt;h2 id=&#34;tcp&#34;&gt;TCP
&lt;/h2&gt;&lt;p&gt;For TCP protocol, the maximum length of the entire packet is determined by the Maximum Segment Size (MSS). MSS is the maximum data segment that a TCP packet can transmit each time. To achieve optimal transmission performance, the TCP protocol usually negotiates the MSS value between both parties when establishing a connection. When implementing the TCP protocol, the MTU value is often used as a substitute (minus the size of the IP packet header of 20 bytes and the TCP segment header of 20 bytes), so the MSS is often 1460 bytes. The communicating parties will determine the maximum MSS value for this connection based on the smaller of the two MSS values provided.&lt;/p&gt;
&lt;h2 id=&#34;ip&#34;&gt;IP
&lt;/h2&gt;&lt;p&gt;For IP protocol, the size of the IP packet is determined by the MTU (Maximum Transmission Unit).&lt;/p&gt;
</description>
        </item>
        <item>
        <title>TCP Message Format and HTTP Message Format</title>
        <link>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/tcp-%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F-http%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/</link>
        <pubDate>Mon, 26 Mar 2018 16:37:00 +0000</pubDate>
        
        <guid>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/tcp-%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F-http%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F/</guid>
        <description>&lt;h2 id=&#34;tcp&#34;&gt;TCP
&lt;/h2&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Source Port  Destination Port
    Sequence Number
    Acknowledgment Number
Flags         Window
Checksum      Urgent Pointer
    Options
    Data
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;http&#34;&gt;HTTP
&lt;/h2&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Request URL Protocol-Version\r\n
Field: Value\r\n
\r\n
Body
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Protocol-Version Status-Code Status-Description\r\n
Field: Value\r\n
\r\n
Body
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>TCP UDP Connection Establishment Process via Socket</title>
        <link>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/tcp-udp-%E9%80%9A%E8%BF%87socket%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B/</link>
        <pubDate>Mon, 26 Mar 2018 14:46:00 +0000</pubDate>
        
        <guid>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/tcp-udp-%E9%80%9A%E8%BF%87socket%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B/</guid>
        <description>&lt;h2 id=&#34;tcp&#34;&gt;TCP
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Phase&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;Server&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Client&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;socket&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;socket&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;bind&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;listen&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;accept&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;connect&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;write&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;write&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;read&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;read&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;close&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;close&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;udp&#34;&gt;UDP
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Phase&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;Server&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Client&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;socket&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;socket&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;bind&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;sendto&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;recvfrom&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;recvfrom&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;sendto&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;close&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;close&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
        </item>
        <item>
        <title>HTTPS Two-way Encryption Process Analysis</title>
        <link>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/https-%E5%8F%8C%E5%90%91%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</link>
        <pubDate>Mon, 26 Mar 2018 14:42:00 +0000</pubDate>
        
        <guid>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/https-%E5%8F%8C%E5%90%91%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</guid>
        <description>&lt;p&gt;HTTPS authentication process:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;‚ë† The browser sends a connection request to the secure server.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;‚ë° The server sends its certificate and certificate-related information to the client browser.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;‚ë¢ The client browser checks whether the certificate sent by the server is issued by a trusted CA (Certificate Authority). If it is, the protocol continues execution; if not, the client browser gives the user a warning message: warning that this certificate is not trustworthy and asking whether the user wants to continue.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;‚ë£ Next, the client browser compares the information in the certificate, such as domain name and public key, with the relevant information just sent by the server. If they match, the client browser recognizes the server&amp;rsquo;s legal identity.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;‚ë§ The server requests the client to send its own certificate. After receiving it, the server verifies the client&amp;rsquo;s certificate. If it fails verification, the connection is refused; if it passes verification, the server obtains the user&amp;rsquo;s public key.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;‚ë• The client browser informs the server of the symmetric encryption methods it supports.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;‚ë¶ The server selects the encryption method with the highest level of encryption from the methods sent by the client, encrypts it with the client&amp;rsquo;s public key, and notifies the browser.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;‚ëß The browser selects a session key for this encryption method, encrypts it with the server&amp;rsquo;s public key, and sends it to the server.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;‚ë® The server receives the message sent by the browser, decrypts it with its own private key, and obtains the session key.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;‚ë© The subsequent communication between the server and browser uses the symmetric encryption method, and the symmetric key is encrypted.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The above describes the specific communication process of two-way authentication SSL protocol, which requires certificates from both the server and user. One-way authentication SSL protocol does not require the client to have a CA certificate. Compared to the steps above, it only needs to remove the process of server-side verification of the client certificate, and when negotiating the symmetric encryption method and session key, the server sends the unencrypted encryption method to the client (this does not affect the security of the SSL process). This way, the specific communication content between both parties is encrypted data. If a third party attacks and obtains the data, they only get encrypted information. For the third party to obtain useful information, they need to decrypt the encrypted data, and at this point, security depends on the security of the encryption method. Fortunately, the current encryption methods are sufficiently secure as long as the communication key is long enough. This is why we emphasize the requirement to use 128-bit encrypted communication.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Select, Poll, Epoll: A Brief Introduction</title>
        <link>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/select-poll-epoll-%E7%AE%80%E6%98%8E%E4%BB%8B%E7%BB%8D/</link>
        <pubDate>Mon, 12 Mar 2018 13:19:00 +0000</pubDate>
        
        <guid>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/select-poll-epoll-%E7%AE%80%E6%98%8E%E4%BB%8B%E7%BB%8D/</guid>
        <description>&lt;p&gt;Source: &lt;a class=&#34;link&#34; href=&#34;https://cloud.tencent.com/developer/article/1005481&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cloud.tencent.com/developer/article/1005481&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;function-introduction&#34;&gt;Function Introduction
&lt;/h1&gt;&lt;h2 id=&#34;select&#34;&gt;select
&lt;/h2&gt;&lt;p&gt;Function prototype:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;fd_set is a set containing file descriptors, represented as a bitmap with n bits. This means that every call involves copying the file descriptor set to the kernel.&lt;/p&gt;
&lt;h2 id=&#34;poll&#34;&gt;poll
&lt;/h2&gt;&lt;p&gt;Function prototype:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int poll (struct pollfd *fds, unsigned int nfds, int timeout);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Unlike select which uses three bitmaps to represent three fdsets, poll uses an array of pollfd. It takes the length of this array and a timeout value as parameters.&lt;/p&gt;
&lt;h2 id=&#34;epoll&#34;&gt;epoll
&lt;/h2&gt;&lt;p&gt;epoll was introduced in the 2.6 kernel and is an enhanced version of the previous select and poll.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int epoll_create(int size); //creates an epoll handle, size tells the kernel how large this monitoring set will be
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;epoll_create is used to create an epoll handle. The size parameter is a suggestion to the kernel about how many file descriptors to pre-allocate, but it doesn&amp;rsquo;t limit the actual number in operation.
epoll_ctl controls the epoll handle, allowing us to add, delete, or modify file descriptors. The separation of ctl from epoll_wait means we only need to copy the event set once.
epoll_wait is used to get the set of events received from the kernel.&lt;/p&gt;
&lt;h1 id=&#34;socket-events&#34;&gt;socket events
&lt;/h1&gt;&lt;p&gt;In the Linux 2.6 kernel events, a wakeup callback mechanism is set up. When a socket is waiting for an event to occur, it&amp;rsquo;s managed by the kernel&amp;rsquo;s socket sleep queue. When a socket event occurs, the kernel sequentially traverses each process on the socket sleep queue and notifies it of the event. During notification, it sequentially calls the callback function for that event.&lt;/p&gt;
&lt;h2 id=&#34;the-original-select&#34;&gt;The original select
&lt;/h2&gt;&lt;p&gt;select was initially just a simple implementation to try to solve the problem of checking multiple file descriptors.&lt;/p&gt;
&lt;h3 id=&#34;what-does-select-do&#34;&gt;What does select do?
&lt;/h3&gt;&lt;p&gt;After a select call, it does the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Copies the file descriptor sets passed as parameters to kernel space&lt;/li&gt;
&lt;li&gt;Iterates through the file descriptors to check if there are any readable events; if there are, it returns&lt;/li&gt;
&lt;li&gt;If there are no readable file descriptors, it begins to sleep, waiting for kernel socket events to occur&lt;/li&gt;
&lt;li&gt;When awakened, it checks again to determine which file descriptor triggered the operation&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;what-are-the-problems-with-select&#34;&gt;What are the problems with select?
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Each call to socket copies the data to kernel space, which is inefficient&lt;/li&gt;
&lt;li&gt;When any socket is awakened, all sockets need to be traversed, wasting time&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;how-can-select-be-improved&#34;&gt;How can select be improved?
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;The monitored fds set is limited to 1024, which is too small; we want a larger set of fds to monitor&lt;/li&gt;
&lt;li&gt;The fds set needs to be copied from user space to kernel space; we hope to avoid this copying&lt;/li&gt;
&lt;li&gt;When some of the monitored fds have readable data, we want more precise notifications; we want to get a list of fds with readable events from the notification, rather than having to traverse the entire fds set to collect them.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;the-lackluster-poll&#34;&gt;The lackluster poll
&lt;/h2&gt;&lt;p&gt;poll only solves the first problem: the 1024 size limitation of fds. It&amp;rsquo;s merely a change in the interface of the parameters being passed.&lt;/p&gt;
&lt;h2 id=&#34;the-mature-epoll&#34;&gt;The mature epoll
&lt;/h2&gt;&lt;p&gt;epoll solves the second and third problems.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;For the second problem&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Breaking down function calls and further subdividing them
For I/O multiplexing, we find that each call to select or poll repeatedly prepares (processes collectively) the entire set of fds that needs to be monitored. However, for frequently called select or poll, the frequency of changes in the fds set is much lower, so there&amp;rsquo;s no need to re-prepare (process collectively) the entire fds set each time.
So, epoll introduces the epoll_ctl system call to separate the high-frequency epoll_wait from the low-frequency epoll_ctl. At the same time, epoll_ctl uses three operations (EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL) to distribute modifications to the monitored fds set, ensuring changes only happen when necessary. This turns the high-frequency, large memory copy (collective processing) of select or poll into low-frequency, small memory copy (distributed processing) of epoll_ctl, avoiding a large amount of memory copying.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Using a red-black tree
Additionally, epoll uses epoll_ctl to add, delete, or modify the monitored fds set, which must involve fast fd lookup. Therefore, a data structure with low time complexity for adding, deleting, modifying, and querying is essential to organize the monitored fds set. In Linux kernel versions before 2.6.8, epoll used a hash to organize the fds set, so when creating an epoll fd, epoll needed to initialize the hash size. Hence, epoll_create(int size) had a parameter &amp;lsquo;size&amp;rsquo; to allow the kernel to allocate the hash size based on it. In Linux kernel versions 2.6.8 and later, epoll uses a red-black tree to organize the monitored fds set, so the &amp;lsquo;size&amp;rsquo; parameter in epoll_create(int size) is actually meaningless.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For the third problem&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Using a callback mechanism
From the socket sleep queue wakeup logic above, we know that when a socket wakes up a wait_entry (process) sleeping in its sleep queue, it calls the wait_entry&amp;rsquo;s callback function, and we can do anything in this callback. To achieve traversal of only the ready fds, we need a place to organize those fds that are already ready. For this, epoll introduces an intermediate layer: a doubly linked list (ready_list), a separate sleep queue (single_epoll_wait_list). Unlike select or poll, epoll&amp;rsquo;s process doesn&amp;rsquo;t need to be inserted into all the sleep queues of the socket set for multiplexing. Instead, the process is only inserted into epoll&amp;rsquo;s separate sleep queue; the process sleeps on epoll&amp;rsquo;s separate queue, waiting for events to occur. At the same time, an intermediate wait_entry_sk is introduced, which is closely related to a specific socket sk. wait_entry_sk sleeps on the sk&amp;rsquo;s sleep queue, and its callback function logic is to put the current sk into epoll&amp;rsquo;s ready_list and wake up epoll&amp;rsquo;s single_epoll_wait_list. The callback function of the process sleeping on single_epoll_wait_list becomes clear: traverse all sks on the ready_list, call the poll function of each sk to collect events, and then wake up the process to return from epoll_wait.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;finally-edge-triggering-vs-level-triggering&#34;&gt;Finally, Edge Triggering vs. Level Triggering
&lt;/h2&gt;&lt;p&gt;When discussing Epoll, we can&amp;rsquo;t ignore the two modes of Epoll events. Here are the basic concepts of the two modes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Edge Triggered (ET)
.Read events are triggered when the state of the socket&amp;rsquo;s receive buffer changes, i.e., when the empty receive buffer just receives data
.Write events are triggered when the state of the socket&amp;rsquo;s send buffer changes, i.e., when the full buffer just frees up space
Events are only triggered when the buffer state changes, such as when the data buffer changes from empty to containing data (unreadable to readable)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Level Triggered (LT)
.As long as the socket&amp;rsquo;s receive buffer is not empty and has data to read, the read event continues to trigger
.As long as the socket&amp;rsquo;s send buffer is not full and can continue to write data, the write event continues to trigger
This conforms to intuitive thinking; the events returned by epoll_wait represent the socket&amp;rsquo;s state&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>HTTP Long and Short Connections</title>
        <link>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/http%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5/</link>
        <pubDate>Wed, 07 Mar 2018 03:15:00 +0000</pubDate>
        
        <guid>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/http%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5/</guid>
        <description>&lt;h2 id=&#34;the-relationship-between-http-protocol-and-tcpip-protocol&#34;&gt;The Relationship Between HTTP Protocol and TCP/IP Protocol
&lt;/h2&gt;&lt;p&gt;HTTP long and short connections are essentially TCP long and short connections. HTTP is an application layer protocol that uses TCP protocol at the transport layer and IP protocol at the network layer. The IP protocol mainly solves network routing and addressing issues, while the TCP protocol mainly solves how to reliably deliver data packets over the IP layer, ensuring that all packets sent from one end are received at the other end of the network in the same order as they were sent. TCP has reliable, connection-oriented characteristics.&lt;/p&gt;
&lt;h2 id=&#34;understanding-why-http-protocol-is-stateless&#34;&gt;Understanding Why HTTP Protocol is Stateless
&lt;/h2&gt;&lt;p&gt;The HTTP protocol is stateless, meaning that the protocol has no memory capability for transaction processing, and the server doesn&amp;rsquo;t know what state the client is in. In other words, there is no connection between opening a webpage on a server and previously opening a webpage on that server. HTTP is a stateless connection-oriented protocol. Being stateless doesn&amp;rsquo;t mean that HTTP cannot maintain a TCP connection, and it certainly doesn&amp;rsquo;t mean that HTTP uses the UDP protocol (connectionless).&lt;/p&gt;
&lt;h2 id=&#34;what-are-long-connections-and-short-connections&#34;&gt;What are Long Connections and Short Connections?
&lt;/h2&gt;&lt;p&gt;In HTTP/1.0, short connections are used by default. This means that the browser and server establish a connection for each HTTP operation, but the connection is terminated once the task is completed. If a client browser accesses an HTML or other type of Web page that contains other Web resources such as JavaScript files, image files, CSS files, etc., the browser will establish an HTTP session each time it encounters such a Web resource. However, from HTTP/1.1 onwards, long connections are used by default to maintain connection characteristics. HTTP protocols using long connections will add this line of code to the response header: &lt;code&gt;Connection:keep-alive&lt;/code&gt;. In the case of using a long connection, when a webpage is fully opened, the TCP connection used to transmit HTTP data between the client and server will not close. If the client accesses the webpage on this server again, it will continue to use this already established connection. Keep-Alive will not permanently maintain the connection; it has a retention time that can be set in different server software (such as Apache). Both the client and server must support long connections to implement them. The long and short connections of the HTTP protocol are essentially the long and short connections of the TCP protocol.&lt;/p&gt;
&lt;h2 id=&#34;tcp-connection&#34;&gt;TCP Connection
&lt;/h2&gt;&lt;p&gt;When using TCP protocol for network communication, a connection must be established between the server and client before any actual read/write operations. When the read/write operations are completed and both parties no longer need this connection, they can release it. Establishing a connection requires a three-way handshake, while releasing it requires a four-way handshake, so establishing each connection consumes resources and time.&lt;/p&gt;
&lt;h2 id=&#34;tcp-short-connection&#34;&gt;TCP Short Connection
&lt;/h2&gt;&lt;p&gt;Let&amp;rsquo;s simulate a short connection scenario. The client initiates a connection to the server, the server accepts the client connection, and both parties establish a connection. After the client and server complete a read/write operation, their connection is actively closed.&lt;/p&gt;
&lt;h2 id=&#34;tcp-long-connection&#34;&gt;TCP Long Connection
&lt;/h2&gt;&lt;p&gt;Now let&amp;rsquo;s simulate a long connection scenario. The client initiates a connection to the server, the server accepts the client connection, and both parties establish a connection. After the client and server complete a read/write operation, their connection is not actively closed, and subsequent read/write operations will continue to use this connection.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s first talk about the TCP keepalive function mentioned in TCP/IP in Detail. The keepalive function is mainly provided for server applications. Server applications want to know whether the client host has crashed, so they can use resources on behalf of the client. If the client has disappeared, leaving a half-open connection on the server, and the server is waiting for data from the client, the server will wait indefinitely for client data. The keepalive function attempts to detect such half-open connections on the server side.&lt;/p&gt;
&lt;p&gt;If a given connection has no activity for two hours, the server sends a probe segment to the client. The client host must be in one of the following four states:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The client host is still running normally and is reachable from the server. The client&amp;rsquo;s TCP responds normally, and the server knows that the other party is normal. The server resets the keepalive timer after two hours.&lt;/li&gt;
&lt;li&gt;The client host has crashed and is either shut down or restarting. In either case, the client&amp;rsquo;s TCP does not respond. The server will not receive a response to the probe and will time out after 75 seconds. The server sends a total of 10 such probes, each at an interval of 75 seconds. If the server does not receive a response, it assumes that the client host is closed and terminates the connection.&lt;/li&gt;
&lt;li&gt;The client host has crashed and has restarted. The server will receive a response to its keepalive probe, which is a reset, causing the server to terminate the connection.&lt;/li&gt;
&lt;li&gt;The client is running normally, but the server is unreachable. This situation is similar to category 2; TCP can only discover that it has not received a response to the probe.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;how-to-choose-between-long-and-short-connections&#34;&gt;How to Choose Between Long and Short Connections
&lt;/h2&gt;&lt;p&gt;Long connections are often used for frequent operations, point-to-point communications, and situations where the number of connections cannot be too many. Each TCP connection requires a three-way handshake, which takes time. If each operation first establishes a connection and then operates, processing speed will be reduced significantly. So, if the connection is not disconnected after each operation, subsequent processing can directly send data packets without establishing a TCP connection. For example, database connections use long connections. Using short connections for frequent communication will cause socket errors, and frequent socket creation is also a waste of resources.&lt;/p&gt;
&lt;p&gt;Web services like HTTP websites generally use short connections because long connections consume certain resources on the server side. For websites with such frequent connections from thousands or even millions of clients, using short connections saves resources. If long connections were used, and there were thousands of users at the same time, each user occupying one connection would be unimaginable. Therefore, short connections are better for situations with high concurrency but where each user does not need frequent operations.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Epoll TCP Server and Client Simple Example</title>
        <link>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/epoll-tcp%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AE%80%E6%98%8E%E4%BE%8B%E5%AD%90/</link>
        <pubDate>Mon, 25 Dec 2017 02:52:00 +0000</pubDate>
        
        <guid>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/epoll-tcp%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AE%80%E6%98%8E%E4%BE%8B%E5%AD%90/</guid>
        <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction
&lt;/h2&gt;&lt;p&gt;epoll is a Linux-specific API that provides efficient file descriptor management. It&amp;rsquo;s commonly used to monitor the readability of multiple file descriptors in batch and is one of the effective methods for high-concurrency servers. Below is a simple example of an epoll server and client.&lt;/p&gt;
&lt;h2 id=&#34;server-side&#34;&gt;Server Side
&lt;/h2&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/epoll.h&amp;gt;

using namespace std;

const int MAX_EPOLL_EVENTS = 1000;
const int MAX_MSG_LEN = 1024;

void setFdNonblock(int fd)
{
    fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) | O_NONBLOCK);
}

void err_exit(const char *s){
    printf(&amp;#34;error: %s\n&amp;#34;,s);
    exit(0);
}

int create_socket(const char *ip, const int port_number)
{
    struct sockaddr_in server_addr = {0};
    /* Set IPv4 mode */
    server_addr.sin_family = AF_INET;           /* ipv4 */
    /* Set port number */
    server_addr.sin_port = htons(port_number);
    /* Set host address */
    if(inet_pton(server_addr.sin_family, ip, &amp;amp;server_addr.sin_addr) == -1){
        err_exit(&amp;#34;inet_pton&amp;#34;);
    }
    /* Create socket */
    int sockfd = socket(PF_INET, SOCK_STREAM, 0);
    if(sockfd == -1){
        err_exit(&amp;#34;socket&amp;#34;);
    }
    /* Set reuse mode */
    int reuse = 1;
    if(setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;amp;reuse, sizeof(reuse)) == -1)
    {
        err_exit(&amp;#34;setsockopt&amp;#34;);
    }
    /* Bind to port */
    if(bind(sockfd, (sockaddr *)&amp;amp;server_addr, sizeof(server_addr)) == -1){
        err_exit(&amp;#34;bind&amp;#34;);
    }
    /* Set passive open */
    if(listen(sockfd, 5) == -1){
        err_exit(&amp;#34;listen&amp;#34;);
    }
    return sockfd;
}

int main(int argc, const char *argv[])
{
    /* Help message */
    if(argc &amp;lt; 3){
        printf(&amp;#34;usage:%s ip port\n&amp;#34;, argv[0]);
        exit(0);
    }
    /* Get server parameters */
    const char * ip = argv[1];
    const int port = atoi(argv[2]);
    /* Create socket */
    int sockfd = create_socket(ip, port);
    printf(&amp;#34;success create sockfd %d\n&amp;#34;, sockfd);
    setFdNonblock(sockfd);
    /* Create epoll */
    int epollfd = epoll_create1(0);
    if(epollfd == -1) err_exit(&amp;#34;epoll_create1&amp;#34;);
    /* Add sockfd to epollfd interest list */
    struct epoll_event ev;
    ev.data.fd = sockfd;
    ev.events = EPOLLIN ;
    if(epoll_ctl(epollfd, EPOLL_CTL_ADD, sockfd, &amp;amp;ev) == -1){
        err_exit(&amp;#34;epoll_ctl1&amp;#34;);
    }
    /* Create a list to store events returned by wait */
    struct epoll_event events[MAX_EPOLL_EVENTS] = {0};
    /* Start waiting for all events registered on epoll */

    while(1){
        /* Wait for events */
        printf(&amp;#34;begin wait\n&amp;#34;);
        int number = epoll_wait(epollfd, events, MAX_EPOLL_EVENTS, -1);
        printf(&amp;#34;end wait\n&amp;#34;);
        sleep(1);
        if(number &amp;gt; 0){
            /* Traverse all events */
            for (int i = 0; i &amp;lt; number; i++)
            {
                int eventfd = events[i].data.fd;
                /* If the fd triggering the event is sockfd, someone has connected, and we need to accept them */
                if(eventfd == sockfd){
                    printf(&amp;#34;accept new client...\n&amp;#34;);
                    struct sockaddr_in client_addr;
                    socklen_t client_addr_len = sizeof(client_addr);
                    int connfd = accept(sockfd, (struct sockaddr *)&amp;amp;client_addr, &amp;amp;client_addr_len);
                    setFdNonblock(connfd);
                    /* After accept, we need to add the file descriptor to the monitoring list */
                    struct epoll_event ev;
                    ev.data.fd = connfd;
                    ev.events = EPOLLIN;
                    if(epoll_ctl(epollfd, EPOLL_CTL_ADD, connfd, &amp;amp;ev) == -1){
                        err_exit(&amp;#34;epoll_ctl2&amp;#34;);
                    }
                    printf(&amp;#34;accept new client end.\n&amp;#34;);
                }
                /* If the triggering fd is not sockfd, it&amp;#39;s the newly added connfd */
                else{
                    /* Read content until encountering a newline, then display the content */
                    printf(&amp;#34;read start...\n&amp;#34;);
                    while(1){
                        char buff = -1;
                        int ret = read(eventfd, &amp;amp;buff, 1);
                        if(ret &amp;gt; 0){
                            printf(&amp;#34;%c&amp;#34;, buff);
                        }
                        if(buff == &amp;#39;\n&amp;#39;){
                            break;
                        }
                        else if (ret == 0){
                            printf(&amp;#34;client close.\n&amp;#34;);
                            close(eventfd);
                            epoll_ctl(epollfd, EPOLL_CTL_DEL, eventfd, NULL);
                            break;
                        }
                        else if (ret &amp;lt; 0){
                            printf(&amp;#34;read error.\n&amp;#34;);
                            break;
                        }
                    }
                    printf(&amp;#34;read end.\n&amp;#34;);
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;client-side&#34;&gt;Client Side
&lt;/h2&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;iostream&amp;gt;

using namespace std;

void err_exit(const char *s){
    printf(&amp;#34;error: %s\n&amp;#34;,s);
    exit(0);
}

int create_socket(const char *ip, const int port_number)
{
    struct sockaddr_in server_addr = {0};
    /* Set IPv4 mode */
    server_addr.sin_family = AF_INET;           /* ipv4 */
    /* Set port number */
    server_addr.sin_port = htons(port_number);
    /* Set host address */
    if(inet_pton(PF_INET, ip, &amp;amp;server_addr.sin_addr) == -1){
        err_exit(&amp;#34;inet_pton&amp;#34;);
    }

    /* Create socket */
    int sockfd = socket(PF_INET, SOCK_STREAM, 0);
    if(sockfd == -1){
        err_exit(&amp;#34;socket&amp;#34;);
    }

    if(connect(sockfd, (struct sockaddr*)&amp;amp;server_addr, sizeof(server_addr)) == -1){
        err_exit(&amp;#34;connect&amp;#34;);
    }

    return sockfd;
}

int main(int argc, const char *argv[]){
    if(argc &amp;lt; 3){
        printf(&amp;#34;usage:%s ip port\n&amp;#34;, argv[0]);
        exit(0);
    }
    /* Get server parameters */
    const char * ip = argv[1];
    const int port = atoi(argv[2]);
    //Create socket
    int sock = create_socket(ip, port);
    //Initiate request to server (specific IP and port)
    
    while(1){
        string buff;
        getline(cin, buff);
        if(buff == &amp;#34;exit&amp;#34;) break;
        write(sock, buff.c_str(), buff.size());
        char end = &amp;#39;\n&amp;#39;;
        write(sock, &amp;amp;end, 1);
    }
    close(sock);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;compilation&#34;&gt;Compilation
&lt;/h2&gt;&lt;p&gt;Save the above text as socket_server.cpp and socket_client.cpp, then compile and link the programs.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;g++ -Wall socket_server.cpp -o server &amp;amp;&amp;amp; g++ -Wall socket_client.cpp -o client
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;execution&#34;&gt;Execution
&lt;/h2&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;./server localhost 1234
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;./client localhost 1234
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Entering text on the client side and pressing Enter will display it on the server side. Press Ctrl+C or type &amp;ldquo;exit&amp;rdquo; to close the client.&lt;/p&gt;
&lt;h2 id=&#34;execution-flow&#34;&gt;Execution Flow
&lt;/h2&gt;&lt;p&gt;The server first creates a passive open socket file descriptor, then adds this file descriptor to the epoll interest list. It then enters a loop. Whenever the interest list&amp;rsquo;s wait ends, it means the corresponding file descriptor can be operated on. When a client connects to the passive open socket file descriptor, it indicates a client has connected, and the passive open file descriptor can be accepted. The new file descriptor created after accept is the file descriptor for communicating with the client, which is also added to the interest list. When the client sends data, this file descriptor will also generate a readable signal, causing the wait to end. At this point, it enters processing mode, reading and displaying the data sent by the client.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>SOCKET Learning Notes</title>
        <link>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/socket-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Mon, 25 Dec 2017 02:34:00 +0000</pubDate>
        
        <guid>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/socket-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction
&lt;/h2&gt;&lt;p&gt;Interview questions mentioning epoll involve socket programming. To understand epoll principles in depth, we first need to understand socket programming. A socket is an inter-process communication (IPC) mechanism, even in networks. This means the main entities communicating in a network are processes, not computers. Socket learning includes how to establish servers and clients, and how to use socket APIs.&lt;/p&gt;
&lt;h4 id=&#34;fdsocketdomain-type-protocol&#34;&gt;fd=socket(domain, type, protocol);
&lt;/h4&gt;&lt;p&gt;The socket call can be used to create a socket, for example,
domain can specify IPv4, type can specify TCP, and protocol is generally 0.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;domain
domain specifies the communication scope and the type of communication address. There are several classic types:
UNIX IPV4 IPV6, corresponding to parameters AF_UNIX AF_INET AF_INET6.
The domain parameters all start with AF, representing address families. PF stands for protocol families. Originally, address families and protocol families were designed to have many-to-many relationships, but during implementation, each protocol family corresponds to exactly one address family. So basically, specifying the domain determines the protocol family and the address family.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;type
Socket indicates whether it&amp;rsquo;s a stream or a datagram, which essentially means TCP or UDP. For TCP, it&amp;rsquo;s SOCK_STREAM; for UDP, it&amp;rsquo;s SOCK_DGRAM.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;bindint-sockfd-const-struct-sockaddr-addr-socklen_t-addrlen&#34;&gt;bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
&lt;/h4&gt;&lt;p&gt;This call is used to bind a socket to an address. After that, TCP packets can be sent, and in some cases, UDP packets can also be sent through write, but only data from the peer socket can be read on this socket.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sockaddr
This structure has an integer representing the address type, followed by a char array. As we&amp;rsquo;ll see, depending on the use case, other data structures are passed in, but they are generic.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;listenint-sockfd-int-backlog&#34;&gt;listen(int sockfd, int backlog)
&lt;/h4&gt;&lt;p&gt;Marks a socket descriptor as passive. It can be connected by active sockets. backlog is used to limit the number of pending connections.&lt;/p&gt;
&lt;h4 id=&#34;acceptint-sockfd-struct-sockaddr-addr-socklen_t--addrlen&#34;&gt;accept(int sockfd, struct sockaddr *addr, socklen_t * addrlen);
&lt;/h4&gt;&lt;p&gt;The accept call blocks and waits for an incoming request on the file descriptor sockfd. Once the request succeeds, a new socket is created, and this new socket connects with the other party.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;addr
Returns the address of the other party&lt;/li&gt;
&lt;li&gt;addrlen
Passes in the length of addr, indicating the maximum length that can be written.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;connectint-sockfd-const-struct-sockaddr--addr-socklen_t-addrlen&#34;&gt;connect(int sockfd, const struct sockaddr * addr, socklen_t addrlen);
&lt;/h4&gt;&lt;p&gt;Connects sockfd to the address described by addr.&lt;/p&gt;
&lt;h4 id=&#34;closeint-fd&#34;&gt;close(int fd)
&lt;/h4&gt;&lt;p&gt;Used to close the connection&lt;/p&gt;
&lt;h4 id=&#34;read-write&#34;&gt;read write
&lt;/h4&gt;&lt;p&gt;Used for reading from or writing to sockfd&lt;/p&gt;
&lt;h4 id=&#34;recvfromint-sockfd-void-buffer-size_t-length-int-flags-struct-sockaddr-src_addr-socklen_t-addrlen&#34;&gt;recvfrom(int sockfd, void *buffer, size_t length, int flags, struct sockaddr *src_addr, socklen_t *addrlen);
&lt;/h4&gt;&lt;h4 id=&#34;sendtoint-sockfd-const-void-buffer-size_t-length-int-flags-const-struct-sockaddr-dest_addr-socklen_t-addrlen&#34;&gt;sendto(int sockfd, const void *buffer, size_t length, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);
&lt;/h4&gt;&lt;p&gt;Used to send and receive UDP packets. The server side cannot use the listen function and accept function, and the client side cannot use the connect function.&lt;/p&gt;
&lt;h4 id=&#34;unix-domain&#34;&gt;unix domain
&lt;/h4&gt;&lt;p&gt;Using the APIs above, communication through files on the local machine can be implemented.
The sockaddr used by unix domain is sockaddr_un, represented as follows:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct sockaddr_un{
    sa_family_t sun_family;
    char sun_path[108];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;network-byte-order&#34;&gt;Network Byte Order
&lt;/h4&gt;&lt;p&gt;The network byte order follows big-endian, while x86 is a little-endian structure. The conversion is done using the following functions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;htons&lt;/li&gt;
&lt;li&gt;htonl&lt;/li&gt;
&lt;li&gt;ntohs&lt;/li&gt;
&lt;li&gt;ntohl
h is for host, n is for net, s is for 16-bit, and l is for 32-bit. s and l stand for short and long, although these standards are no longer used that way now.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;internet-socket-address-structure&#34;&gt;Internet Socket Address Structure
&lt;/h4&gt;&lt;p&gt;The socket address used in networks is sockaddr_in, defined as follows:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct sockaddr_in{
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;
    unsigned char __pad[X];
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, the difference is that the char array is replaced by a port and an address. sin is the abbreviation of socket Internet, which is as poor an abbreviation as sun.&lt;/p&gt;
&lt;h4 id=&#34;internet-socket-address-conversion&#34;&gt;Internet Socket Address Conversion
&lt;/h4&gt;&lt;p&gt;APIs for converting string address formats to binary address formats:&lt;/p&gt;
&lt;h4 id=&#34;inet_ptonint-domain-const-char-src-void-addrptr&#34;&gt;inet_pton(int domain, const char *src, void *addrptr);
&lt;/h4&gt;&lt;p&gt;This function is used to convert the string contained in src to a &lt;strong&gt;network byte order&lt;/strong&gt; binary address, storing it in addrptr. p stands for presentation, meaning a human-readable address.&lt;/p&gt;
&lt;h4 id=&#34;const-char--inet_ntopint-domain-const-void-addrptr-char-dst_str-size_t-len&#34;&gt;const char * inet_ntop(int domain, const void *addrptr, char *dst_str, size_t len);
&lt;/h4&gt;&lt;p&gt;This function converts a network byte order binary address to a human-readable address, writing it to dst_str. The buffer size is passed in by len.&lt;/p&gt;
&lt;h4 id=&#34;getaddrinfoconst-char-host-const-char-service-const-struct-addrinfo-hints-struct-result&#34;&gt;getaddrinfo(const char *host, const char *service, const struct addrinfo *hints, struct **result);
&lt;/h4&gt;&lt;p&gt;This function returns a socket address and port number given a host name and service name.
getaddrinfo takes host, service, and hints as inputs, where the host parameter includes a hostname or an IPv4 string. Service is a service name or a port number. After calling this function, freeaddrinfo should be used to free the space.&lt;/p&gt;
&lt;h4 id=&#34;getnameinfoconst-struct-sockaddr-addr-socklen_t-addrlen-char-host-size_t-hostlen-char-service-size_t-servlen-int-flags&#34;&gt;getnameinfo(const struct sockaddr *addr, socklen_t addrlen, char *host, size_t hostlen, char *service, size_t servlen, int flags);
&lt;/h4&gt;&lt;p&gt;Given a socket address structure, returns a host and service name string.&lt;/p&gt;
&lt;h4 id=&#34;setsockoptint-sockfd-int-level-int-optname-const-void-optval-socklen_t-optlen&#34;&gt;setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
&lt;/h4&gt;&lt;p&gt;sockfd is the file descriptor pointing to the socket. The level parameter specifies the protocol to which the socket option applies, such as TCP or IP, indicating the socket API layer where the option takes effect. Generally, this option is set to SOL_SOCKET, indicating that it applies to the socket API layer. The optname parameter indicates the option we expect to set, optvalue is used to set the value of that option, which can be an integer or a pointer to a structure pointing to a buffer, and the optlen parameter is the size of the region pointed to by that pointer.&lt;/p&gt;
&lt;p&gt;For example, to set sockfd to the reuseaddr property, you can call:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    int reuse = 1;
    if(setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;amp;reuse, sizeof(reuse)) == -1)
    {
        err_exit(&amp;#34;setsockopt&amp;#34;);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;getsockoptint-sockfd-int-level-int-optname-void-optval-socklen_t-optlen&#34;&gt;getsockopt(int sockfd, int level, int optname, void *optval, socklen_t optlen);
&lt;/h4&gt;&lt;p&gt;The usage is the same as above, but it&amp;rsquo;s for getting rather than setting.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Other I/O Models Summary</title>
        <link>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/%E5%85%B6%E4%BB%96-i-o-%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/</link>
        <pubDate>Thu, 21 Dec 2017 06:18:00 +0000</pubDate>
        
        <guid>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/%E5%85%B6%E4%BB%96-i-o-%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/</guid>
        <description>&lt;ul&gt;
&lt;li&gt;I/O Multiplexing&lt;/li&gt;
&lt;li&gt;Signal-Driven I/O&lt;/li&gt;
&lt;li&gt;Linux-specific epoll&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;io-multiplexing&#34;&gt;I/O Multiplexing
&lt;/h2&gt;&lt;p&gt;File descriptors are examined through the select system call or the poll system call.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;select function
&lt;code&gt;int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout);&lt;/code&gt;
The parameters respectively mean: the range of file descriptors to test (0 to fd-1), file descriptors that meet three different condition requirements, and timeout period.&lt;/li&gt;
&lt;li&gt;poll function
&lt;code&gt;int poll(struct pollfd fds[], nfds_t nfds, int timeout);&lt;/code&gt;
The parameters are: an array containing elements with file descriptors, states to be checked, returned states; the array length; and the timeout period.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The difference between the two is that the array size passed into poll is not limited by the size defined by fd_set. Poll&amp;rsquo;s events and revents are a bit more versatile. Select is used more widely. In newer versions, select&amp;rsquo;s performance has been optimized to be comparable to poll.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;epoll function
The epoll function includes three APIs: epoll_create(), epoll_ctl(), and epoll_wait().
Among the three calls, epoll has the best performance and most effectiveness. However, it can only be used on Linux.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is mainly because a server will have multiple socket connections, and if a thread were created for each socket, it would consume considerable resources. Therefore, epoll is needed to optimize performance.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Building a Personal Blog with Flask</title>
        <link>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/%E5%9F%BA%E4%BA%8Eflask%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</link>
        <pubDate>Sun, 30 Jul 2017 17:38:00 +0000</pubDate>
        
        <guid>https://nansenli.com/post/jianshu/%E7%BD%91%E7%BB%9C/%E5%9F%BA%E4%BA%8Eflask%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</guid>
        <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction
&lt;/h2&gt;&lt;p&gt;The source code can be run directly, supports markdown syntax, supports email registration, and any issues can be referenced in &lt;a class=&#34;link&#34; href=&#34;https://book.douban.com/subject/26274202/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;„ÄäFlask Web Development: Web Application Development in Action with Python„Äã&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Blog website: &lt;a class=&#34;link&#34; href=&#34;http://www.unrealblue.cc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.unrealblue.cc&lt;/a&gt;
Project repository: &lt;a class=&#34;link&#34; href=&#34;https://github.com/linanwx/unrealblue-blog&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/linanwx/unrealblue-blog&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;preview&#34;&gt;Preview
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/4388248-14b7a806bb06cf9a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/4388248-2c73dba03a62ae14.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;markdown syntax&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/4388248-90a191e0ee2bc604.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;login&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/4388248-6cad70a486daaeea.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;homepage&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;deployment-process&#34;&gt;Deployment Process
&lt;/h2&gt;&lt;p&gt;First, to verify the program functionality, you need to deploy it on your local machine. After that, you can use nginx as a reverse proxy tool to expose the port, so that others can access your blog on the public network. Then follow the same steps on the server. The specific process is as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Install the virtualenv Python virtual environment with &lt;code&gt;pip install virtualenv&lt;/code&gt; or &lt;code&gt;pip3 install virtualenv&lt;/code&gt;. Then use virtualenv to create a venv environment in a suitable directory, for example under this project with &lt;code&gt;virtualenv venv&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Activate the virtualenv environment by running the activate script in the venv directory: &lt;code&gt;. venv/bin/activate&lt;/code&gt;. Note the position of the dot. After this, you will see the (venv) marker at the beginning of the command line.&lt;/li&gt;
&lt;li&gt;Install all modules listed in requirements.txt within the virtual environment: &lt;code&gt;pip3 install -r requirements.txt&lt;/code&gt;. If installation is too slow, you may need to configure a domestic pip source. See the pip official page for how to change the pip source.&lt;/li&gt;
&lt;li&gt;Import environment variables by creating an &lt;code&gt;env&lt;/code&gt; file in the project directory with the following fields:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MAIL_USERNAME=email@example.com&lt;/code&gt; (Email used by the server to send verification codes, an email account with smtp service enabled. The program uses QQ email by default, modify the config file to use other types of email)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MAIL_PASSWORD=password&lt;/code&gt; (Password for the above email, note that QQ email uses a special 16-digit password)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FLASK_ADMIN=admin@example.com&lt;/code&gt; (After the server is running, an account created with this email will be the administrator)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MAIL_SERVER=smtp.qq.com&lt;/code&gt; (Email server address)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FLASKY_MAIL_SENDER=example@foxmail.com&lt;/code&gt; (Sender&amp;rsquo;s email)&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Set up database migration by entering the following commands:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;python manager.py db init&lt;/code&gt; (The init command creates a migration repository, which will add a migrations folder)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;python manager.py db migrate -m &amp;quot;initial migration&amp;quot;&lt;/code&gt; (The migrate command is used to automatically create migration scripts)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;python manager.py db upgrade&lt;/code&gt; (Update the database. The first time you use this command, it will create a new database called data-dev.sqlite)&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;Deploy the program: &lt;code&gt;python manager.py deploy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Run the program locally: &lt;code&gt;python manager.py runserver&lt;/code&gt;. Open http://127.0.0.1:5000 to view it, press Ctrl+C to exit the program.&lt;/li&gt;
&lt;li&gt;If running on a server and you want to preserve data, you can copy the migrations folder and the data-dev.sqlite database to the server, then use &lt;code&gt;./venv/bin/gunicorn -w 4 -b 127.0.0.1:8080 manager:app&lt;/code&gt;. At this point, you should be able to see the webpage on port 8080, and this port is exposed to the external network. Enter the server address in your local browser, and you will be able to see the blog.&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
    </channel>
</rss>
